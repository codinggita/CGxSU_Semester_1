# Assignment: Dijkstra's Algorithm

## Overview

This assignment focuses on Dijkstra's algorithm for finding shortest paths in weighted graphs with non-negative edge weights. This greedy algorithm is fundamental for navigation systems, network routing, and optimization problems.

---

## Key Concepts

**Dijkstra's Algorithm:**
- Finds shortest paths from a source vertex to all other vertices
- Requires non-negative edge weights
- Uses a priority queue for efficiency
- Time complexity: $O((V+E) \log V)$ with binary heap

---

## Problems

### Problem 1-5: Basic Dijkstra Applications

**Task:** Apply Dijkstra's algorithm to find shortest distances from the source vertex.

**General Solution Approach:**
1. Initialize: distance[source] = 0, all others = âˆž
2. Use priority queue to extract minimum distance vertex
3. Relax edges: update distances of neighbors
4. Repeat until queue is empty

**(Solutions follow standard Dijkstra execution with distance tables)** $\square$

---

### Problem 6-10: Shortest Path Trees

**Task:** Construct shortest path trees and find specific paths.

**Approach:**
- Track parent pointers during Dijkstra execution
- Reconstruct paths by backtracking from destination
- Verify optimality using distance labels

**(Solutions include full Dijkstra tables with parent tracking)** $\square$

---

### Problem 11-15: Advanced Applications

**Tasks:**
- Find all shortest paths from source
- Determine minimum routing costs
- Apply Dijkstra with step-by-step iteration tables
- Priority queue method demonstration

**Example Solution Structure:**

For a weighted graph, Dijkstra proceeds as:

| Iteration | Vertex | Distance | Parent | Queue |
|-----------|--------|----------|--------|-------|
| 0         | Start  | 0        | -      | All   |
| 1         | ...    | ...      | ...    | ...   |

Final distances represent shortest path costs from source. $\square$

---

## Summary

This assignment covered:
- Dijkstra's algorithm implementation
- Shortest path tree construction
- Distance label relaxation
- Priority queue optimization
- Applications in routing and navigation

**Key Limitation:** Dijkstra requires **non-negative weights**. For negative weights, use Bellman-Ford algorithm instead.
