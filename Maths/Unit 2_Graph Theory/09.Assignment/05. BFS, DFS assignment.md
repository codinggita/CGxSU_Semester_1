# Assignment: BFS and DFS Traversals

## Overview

This assignment covers Breadth-First Search (BFS) and Depth-First Search (DFS), two fundamental graph traversal algorithms. These algorithms form the basis for many graph problems including pathfinding, cycle detection, and connectivity analysis.

---

## Key Concepts

**BFS:** Level-by-level traversal using a queue (FIFO). Finds shortest paths in unweighted graphs.

**DFS:** Depth-first traversal using a stack or recursion (LIFO). Useful for cycle detection and topological sorting.

---

## Problems

### Problem 1: BFS Traversal

Given the graph:

```
A — B — C
|
D
```

**Task:** Perform BFS starting from $A$ and write the BFS order.

**Solution:**

**BFS Process:**
- Start: $A$ (queue: $[A]$)
- Visit $A$, enqueue neighbors: $B, D$ (queue: $[B, D]$)
- Visit $B$, enqueue $C$ (queue: $[D, C]$)
- Visit $D$ (queue: $[C]$)
- Visit $C$ (queue: $[]$)

**BFS Order: $A, B, D, C$** $\square$

---

### Problem 2: DFS Traversal

Given the graph:

```
1 — 2 — 3
    |
    4
```

**Task:** Perform DFS starting from $1$ and write the DFS order.

**Solution:**

**DFS Process (stack-based):**
- Start: $1$ (stack: $[1]$)
- Visit $1$, push $2$ (stack: $[2]$)
- Visit $2$, push $3, 4$ (stack: $[3, 4]$)
- Visit $4$ (stack: $[3]$)
- Visit $3$ (stack: $[]$)

**DFS Order: $1, 2, 4, 3$** (or $1, 2, 3, 4$ depending on neighbor order) $\square$

---

### Problem 3-5: BFS with Level Tracking

For these problems, track the BFS level of each vertex:

**Problem 3:** Graph with vertices $\{S, A, B, C\}$

**Problem 4:** Graph with vertices $\{X, Y, Z, W\}$

**Problem 5:** Track parent pointers in BFS tree

**(Solutions follow the same pattern as Problem 1 with added level/parent tracking)** $\square$

---

### Problem 6-10: DFS Applications

**Problem 6-7:** DFS traversal on various graphs

**Problem 8:** DFS with parent tracking

**Problem 9:** DFS on cycle graph $C_4$

**Problem 10:** DFS on directed graph

**(Solutions apply DFS systematically with appropriate data structures)** $\square$

---

### Problem 11: BFS and DFS Comparison

Given the graph:

```
A — B — C
|     /
D — E — F
```

**Tasks:**
(a) Perform BFS from $A$
(b) Perform DFS from $A$
(c) Compare the orders

**Solution:**

**(a) BFS from $A$:**
Level 0: $A$
Level 1: $B, D$
Level 2: $C, E$
Level 3: $F$

**BFS Order: $A, B, D, C, E, F$**

**(b) DFS from $A$:**
Following left-most branch first:

**DFS Order: $A, B, C, E, D, F$** (varies by implementation)

**(c) Comparison:**
- BFS explores level-by-level (shortest path)
- DFS explores depth-first (deeper exploration before backtracking) $\square$

---

### Problem 12-15: BFS Trees and Distance Calculation

**Problem 12:** Construct BFS tree from source

**Problem 13:** Find discovery and finishing times in DFS

**Problem 14:** Calculate distance of each vertex from source using BFS

**Problem 15:** Identify tree edges and back edges in DFS

**(Solutions construct explicit BFS/DFS trees with timing)** $\square$

---

### Problem 16-18: Advanced Applications

**Problem 16:** BFS to identify connected components in disconnected graph

**Problem 17:** DFS tree construction

**Problem 18:** Comparison of BFS vs DFS for finding specific vertex

**(Solutions apply algorithms to multi-component graphs)** $\square$

---

### Problem 19: Shortest Path with BFS

Given the graph:

```
2 — 3 — 4
|       |
1 — — — 5
```

**Task:** Find the shortest path from $2$ to $5$ using BFS.

**Solution:**

**BFS from $2$:**
- Level 0: $2$
- Level 1: $1, 3$
- Level 2: $5, 4$

**Shortest path:** $2 \to 1 \to 5$ (distance = 2)

Alternatively: $2 \to 3 \to 4 \to 5$ (distance = 3)

**BFS finds the shortest: $2 \to 1 \to 5$** with distance 2. $\square$

---

### Problem 20: Cycle Detection with DFS

Given the graph:

```
A — B — C
|       |
| — — — D
```

**Task:** Use DFS to determine if a cycle exists.

**Solution:**

**DFS from $A$:**
- Visit $A$, mark as visiting
- Explore $B$: visit $B$, mark as visiting
- Explore $C$: visit $C$, mark as visiting
- Explore $D$: visit $D$, mark as visiting
- From $D$, neighbor $A$ is already visiting → **back edge detected**

**Conclusion:** Cycle exists: $A \to B \to C \to D \to A$ $\square$

---

## Summary

This assignment covered:
- **BFS:** Queue-based, finds shortest paths, level-order traversal
- **DFS:** Stack/recursion-based, detects cycles, explores deeply
- **Applications:** Shortest paths, connectivity, cycle detection, tree construction
- **Complexity:** Both $O(V + E)$ for adjacency list representation

Master these fundamental algorithms as they form the foundation for advanced graph algorithms.
