# Shortest Path Algorithms

## Learning Objectives

- Understand the shortest path problem and its variations
- Master Dijkstra's algorithm for non-negative weighted graphs
- Understand Bellman-Ford algorithm for graphs with negative weights
- Learn Floyd-Warshall algorithm for all-pairs shortest paths
- Analyze correctness and complexity of shortest path algorithms
- Apply shortest path algorithms to real-world problems
- Understand negative weight cycles and their detection

## Prerequisites

- Graph theory fundamentals
- Graph representations (adjacency matrix, adjacency list)
- Priority queues and heaps
- Dynamic programming basics
- Algorithm complexity analysis

## Definitions and Theoretical Foundations

### Definition 7.1 (Shortest Path Problem)

Given a weighted graph $G = (V, E, w)$ with weight function $w: E \to \mathbb{R}$ and vertices $s, t \in V$, the **shortest path problem** is to find a path from $s$ to $t$ with minimum total weight.

**Weight of path** $P = v_0, v_1, \ldots, v_k$:
$$w(P) = \sum_{i=1}^{k} w(v_{i-1}, v_i)$$

**Shortest path distance** $\delta(s, t)$ is the minimum weight over all paths from $s$ to $t$, or $\infty$ if no path exists.

### Variations

1. **Single-source shortest path (SSSP):** Find shortest paths from one source $s$ to all vertices
2. **Single-destination:** Find shortest paths from all vertices to one destination $t$ (equivalent to SSSP by reversing edges)
3. **All-pairs shortest paths (APSP):** Find shortest paths between all pairs of vertices
4. **Single-pair:** Find shortest path between specific $s$ and $t$ (no better algorithm than SSSP in general)

### Theorem 7.1 (Optimal Substructure)

Any subpath of a shortest path is itself a shortest path.

**Proof:** Suppose $p$ is a shortest path from $u$ to $v$, and $p'$ is a subpath from $x$ to $y$ within $p$. If there were a shorter path $p''$ from $x$ to $y$, we could replace $p'$ with $p''$ in $p$ to get a shorter path from $u$ to $v$, contradicting the optimality of $p$. $\square$

### Definition 7.2 (Negative Weight Cycle)

A **negative weight cycle** is a cycle whose total weight is negative. If such a cycle is reachable from source $s$, then shortest paths are undefined (can infinitely decrease weight by repeating the cycle).

## Dijkstra's Algorithm

### Algorithm Description

**Dijkstra's algorithm** finds shortest paths from source $s$ to all vertices in a graph with **non-negative edge weights**.

**Key Idea:** Greedily select the closest unvisited vertex and update distances.

**Data Structures:**
- Distance array $d[v]$: current shortest distance from $s$ to $v$
- Priority queue $Q$: vertices ordered by distance
- Parent array $\pi[v]$: predecessor on shortest path

**Algorithm:**
1. Initialize: $d[s] = 0$, $d[v] = \infty$ for $v \neq s$
2. Insert all vertices into priority queue $Q$ with keys $d[v]$
3. While $Q$ is not empty:
   - Extract vertex $u$ with minimum $d[u]$ from $Q$
   - For each neighbor $v$ of $u$:
     - If $d[u] + w(u, v) < d[v]$:
       - $d[v] = d[u] + w(u, v)$ (relaxation)
       - $\pi[v] = u$
       - Decrease key of $v$ in $Q$

### Theorem 7.2 (Dijkstra's Correctness)

For graphs with non-negative edge weights, Dijkstra's algorithm correctly computes shortest paths from source $s$.

**Proof Sketch:** By induction on number of vertices finalized. When vertex $u$ is extracted with distance $d[u]$, this is the true shortest distance (any other path would have to go through a vertex with distance ≥ $d[u]$ first, but all edge weights are non-negative). $\square$

### Complexity

- **Time complexity:**
  - With binary heap: $O((V + E) \log V)$
  - With Fibonacci heap: $O(E + V \log V)$
  - With array (dense graphs): $O(V^2)$
- **Space complexity:** $O(V)$

## Bellman-Ford Algorithm

### Algorithm Description

**Bellman-Ford algorithm** handles graphs with **negative edge weights** and detects negative weight cycles.

**Algorithm:**
1. Initialize: $d[s] = 0$, $d[v] = \infty$ for $v \neq s$
2. For $i = 1$ to $V - 1$:
   - For each edge $(u, v) \in E$:
     - Relax: if $d[u] + w(u, v) < d[v]$, set $d[v] = d[u] + w(u, v)$
3. Check for negative cycles:
   - For each edge $(u, v) \in E$:
     - If $d[u] + w(u, v) < d[v]$: return "negative cycle exists"

### Theorem 7.3 (Bellman-Ford Correctness)

If graph contains no negative weight cycles reachable from $s$, Bellman-Ford correctly computes shortest paths. If it does, the algorithm detects it.

**Proof:** After $k$ iterations, $d[v]$ equals the shortest path distance using at most $k$ edges. Since shortest simple paths use at most $V - 1$ edges, $V - 1$ iterations suffice. $\square$

### Complexity

- **Time:** $O(VE)$
- **Space:** $O(V)$

## Floyd-Warshall Algorithm

### Algorithm Description

**Floyd-Warshall** computes shortest paths between **all pairs of vertices** using dynamic programming.

**Recurrence:** Let $d^{(k)}[i][j]$ be the shortest path from $i$ to $j$ using only vertices $\{1, \ldots, k\}$ as intermediates.

$$d^{(k)}[i][j] = \min(d^{(k-1)}[i][j], d^{(k-1)}[i][k] + d^{(k-1)}[k][j])$$

**Algorithm:**
1. Initialize: $d[i][j] = w(i, j)$ if edge exists, else $\infty$; $d[i][i] = 0$
2. For $k = 1$ to $V$:
   - For $i = 1$ to $V$:
     - For $j = 1$ to $V$:
       - $d[i][j] = \min(d[i][j], d[i][k] + d[k][j])$

### Complexity

- **Time:** $O(V^3)$
- **Space:** $O(V^2)$

## Worked Examples

### Example 1 (Simple): Dijkstra's Algorithm

**Problem:** Find shortest paths from $A$ using Dijkstra's:

Edges: $(A,B,4)$, $(A,C,2)$, $(B,C,1)$, $(B,D,5)$, $(C,D,3)$

**Solution:**

| Step | Extract | $d[A]$ | $d[B]$ | $d[C]$ | $d[D]$ |
|------|---------|--------|--------|--------|--------|
| 0    | -       | 0      | ∞      | ∞      | ∞      |
| 1    | A       | 0      | 4      | 2      | ∞      |
| 2    | C       | 0      | 3      | 2      | 5      |
| 3    | B       | 0      | 3      | 2      | 5      |
| 4    | D       | 0      | 3      | 2      | 5      |

**Shortest distances:** $A \to B: 3$, $A \to C: 2$, $A \to D: 5$ $\square$

---

### Example 2 (Intermediate): Bellman-Ford with Negative Weights

**Problem:** Find shortest paths from $A$:

Edges: $(A,B,4)$, $(A,C,2)$, $(B,C,-3)$, $(C,D,1)$

**Solution:**

After iteration 1: $d[B] = 4$, $d[C] = 2$, $d[D] = 3$

After iteration 2: $d[B] = 4$, $d[C] = 1$ (via $B$), $d[D] = 2$

After iteration 3: No changes.

**Shortest distances:** $A \to C: 1$, $A \to D: 2$ $\square$

---

### Example 3 (Challenging): Floyd-Warshall

**Problem:** Find all-pairs shortest paths:

Vertices: $\{1, 2, 3\}$

Edges: $(1,2,3)$, $(2,3,1)$, $(1,3,7)$

**Solution:**

Initial:
$$D^{(0)} = \begin{bmatrix} 0 & 3 & 7 \\ \infty & 0 & 1 \\ \infty & \infty & 0 \end{bmatrix}$$

After $k=1$: $D^{(1)}$ (paths via vertex 1)

After $k=2$: $d[1][3] = \min(7, 3 + 1) = 4$

Final:
$$D = \begin{bmatrix} 0 & 3 & 4 \\ \infty & 0 & 1 \\ \infty & \infty & 0 \end{bmatrix}$$

**Answer:** Shortest path $1 \to 3: 4$ (via vertex 2). $\square$

## Applications

**GPS Navigation:** Dijkstra's for road networks

**Network Routing:** OSPF protocol uses shortest paths

**Game AI:** Pathfinding for NPCs

**Finance:** Arbitrage detection (negative cycles in currency exchange)

## Common Mistakes

1. **Using Dijkstra with negative weights:** Fails! Use Bellman-Ford instead.
2. **Forgetting negative cycle detection:** Can cause infinite loops.
3. **Confusing SSSP vs. APSP:** Choose appropriate algorithm.

## Summary

1. **Dijkstra:** Non-negative weights, $O((V+E) \log V)$
2. **Bellman-Ford:** Handles negative weights, $O(VE)$
3. **Floyd-Warshall:** All-pairs, $O(V^3)$

---

**Further Study:** A* search, Johnson's algorithm, bidirectional search.
