# Applications of Graphs in Computer Science

## Learning Objectives

- Understand how graph theory models real-world systems
- Apply graphs to network analysis and routing
- Use graphs for social network analysis
- Model dependencies and scheduling with DAGs
- Apply graph algorithms to compiler design and optimization
- Understand web graph structure and PageRank
- Recognize graph problems in databases, AI, and distributed systems

## Prerequisites

- Graph theory fundamentals
- Graph algorithms (traversal, shortest paths, spanning trees)
- Basic understanding of computer systems
- Complexity analysis

## Applications Overview

### 1. Network Routing and Communication

**Problem:** Route data packets efficiently across computer networks.

**Graph Model:**
- Vertices = routers, switches, computers
- Edges = physical or logical connections
- Weights = latency, bandwidth, cost

**Algorithms:**
- **Dijkstra's algorithm:** Find shortest path for packet routing
- **Spanning trees:** Prevent broadcast storms (Spanning Tree Protocol)
- **Maximum flow:** Optimize network capacity

**Example:** Internet routing protocols (OSPF, BGP) use shortest path algorithms to direct traffic.

### 2. Social Network Analysis

**Problem:** Analyze relationships and information flow in social networks.

**Graph Model:**
- Vertices = users
- Edges = friendships, follows, interactions
- Weights = interaction frequency, relationship strength

**Key Metrics:**
- **Degree centrality:** Number of connections (influence)
- **Betweenness centrality:** How often a user lies on shortest paths (bridge between communities)
- **Clustering coefficient:** Density of connections among neighbors
- **Community detection:** Identify tightly-knit groups

**Algorithms:**
- **BFS:** Find degrees of separation
- **Connected components:** Identify isolated communities
- **PageRank variant:** Rank influential users

**Example:** Facebook friendship graphs, Twitter follower networks, LinkedIn professional connections.

### 3. Compiler Design and Program Analysis

**Problem:** Optimize code execution and manage dependencies.

**Graph Models:**

**a) Control Flow Graph (CFG):**
- Vertices = basic blocks (straight-line code)
- Edges = control flow (jumps, branches)
- Applications: Dead code elimination, loop optimization

**b) Data Dependency Graph:**
- Vertices = instructions or variables
- Edges = data dependencies
- Applications: Instruction scheduling, parallelization

**c) Call Graph:**
- Vertices = functions/methods
- Edges = function calls
- Applications: Inlining decisions, detecting recursion

**Algorithms:**
- **DFS:** Detect cycles (identify loops, recursive calls)
- **Topological sort:** Order compilation units
- **Dominance analysis:** Optimize control flow

### 4. Task Scheduling and Project Management

**Problem:** Schedule tasks respecting dependencies and minimize completion time.

**Graph Model (DAG):**
- Vertices = tasks
- Directed edges = dependencies ($u \to v$ means $u$ must complete before $v$)
- Weights = task duration

**Algorithms:**
- **Topological sort:** Find valid execution order
- **Critical path method (CPM):** Identify longest path (determines minimum project duration)
- **PERT (Program Evaluation Review Technique):** Probabilistic scheduling

**Example:** Build systems (Make, Maven), CPU instruction scheduling, project management software.

### 5. Web Structure and Search Engines

**Problem:** Rank web pages by importance and navigate the web graph.

**Graph Model:**
- Vertices = web pages
- Directed edges = hyperlinks
- Properties: Billions of vertices, highly connected, small-world network

**PageRank Algorithm:**

Assign each page a rank based on incoming links from important pages.

**Recurrence:**
$$PR(v) = \frac{1-d}{N} + d \sum_{u \in \text{In}(v)} \frac{PR(u)}{|\text{Out}(u)|}$$

where $d \approx 0.85$ is damping factor, $N$ is total pages.

**Implementation:** Power iteration on transition matrix.

**Other Applications:**
- **Crawling:** BFS to discover pages
- **Link analysis:** Identify spam networks
- **Hub and authority scores (HITS):** Distinguish authoritative pages from hub pages

### 6. Databases and Data Storage

**Problem:** Optimize query execution and maintain data integrity.

**Graph Applications:**

**a) Query Optimization:**
- Query plan represented as tree/DAG
- Optimize join order using graph algorithms

**b) Dependency Tracking:**
- Functional dependencies in normalization
- Detect circular dependencies in views

**c) Graph Databases:**
- Native graph storage (Neo4j, Amazon Neptune)
- Efficiently query relationships (social networks, recommendation systems)

**Algorithms:**
- **Shortest paths:** Find connections in knowledge graphs
- **Connected components:** Cluster related entities
- **Pattern matching:** Subgraph isomorphism

### 7. Artificial Intelligence and Machine Learning

**Problem:** Represent knowledge, learn from structured data, plan actions.

**Graph Applications:**

**a) Knowledge Graphs:**
- Vertices = entities
- Edges = relationships
- Examples: Google Knowledge Graph, Wikidata

**b) Neural Network Architecture:**
- Computation graphs for backpropagation
- Graph neural networks (GNNs) learn on graph-structured data

**c) Planning and Search:**
- State-space graph
- A* search for pathfinding
- Game trees for adversarial search

**d) Probabilistic Graphical Models:**
- Bayesian networks (DAGs)
- Markov networks (undirected graphs)
- Represent conditional independence

**Algorithms:**
- **Graph traversal:** Explore state spaces
- **Shortest paths:** Optimal planning
- **Graph convolutions:** Learn node representations

### 8. Operating Systems

**Problem:** Manage resources, detect deadlocks, schedule processes.

**Graph Applications:**

**a) Deadlock Detection:**
- Resource allocation graph
- Vertices = processes and resources
- Cycle detection identifies deadlock

**b) Process Synchronization:**
- Wait-for graph
- Detect circular waits

**c) Memory Management:**
- Page reference graph
- Optimize page replacement

### 9. Bioinformatics

**Problem:** Analyze biological networks and sequences.

**Graph Applications:**

**a) Protein Interaction Networks:**
- Vertices = proteins
- Edges = interactions
- Identify functional modules

**b) Metabolic Pathways:**
- Vertices = metabolites
- Edges = reactions
- Shortest paths = alternative metabolic routes

**c) Phylogenetic Trees:**
- Evolutionary relationships
- Tree reconstruction algorithms

**d) Sequence Assembly:**
- De Bruijn graphs for genome assembly

### 10. Distributed Systems and Blockchain

**Problem:** Achieve consensus, track transactions, prevent conflicts.

**Graph Applications:**

**a) Blockchain:**
- DAG of transactions (Bitcoin, Ethereum)
- Merkle trees for verification
- Distributed ledger as graph

**b) Distributed Algorithms:**
- Spanning tree construction for broadcast
- Leader election using graph properties
- Consensus protocols on communication graphs

**c) Cloud Infrastructure:**
- Data center network topology
- Load balancing using graph partitioning

## Worked Example: Critical Path Method

**Problem:** A project has tasks with dependencies:

| Task | Duration | Prerequisites |
|------|----------|---------------|
| A    | 3        | -             |
| B    | 2        | A             |
| C    | 5        | A             |
| D    | 3        | B             |
| E    | 4        | C, D          |

Find minimum project duration.

**Solution:**

1. Construct DAG:
   - Vertices: $\{Start, A, B, C, D, E, End\}$
   - Edges represent dependencies

2. Find longest path (critical path):
   - Start → A → C → E → End
   - Duration: $0 + 3 + 5 + 4 = 12$

Alternative path: Start → A → B → D → E → End
- Duration: $0 + 3 + 2 + 3 + 4 = 12$

**Critical path:** Both paths are critical with duration 12.

**Minimum project duration:** 12 time units. $\square$

## Common Graph Problems in CS

| Problem | Graph Type | Algorithm | Application |
|---------|-----------|-----------|-------------|
| Shortest path | Weighted | Dijkstra, Bellman-Ford | GPS, routing |
| Minimum spanning tree | Weighted, undirected | Kruskal, Prim | Network design |
| Maximum flow | Weighted, directed | Ford-Fulkerson | Network capacity |
| Topological sort | DAG | DFS | Task scheduling |
| Strongly connected components | Directed | Tarjan, Kosaraju | Compiler optimization |
| Bipartite matching | Bipartite | Hungarian, Hopcroft-Karp | Job assignment |
| Graph coloring | Undirected | Greedy, backtracking | Register allocation |
| Cycle detection | Any | DFS | Deadlock detection |
| Connectivity | Any | DFS, BFS | Network reliability |

## Summary

Graphs model relationships in countless computer science domains:

1. **Networks:** Routing, topology design
2. **Social:** Influence analysis, community detection
3. **Compilers:** Control flow, optimization
4. **Scheduling:** Task dependencies, critical paths
5. **Web:** PageRank, crawling
6. **Databases:** Query optimization, graph DBs
7. **AI:** Knowledge graphs, planning, GNNs
8. **OS:** Deadlock detection, resource allocation
9. **Bioinformatics:** Protein networks, genome assembly
10. **Distributed systems:** Consensus, blockchain

Graph algorithms (BFS, DFS, Dijkstra, MST, flow) are foundational tools for solving real-world computational problems.

---

**Further Study:** Advanced topics include graph neural networks, temporal graphs, streaming algorithms, and approximation algorithms for NP-hard graph problems.
