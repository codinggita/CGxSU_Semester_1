# Graph Traversals

## Learning Objectives

- Understand systematic methods for exploring all vertices and edges of a graph
- Master Breadth-First Search (BFS) algorithm and its properties
- Master Depth-First Search (DFS) algorithm and its properties
- Analyze time and space complexity of traversal algorithms
- Apply BFS for shortest path finding in unweighted graphs
- Apply DFS for cycle detection, topological sorting, and connected components
- Prove correctness of traversal algorithms
- Distinguish appropriate use cases for BFS vs. DFS

## Prerequisites

- Graph theory fundamentals (vertices, edges, paths, connectivity)
- Graph representations (adjacency matrix, adjacency list)
- Basic data structures (queues, stacks, recursion)
- Algorithm analysis and Big-O notation

## Definitions and Theoretical Foundations

### Definition 6.1 (Graph Traversal)

A **graph traversal** is a systematic method to visit all vertices of a graph, ensuring each vertex is processed exactly once.

### Definition 6.2 (Breadth-First Search - BFS)

**Breadth-First Search** explores a graph level by level, visiting all neighbors of a vertex before proceeding to their neighbors.

**Algorithm Structure:**
1. Start from source vertex $s$
2. Use a **queue** (FIFO) to maintain vertices to visit
3. Mark $s$ as visited, enqueue $s$
4. While queue is not empty:
   - Dequeue vertex $v$
   - For each unvisited neighbor $u$ of $v$:
     - Mark $u$ as visited
     - Enqueue $u$

**Data Structure:** Queue (First-In, First-Out)

### Theorem 6.1 (BFS Correctness)

BFS starting from vertex $s$ visits every vertex reachable from $s$ exactly once.

**Proof:**

By contradiction. Suppose BFS misses some reachable vertex $v$.

Let $d(s, v)$ be the shortest path distance from $s$ to $v$. Among all missed vertices, choose $v$ with minimum $d(s, v) = k$.

There exists a shortest path $s = v_0, v_1, \ldots, v_k = v$ of length $k$.

Since $d(s, v_{k-1}) = k - 1 < k$, vertex $v_{k-1}$ is visited (by minimality of $k$).

When BFS processes $v_{k-1}$, it examines all neighbors, including $v$. Since $v$ is unvisited at that point, it gets enqueued and later visited. Contradiction.

Therefore, BFS visits all reachable vertices. $\square$

### Theorem 6.2 (BFS Shortest Path)

BFS computes the shortest path distance from source $s$ to every reachable vertex in an **unweighted graph**.

**Proof:**

We prove by induction on distance $k$ from $s$ that BFS correctly finds all vertices at distance $k$ before finding any vertex at distance $k + 1$.

**Base case:** $k = 0$. Only $s$ is at distance 0, and BFS starts by visiting $s$. ✓

**Inductive step:** Assume BFS correctly identifies all vertices at distance ≤ $k$ before any vertex at distance $> k$.

Consider a vertex $u$ at distance $k + 1$. There exists a shortest path of length $k + 1$ ending with edge $\{v, u\}$ where $d(s, v) = k$.

By the inductive hypothesis, $v$ is visited before any vertex at distance $> k$. When BFS processes $v$, it examines $u$. If $u$ is unvisited, it gets enqueued at distance $k + 1$.

Therefore, BFS discovers all vertices at distance $k + 1$ correctly. $\square$

### Definition 6.3 (Depth-First Search - DFS)

**Depth-First Search** explores a graph by going as deep as possible along each branch before backtracking.

**Algorithm Structure (Recursive):**
1. Start from source vertex $s$
2. Mark $s$ as visited
3. For each unvisited neighbor $u$ of $s$:
   - Recursively apply DFS to $u$

**Algorithm Structure (Iterative):**
- Use a **stack** (LIFO) instead of recursion
- Similar to BFS but with stack replacing queue

**Data Structure:** Stack (Last-In, First-Out) or recursion call stack

### Theorem 6.3 (DFS Correctness)

DFS starting from vertex $s$ visits every vertex reachable from $s$ exactly once.

**Proof:**

Similar to BFS proof. By contradiction, suppose DFS misses a reachable vertex $v$.

Choose the missed vertex $v$ closest to $s$ (minimum distance). There's a path from $s$ to $v$ through some vertex $u$ adjacent to $v$.

Since $u$ is closer to $s$, it's visited. When DFS processes $u$, it explores all unvisited neighbors, including $v$. Thus $v$ gets visited, contradiction. $\square$

### Definition 6.4 (DFS Forest and Discovery/Finish Times)

During DFS on a graph, edges are classified:
- **Tree edges:** Edges in the DFS traversal tree
- **Back edges:** Edges to ancestors in DFS tree
- **Forward edges:** Edges to descendants (not direct children)
- **Cross edges:** Edges between different branches

Each vertex $v$ gets:
- **Discovery time** $d[v]$: when $v$ is first visited
- **Finish time** $f[v]$: when DFS completes processing $v$

### Theorem 6.4 (Parenthesis Theorem)

For any two vertices $u$ and $v$ in a DFS, exactly one of the following holds:
1. Intervals $[d[u], f[u]]$ and $[d[v], f[v]]$ are disjoint (neither is ancestor of other)
2. $[d[u], f[u]] \subset [d[v], f[v]]$ (u is descendant of v)
3. $[d[v], f[v]] \subset [d[u], f[u]]$ (v is descendant of u)

### Theorem 6.5 (Cycle Detection using DFS)

A graph contains a cycle if and only if DFS finds a **back edge**.

**Proof:**

($\Rightarrow$) If a cycle exists, let $v$ be the first vertex in the cycle visited by DFS. Following the cycle, DFS eventually reaches a vertex $u$ adjacent to $v$ while $v$ is still on the DFS stack. The edge $\{u, v\}$ is a back edge.

($\Leftarrow$) If there's a back edge $\{u, v\}$ where $v$ is an ancestor of $u$ in the DFS tree, then the path from $v$ to $u$ in the tree plus the back edge forms a cycle. $\square$

### Complexity Analysis

| Algorithm | Time Complexity (Adjacency List) | Time Complexity (Adjacency Matrix) | Space Complexity |
|-----------|----------------------------------|-------------------------------------|------------------|
| **BFS** | $O(V + E)$ | $O(V^2)$ | $O(V)$ |
| **DFS** | $O(V + E)$ | $O(V^2)$ | $O(V)$ |

**Explanation:**
- Each vertex is visited once: $O(V)$
- Each edge is examined once (undirected) or twice (directed): $O(E)$
- Queue/stack stores at most $O(V)$ vertices

## Worked Examples

### Example 1 (Simple): BFS Traversal

**Problem:** Perform BFS starting from vertex $A$ on the graph:

```
   A --- B --- C
   |           |
   D --- E --- F
```

Edges: $\{A,B\}, \{A,D\}, \{B,C\}, \{D,E\}, \{E,F\}, \{C,F\}$

**Solution:**

Start: $s = A$

1. Visit $A$, enqueue: Queue = $[A]$, Visited = $\{A\}$
2. Dequeue $A$, explore neighbors $B, D$:
   - Visit $B$, $D$: Queue = $[B, D]$, Visited = $\{A, B, D\}$
3. Dequeue $B$, explore neighbors: $A$ (visited), $C$ (new)
   - Visit $C$: Queue = $[D, C]$, Visited = $\{A, B, D, C\}$
4. Dequeue $D$, explore neighbors: $A$ (visited), $E$ (new)
   - Visit $E$: Queue = $[C, E]$, Visited = $\{A, B, D, C, E\}$
5. Dequeue $C$, explore neighbors: $B$ (visited), $F$ (new)
   - Visit $F$: Queue = $[E, F]$, Visited = $\{A, B, D, C, E, F\}$
6. Dequeue $E$, explore neighbors: all visited
7. Dequeue $F$, explore neighbors: all visited

**BFS Order:** $A, B, D, C, E, F$ $\square$

---

### Example 2 (Intermediate): BFS Shortest Path

**Problem:** Using BFS from Example 1, find the shortest path from $A$ to $F$ and its length.

**Solution:**

BFS discovers vertices in order: $A$ (distance 0), $B, D$ (distance 1), $C, E$ (distance 2), $F$ (distance 3).

Track parent pointers during BFS:
- $parent[B] = A$, $parent[D] = A$
- $parent[C] = B$, $parent[E] = D$
- $parent[F] = C$

Reconstruct path from $F$ to $A$:
$$F \leftarrow C \leftarrow B \leftarrow A$$

**Shortest path:** $A \to B \to C \to F$ with length 3. $\square$

---

### Example 3 (Intermediate): DFS Traversal

**Problem:** Perform DFS starting from vertex $A$ on the same graph from Example 1.

**Solution:**

Start: $s = A$, Stack = $[A]$

1. Pop $A$, visit, push unvisited neighbors: Stack = $[D, B]$, Visited = $\{A\}$
2. Pop $B$, visit, push unvisited neighbors: Stack = $[D, C]$, Visited = $\{A, B\}$
3. Pop $C$, visit, push unvisited neighbors: Stack = $[D, F]$, Visited = $\{A, B, C\}$
4. Pop $F$, visit, push unvisited neighbors: Stack = $[D, E]$, Visited = $\{A, B, C, F\}$
5. Pop $E$, visit, push unvisited neighbors: Stack = $[D]$, Visited = $\{A, B, C, F, E\}$
6. Pop $D$, visit (all neighbors visited): Stack = $[]$, Visited = $\{A, B, C, F, E, D\}$

**DFS Order:** $A, B, C, F, E, D$ $\square$

---

### Example 4 (Challenging): Cycle Detection

**Problem:** Use DFS to detect if the following graph contains a cycle:

```
A → B → C
↓   ↑
D ← ← ←
```

Edges: $A \to B$, $B \to C$, $A \to D$, $D \to B$

**Solution:**

DFS from $A$:
1. Visit $A$, explore $B$
2. Visit $B$, explore $C$
3. Visit $C$ (no outgoing edges), backtrack
4. Back at $B$, done with $B$, backtrack
5. Back at $A$, explore $D$
6. Visit $D$, explore $B$ — **$B$ is already visited but not finished (still on stack)**

Edge $D \to B$ is a **back edge**, indicating a cycle: $B \to C \to (backtrack) \to B \to D \to B$ or more simply $B \to ... \to D \to B$.

**Answer:** Cycle detected. $\square$

---

### Example 5 (Challenging): Connected Components using DFS

**Problem:** Find all connected components of the graph:

Vertices: $\{1, 2, 3, 4, 5, 6\}$

Edges: $\{\{1,2\}, \{2,3\}, \{4,5\}\}$

**Solution:**

Initialize all vertices as unvisited. Run DFS from each unvisited vertex:

**Component 1:** Start DFS from 1
- Visit 1, explore 2
- Visit 2, explore 3
- Visit 3, no more neighbors
- Component: $\{1, 2, 3\}$

**Component 2:** Start DFS from 4 (unvisited)
- Visit 4, explore 5
- Visit 5, no more neighbors
- Component: $\{4, 5\}$

**Component 3:** Vertex 6 is isolated
- Component: $\{6\}$

**Answer:** 3 connected components: $\{1, 2, 3\}$, $\{4, 5\}$, $\{6\}$ $\square$

---

### Example 6 (Advanced): Topological Sort using DFS

**Problem:** Perform a topological sort on the DAG:

```
A → B → D
↓   ↓
C → E
```

Edges: $A \to B$, $A \to C$, $B \to D$, $B \to E$, $C \to E$

**Solution:**

Run DFS and record finish times (vertices are added to output in reverse finish order):

1. Start DFS from $A$:
   - Visit $A$, explore $B$
     - Visit $B$, explore $D$
       - Visit $D$ (no edges), finish $D$
     - Back to $B$, explore $E$
       - Visit $E$ (no edges), finish $E$
     - Finish $B$
   - Back to $A$, explore $C$
     - Visit $C$, explore $E$ (already visited), finish $C$
   - Finish $A$

Finish order: $D, E, B, C, A$

**Topological sort** (reverse finish order): $A, C, B, E, D$ (or $A, B, C, E, D$ depending on exploration order)

Both are valid topological orderings. $\square$

## Applications and Intuition

### BFS Applications

**Shortest path in unweighted graphs:** BFS guarantees shortest paths.

**Level-order traversal:** Process vertices level by level (useful in trees).

**Web crawling:** Explore web pages by distance from starting page.

**Social networks:** Find degrees of separation (e.g., "6 degrees of Kevin Bacon").

### DFS Applications

**Cycle detection:** Back edges indicate cycles.

**Topological sorting:** Order tasks with dependencies (DAGs only).

**Connected components:** Find all separate subgraphs.

**Maze solving:** DFS explores paths deeply, backtracking when stuck.

**Strongly connected components:** Kosaraju's and Tarjan's algorithms use DFS.

### When to Use Which?

**Use BFS when:**
- Finding shortest path in unweighted graphs
- Level-by-level exploration needed
- Memory is not severely constrained (BFS can use more space for wide graphs)

**Use DFS when:**
- Detecting cycles
- Topological sorting
- Finding connected components
- Exploring all possibilities (backtracking problems)
- Memory-efficient for deep graphs

## Exercises

### Exercise 1

Perform BFS starting from vertex 1 on the graph with edges: $\{1,2\}, \{1,3\}, \{2,4\}, \{3,4\}, \{4,5\}$.

**Hint:** Use a queue.

**Solution:** Order: $1, 2, 3, 4, 5$

---

### Exercise 2

Using the graph from Exercise 1, find the shortest path from vertex 1 to vertex 5.

**Solution:** $1 \to 2 \to 4 \to 5$ or $1 \to 3 \to 4 \to 5$ (both length 3).

---

### Exercise 3

Perform DFS starting from vertex $A$ on a graph with edges: $A-B, B-C, C-A$.

**Hint:** This forms a cycle.

**Solution:** Order (one possibility): $A, B, C$. Back edge: $C-A$ indicates cycle.

---

### Exercise 4

Prove that BFS uses $O(V)$ space.

**Solution:** The queue stores at most all vertices, so space is $O(V)$. The visited array also requires $O(V)$. Total: $O(V)$. $\square$

---

### Exercise 5

Why does DFS use $O(V)$ space even though it can explore very deep paths?

**Hint:** Consider the recursion stack or explicit stack depth.

**Solution:** In the worst case (a path graph), the recursion stack or explicit stack grows to depth $V$. However, only vertices currently on the path are stored, giving $O(V)$ space in the worst case. $\square$

---

### Exercise 6 (Challenge)

Modify BFS to compute the number of shortest paths from source $s$ to every other vertex.

**Hint:** Track count while doing BFS.

**Solution:**
Initialize `count[s] = 1`. When discovering vertex $v$ from $u$:
- If $v$ is newly discovered: `count[v] = count[u]`
- If $v$ is already discovered at the same level: `count[v] += count[u]`

This counts all shortest paths correctly. $\square$

---

### Exercise 7 (Challenge)

Prove that in an undirected graph, DFS classifies edges into only **tree edges** and **back edges** (no forward or cross edges).

**Hint:** Use the fact that edges are undirected.

**Solution:**
When DFS encounters an edge $\{u, v\}$:
- If $v$ is unvisited: tree edge
- If $v$ is visited and on the stack: back edge
- If $v$ is visited and finished: In undirected graphs, this would have been discovered as a tree edge from $v$ to $u$ earlier.

Therefore, only tree and back edges exist in undirected graphs. $\square$

## Common Mistakes and Misconceptions

1. **Confusing BFS and DFS complexity:** Both are $O(V + E)$ with adjacency lists. The difference is in their behavior, not asymptotic complexity.

2. **Assuming DFS finds shortest paths:** DFS does not guarantee shortest paths (only BFS does in unweighted graphs).

3. **Forgetting to mark vertices as visited:** Leads to infinite loops or incorrect traversals.

4. **Not handling disconnected graphs:** For graphs with multiple components, run BFS/DFS from all unvisited vertices.

5. **Mixing up tree/back/forward/cross edges:** Understand edge classification carefully, especially in directed vs. undirected graphs.

## Summary and Key Takeaways

1. **BFS:** Level-by-level exploration using a queue. Finds shortest paths in unweighted graphs.

2. **DFS:** Deep exploration using a stack or recursion. Useful for cycle detection, topological sorting, connectivity.

3. **Complexity:** Both $O(V + E)$ time with adjacency lists, $O(V)$ space.

4. **BFS guarantees shortest paths** in unweighted graphs; DFS does not.

5. **Cycle detection:** DFS finds back edges, indicating cycles.

6. **Applications:** BFS for shortest paths, level-order processing. DFS for topological sort, connected components, backtracking.

7. **Edge classification:** Tree, back, forward, cross edges help analyze graph structure.

---

**Further Study:** Explore bidirectional BFS, iterative deepening DFS, A* search, and advanced applications like strongly connected components (Tarjan's/Kosaraju's algorithms).
