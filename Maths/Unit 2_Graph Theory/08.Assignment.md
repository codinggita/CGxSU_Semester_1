# Assignment: Graph Traversals — BFS & DFS

## Overview

This comprehensive assignment covers Breadth-First Search (BFS) and Depth-First Search (DFS) algorithms. These fundamental graph traversal techniques are essential for solving pathfinding, connectivity, and structural analysis problems.

---

## Concepts

**BFS (Breadth-First Search):**
- Traverses level by level using a queue (FIFO)
- Finds shortest paths in unweighted graphs
- Time complexity: $O(V + E)$

**DFS (Depth-First Search):**
- Traverses deeply first using a stack or recursion (LIFO)
- Useful for cycle detection and topological sorting
- Time complexity: $O(V + E)$

---

## Problems

### Problem 1: BFS Traversal

Given the graph:

```
     A
    / \
   B   C
  / \   \
 D   E   F
```

**Task:** Perform BFS starting from $A$ and list the traversal order with queue states at each level.

**Solution:**

**BFS Execution:**

| Level | Dequeue | Enqueue | Queue State | Visited |
|-------|---------|---------|-------------|---------|
| 0     | -       | A       | [A]         | -       |
| 1     | A       | B, C    | [B, C]      | A       |
| 2     | B       | D, E    | [C, D, E]   | A, B    |
| 2     | C       | F       | [D, E, F]   | A, B, C |
| 3     | D       | -       | [E, F]      | A, B, C, D |
| 3     | E       | -       | [F]         | A, B, C, D, E |
| 3     | F       | -       | []          | A, B, C, D, E, F |

**BFS Order: $A, B, C, D, E, F$** $\square$

---

### Problem 2: DFS Traversal

Using the same graph as Problem 1, perform DFS starting from $A$.

**Solution:**

**DFS Process (recursive or stack-based):**
- Visit $A$
- Explore left: Visit $B$
  - Explore left: Visit $D$
  - Backtrack, explore right: Visit $E$
- Backtrack to $A$, explore right: Visit $C$
  - Explore: Visit $F$

**DFS Order: $A, B, D, E, C, F$** $\square$

---

### Problem 3: Directed Graph BFS

Given the directed graph:

```
1 → 2 → 4
↓   ↓
3 → 5
```

**Task:** Perform BFS from vertex $1$ considering edge directions.

**Solution:**

Following directed edges only:
- Level 0: $1$
- Level 1: $2, 3$ (out-neighbors of $1$)
- Level 2: $4, 5$ (out-neighbors of $2, 3$)

**BFS Order: $1, 2, 3, 4, 5$** $\square$

---

### Problem 4: Directed Graph DFS

Given the directed graph:

```
1 → 2 → 3
↑       ↓
5 ←  ←  4
```

**Task:** Perform DFS from vertex $1$ and trace stack operations.

**Solution:**

**DFS with Stack Trace:**
- Push $1$, visit $1$
- Push $2$ (neighbor of $1$), visit $2$
- Push $3$ (neighbor of $2$), visit $3$
- Push $4$ (neighbor of $3$), visit $4$
- Push $5$ (neighbor of $4$), visit $5$

**DFS Order: $1, 2, 3, 4, 5$** $\square$

---

### Problem 5: Compare BFS & DFS

Given the graph:

```
      A
    / | \
   B  C  D
      |  /
      E
```

**Tasks:**
(a) Perform both BFS and DFS from $A$
(b) Compare traversal orders
(c) Explain the difference in visiting patterns

**Solution:**

**(a) Traversals:**
- **BFS:** $A, B, C, D, E$ (level-by-level)
- **DFS:** $A, B, C, E, D$ (depth-first on left branch)

**(b) Comparison:**

| Algorithm | Order | Pattern |
|-----------|-------|---------|
| BFS       | $A, B, C, D, E$ | Explores all nodes at distance $k$ before distance $k+1$ |
| DFS       | $A, B, C, E, D$ | Explores as deep as possible before backtracking |

**(c) Key Differences:**
- **BFS:** Guarantees shortest path in unweighted graphs
- **DFS:** Uses less memory for deep graphs, finds paths quickly but not necessarily shortest $\square$

---

### Problems 6-10: Advanced Applications

**Problem 6:** DFS path variations in undirected graph (all valid orderings)

**Problem 7:** BFS in Directed Acyclic Graph (DAG) with in-degree analysis

**Problem 8:** DFS with explicit backtracking steps marked

**Problem 9:** BFS in grid graph with level-by-level expansion

**Problem 10:** DFS edge classification (tree edges, back edges, cross edges)

**(Solutions apply BFS/DFS systematically with appropriate data structure tracking)** $\square$

---

## Edge Classification in DFS

In DFS, edges are classified as:
- **Tree Edge:** Part of DFS tree
- **Back Edge:** Points to an ancestor (indicates cycle)
- **Forward Edge:** Points to a descendant (not in tree)
- **Cross Edge:** Between vertices in different branches

**Example for Problem 10:**

Given graph with DFS tree, classify each edge based on discovery/finish times.

---

## Summary

This assignment covered:
- BFS and DFS algorithm execution
- Queue and stack data structure usage
- Level-order vs. depth-first exploration
- Directed vs. undirected graph traversals
- Edge classification in DFS
- Applications: shortest paths, cycle detection, connectivity

**Key Takeaway:** Choose BFS for shortest paths and level-order processing; choose DFS for cycle detection, topological sorting, and deep exploration.
