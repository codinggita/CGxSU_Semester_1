# JavaScript Control Structures: Conditionals

**Difficulty:** Introductory to Intermediate
**Estimated Time:** 45-60 minutes
**Prerequisites:** Variables, data types, operators, basic JavaScript execution
**Node.js Version:** 18.0.0+ LTS
**Browser Targets:** Chrome 90+, Firefox 88+, Safari 14+, Edge 90+

---

## Learning Objectives

By the end of this lesson, you will be able to:

1. **Implement** all forms of conditional statements (if, if-else, if-else if-else, switch)
2. **Apply** comparison and logical operators to create complex conditions
3. **Understand** JavaScript's truthy/falsy value system and type coercion in conditionals
4. **Use** modern conditional patterns (ternary, optional chaining, nullish coalescing)
5. **Write** guard clauses and early returns for cleaner code flow
6. **Avoid** common anti-patterns and write readable, maintainable conditional logic
7. **Debug** conditional logic using proper techniques and tools

---

## Table of Contents

1. [Introduction to Conditionals](#introduction-to-conditionals)
2. [If Statements](#if-statements)
3. [Comparison and Logical Operators](#comparison-and-logical-operators)
4. [Truthy and Falsy Values](#truthy-and-falsy-values)
5. [Switch Statements](#switch-statements)
6. [Ternary Operator](#ternary-operator)
7. [Modern Conditional Patterns](#modern-conditional-patterns)
8. [Guard Clauses and Early Returns](#guard-clauses-and-early-returns)
9. [Nested Conditionals](#nested-conditionals)
10. [Worked Examples](#worked-examples)
11. [Hands-on Exercises](#hands-on-exercises)
12. [Real-World Applications](#real-world-applications)
13. [Common Pitfalls & Anti-patterns](#common-pitfalls--anti-patterns)
14. [Testing & Verification](#testing--verification)
15. [Performance Considerations](#performance-considerations)
16. [Summary & Next Steps](#summary--next-steps)
17. [References](#references)

---

## Introduction to Conditionals

### What Are Conditionals?

**Conditionals** are control structures that execute different blocks of code based on whether a condition evaluates to `true` or `false`. They are the fundamental mechanism for decision-making in programming.

### Why Conditionals Matter

Conditionals enable your programs to:
- **React dynamically** to different inputs and states
- **Validate** user input and handle edge cases
- **Implement business logic** with complex decision trees
- **Handle errors** and exceptional situations gracefully
- **Create interactive experiences** that respond to user actions

### Mental Model

Think of conditionals like a flowchart in your code:
```
Question: Is user logged in?
  ├─ YES → Show dashboard
  └─ NO  → Show login page
```

Every conditional evaluates to a boolean value (`true` or `false`), determining which code path executes.

---

## If Statements

### Basic If Statement

The simplest conditional executes code only when a condition is true.

**Syntax:**
```javascript
if (condition) {
  // Code executes if condition is true
}
```

**Example:**
```javascript
const age = 18;

if (age >= 18) {
  console.log('You are eligible to vote');
}
// Output: You are eligible to vote
```

**Execution Flow:**
1. Evaluate condition: `age >= 18` → `true`
2. Execute block: `console.log('You are eligible to vote')`
3. Continue with code after the if statement

---

### If-Else Statement

Provides an alternative execution path when the condition is false.

**Syntax:**
```javascript
if (condition) {
  // Executes if condition is true
} else {
  // Executes if condition is false
}
```

**Example:**
```javascript
const temperature = 15;

if (temperature > 20) {
  console.log('It\'s warm outside');
} else {
  console.log('It\'s cool outside');
}
// Output: It's cool outside
```

---

### If-Else If-Else Chain

Checks multiple conditions in sequence, executing the first matching block.

**Syntax:**
```javascript
if (condition1) {
  // Executes if condition1 is true
} else if (condition2) {
  // Executes if condition1 is false AND condition2 is true
} else if (condition3) {
  // Executes if condition1 and condition2 are false AND condition3 is true
} else {
  // Executes if all conditions are false (optional)
}
```

**Example:**
```javascript
const score = 85;

if (score >= 90) {
  console.log('Grade: A');
} else if (score >= 80) {
  console.log('Grade: B');
} else if (score >= 70) {
  console.log('Grade: C');
} else if (score >= 60) {
  console.log('Grade: D');
} else {
  console.log('Grade: F');
}
// Output: Grade: B
```

**Important:** Conditions are evaluated top-to-bottom. Once a condition matches, the rest are skipped.

---

## Comparison and Logical Operators

### Comparison Operators

| Operator | Description | Example | Result |
|----------|-------------|---------|--------|
| `===` | Strict equality (type + value) | `5 === 5` | `true` |
| `!==` | Strict inequality | `5 !== '5'` | `true` |
| `==` | Loose equality (type coercion) | `5 == '5'` | `true` ⚠️ |
| `!=` | Loose inequality | `5 != '5'` | `false` ⚠️ |
| `>` | Greater than | `10 > 5` | `true` |
| `<` | Less than | `3 < 7` | `true` |
| `>=` | Greater than or equal | `5 >= 5` | `true` |
| `<=` | Less than or equal | `4 <= 3` | `false` |

**Best Practice:** Always use strict equality (`===` and `!==`) to avoid unexpected type coercion.

```javascript
// ✅ CORRECT: Strict equality
if (userInput === 'admin') {
  grantAdminAccess();
}

// ❌ WRONG: Loose equality can cause bugs
if (userInput == 'admin') { // '0' == 0 is true!
  grantAdminAccess();
}
```

---

### Logical Operators

Combine multiple conditions into complex logic.

| Operator | Description | Example | Result |
|----------|-------------|---------|--------|
| `&&` | AND (both must be true) | `true && true` | `true` |
| `\|\|` | OR (at least one must be true) | `true \|\| false` | `true` |
| `!` | NOT (inverts boolean) | `!true` | `false` |

**Examples:**
```javascript
const age = 25;
const hasLicense = true;

// AND: Both conditions must be true
if (age >= 18 && hasLicense) {
  console.log('You can drive');
}

// OR: At least one condition must be true
const isWeekend = true;
const isHoliday = false;

if (isWeekend || isHoliday) {
  console.log('No work today!');
}

// NOT: Inverts the boolean value
const isLoggedIn = false;

if (!isLoggedIn) {
  console.log('Please log in');
}
```

**Short-Circuit Evaluation:**

Logical operators use short-circuit evaluation:
- `&&`: If left side is false, right side is never evaluated
- `||`: If left side is true, right side is never evaluated

```javascript
const user = null;

// Safe: Won't error even though user is null
if (user && user.isAdmin) {
  console.log('Admin access granted');
}

// Unsafe without short-circuit
// if (user.isAdmin) { // TypeError: Cannot read property 'isAdmin' of null
```

---

## Truthy and Falsy Values

### Falsy Values

JavaScript has exactly **8 falsy values** (values that evaluate to `false` in a boolean context):

```javascript
false         // The boolean false
0             // Zero
-0            // Negative zero
0n            // BigInt zero
''            // Empty string
""            // Empty string (double quotes)
``            // Empty template literal
null          // Absence of value
undefined     // Undefined variable
NaN           // Not a Number
```

**Example:**
```javascript
const testValues = [false, 0, '', null, undefined, NaN];

testValues.forEach(value => {
  if (value) {
    console.log(`${value} is truthy`);
  } else {
    console.log(`${value} is falsy`);
  }
});
// All output: "... is falsy"
```

---

### Truthy Values

**Everything else** is truthy, including:

```javascript
true          // The boolean true
1, -1, 42     // Any non-zero number
'0'           // String containing zero (not empty!)
'false'       // String containing 'false'
[]            // Empty array
{}            // Empty object
function(){}  // Functions
```

**Common Gotchas:**
```javascript
// ⚠️ These are TRUTHY (often unexpected)
if ('0') {
  console.log('String "0" is truthy!'); // Executes!
}

if ([]) {
  console.log('Empty array is truthy!'); // Executes!
}

if ({}) {
  console.log('Empty object is truthy!'); // Executes!
}
```

---

### Practical Usage

**Checking for existence:**
```javascript
const username = getUserInput();

if (username) {
  console.log(`Welcome, ${username}`);
} else {
  console.log('Please enter a username');
}
// Works for: null, undefined, empty string
```

**Default values (pre-ES6 pattern):**
```javascript
const config = {
  timeout: userTimeout || 3000, // Use 3000 if userTimeout is falsy
};
```

**⚠️ Warning:** This can cause bugs with valid falsy values like `0`:
```javascript
const count = 0;
const displayCount = count || 10; // Bug! displayCount is 10, not 0
```

**Solution:** Use nullish coalescing (covered later).

---

## Switch Statements

### Basic Syntax

The `switch` statement compares a value against multiple cases using **strict equality** (`===`).

**Syntax:**
```javascript
switch (expression) {
  case value1:
    // Code for value1
    break;
  case value2:
    // Code for value2
    break;
  default:
    // Code if no cases match
    break;
}
```

**Example:**
```javascript
const dayOfWeek = 'Monday';

switch (dayOfWeek) {
  case 'Monday':
    console.log('Start of the work week');
    break;
  case 'Friday':
    console.log('TGIF!');
    break;
  case 'Saturday':
  case 'Sunday':
    console.log('Weekend!');
    break;
  default:
    console.log('Midweek day');
    break;
}
// Output: Start of the work week
```

---

### Fall-Through Behavior

Without `break`, execution "falls through" to the next case.

**Intentional fall-through (grouped cases):**
```javascript
const month = 'February';

switch (month) {
  case 'December':
  case 'January':
  case 'February':
    console.log('Winter');
    break;
  case 'March':
  case 'April':
  case 'May':
    console.log('Spring');
    break;
  default:
    console.log('Other season');
    break;
}
// Output: Winter
```

**Accidental fall-through (bug):**
```javascript
// ❌ WRONG: Missing break
const status = 'warning';

switch (status) {
  case 'error':
    console.log('Error occurred');
    // Missing break!
  case 'warning':
    console.log('Warning issued');
    // Missing break!
  case 'info':
    console.log('Info message');
    break;
}
// Output:
// Warning issued
// Info message  ← Bug! Both execute
```

---

### Switch vs If-Else

**Use switch when:**
- Comparing the **same variable** against multiple **exact values**
- You have **4+ conditions** to check
- Readability benefits from grouped cases

**Use if-else when:**
- Comparing **different variables**
- Using **range checks** (`>`, `<`, `>=`, `<=`)
- Conditions involve **complex logic** (`&&`, `||`)

**Example (better with if-else):**
```javascript
// ❌ WRONG: Using switch for ranges (doesn't work!)
const score = 85;
switch (score) {
  case score >= 90: // Bug! This compares (85) === (true)
    console.log('A');
    break;
}

// ✅ CORRECT: Use if-else for ranges
if (score >= 90) {
  console.log('A');
} else if (score >= 80) {
  console.log('B');
}
```

---

## Ternary Operator

The **ternary operator** (`? :`) is a concise way to write simple if-else statements.

**Syntax:**
```javascript
condition ? expressionIfTrue : expressionIfFalse
```

**Basic Example:**
```javascript
const age = 20;
const status = age >= 18 ? 'adult' : 'minor';
console.log(status); // Output: adult

// Equivalent if-else:
let status;
if (age >= 18) {
  status = 'adult';
} else {
  status = 'minor';
}
```

---

### Nested Ternary (Use Sparingly)

```javascript
const score = 85;
const grade = score >= 90 ? 'A' :
              score >= 80 ? 'B' :
              score >= 70 ? 'C' :
              score >= 60 ? 'D' : 'F';

console.log(grade); // Output: B
```

**⚠️ Warning:** Nested ternaries reduce readability. Prefer if-else chains for 3+ conditions.

---

### Best Practices

**✅ GOOD: Simple assignments**
```javascript
const message = isLoggedIn ? 'Welcome back' : 'Please log in';
```

**✅ GOOD: Inline JSX (React)**
```javascript
<div>{isLoading ? <Spinner /> : <Content />}</div>
```

**❌ BAD: Complex logic**
```javascript
// Hard to read!
const result = condition1 && condition2 ?
  (condition3 ? value1 : value2) :
  (condition4 ? value3 : value4);

// Better: Use if-else
let result;
if (condition1 && condition2) {
  result = condition3 ? value1 : value2;
} else {
  result = condition4 ? value3 : value4;
}
```

---

## Modern Conditional Patterns

### Nullish Coalescing Operator (`??`)

Returns the right-hand operand when the left-hand operand is `null` or `undefined` (not all falsy values).

**Syntax:**
```javascript
const result = value ?? defaultValue;
```

**Comparison with `||`:**
```javascript
const count = 0;

// ❌ WRONG: || treats 0 as falsy
const displayCount1 = count || 10;
console.log(displayCount1); // 10 (Bug! We wanted 0)

// ✅ CORRECT: ?? only checks null/undefined
const displayCount2 = count ?? 10;
console.log(displayCount2); // 0 (Correct!)
```

**Use Cases:**
```javascript
// API responses with optional fields
const user = {
  name: 'Alice',
  age: null,
};

const displayAge = user.age ?? 'Not specified';
console.log(displayAge); // "Not specified"

// Configuration with valid falsy values
const config = {
  retries: 0,      // 0 is valid
  timeout: '',     // Empty string is valid
  debug: false,    // false is valid
};

const retries = config.retries ?? 3;    // 0 (correct!)
const timeout = config.timeout ?? 1000; // '' (correct!)
const debug = config.debug ?? true;     // false (correct!)
```

---

### Optional Chaining (`?.`)

Safely access nested properties without errors if intermediate values are `null` or `undefined`.

**Syntax:**
```javascript
const value = object?.property;
const value = object?.method?.();
const value = array?.[index];
```

**Example:**
```javascript
const user = {
  name: 'Alice',
  address: {
    city: 'New York',
  },
};

// ❌ WRONG: Errors if user or address is null
// const zipCode = user.address.zipCode; // undefined (OK)
// const zipCode = user.profile.bio;     // TypeError!

// ✅ CORRECT: Safe access with optional chaining
const zipCode = user?.address?.zipCode; // undefined (no error)
const bio = user?.profile?.bio;         // undefined (no error)

// With arrays
const firstItem = array?.[0]; // undefined if array is null

// With methods
const result = object?.method?.(); // undefined if method doesn't exist
```

**Combined with Nullish Coalescing:**
```javascript
const displayCity = user?.address?.city ?? 'Unknown city';
console.log(displayCity); // "New York"

const displayZip = user?.address?.zipCode ?? 'N/A';
console.log(displayZip); // "N/A"
```

---

## Guard Clauses and Early Returns

### What Are Guard Clauses?

**Guard clauses** are conditional statements placed at the beginning of a function to handle edge cases and exit early. They reduce nesting and improve readability.

**Without Guard Clauses (nested):**
```javascript
// ❌ WRONG: Deeply nested conditionals
function processOrder(order) {
  if (order) {
    if (order.items && order.items.length > 0) {
      if (order.total > 0) {
        if (order.customer) {
          // Main logic buried deep
          return calculateShipping(order);
        } else {
          throw new Error('No customer');
        }
      } else {
        throw new Error('Invalid total');
      }
    } else {
      throw new Error('No items');
    }
  } else {
    throw new Error('No order');
  }
}
```

**With Guard Clauses (flat):**
```javascript
// ✅ CORRECT: Early returns with guard clauses
function processOrder(order) {
  // Guard clauses at the top
  if (!order) {
    throw new Error('No order');
  }

  if (!order.items || order.items.length === 0) {
    throw new Error('No items');
  }

  if (order.total <= 0) {
    throw new Error('Invalid total');
  }

  if (!order.customer) {
    throw new Error('No customer');
  }

  // Main logic at normal indentation
  return calculateShipping(order);
}
```

**Benefits:**
- ✅ Reduces nesting and indentation
- ✅ Makes edge cases explicit and visible
- ✅ Main logic stays at consistent indentation
- ✅ Easier to read and maintain

---

### Early Returns

Return immediately when a condition is met instead of using else blocks.

**Without Early Returns:**
```javascript
// ❌ Unnecessary else block
function getDiscount(user) {
  if (user.isPremium) {
    return 0.2;
  } else {
    if (user.purchaseCount > 10) {
      return 0.1;
    } else {
      return 0;
    }
  }
}
```

**With Early Returns:**
```javascript
// ✅ CORRECT: Early returns eliminate else
function getDiscount(user) {
  if (user.isPremium) {
    return 0.2;
  }

  if (user.purchaseCount > 10) {
    return 0.1;
  }

  return 0;
}
```

---

## Nested Conditionals

### When to Nest

Nesting is appropriate when:
- Conditions are **logically dependent** (inner condition only makes sense if outer is true)
- Nesting level is **2 or fewer**
- **Alternative patterns** (guard clauses, switch) don't apply

**Example:**
```javascript
function canAccessFeature(user, feature) {
  if (user.isLoggedIn) {
    if (user.subscription === 'premium') {
      if (feature.requiresPremium) {
        return true;
      }
    }
  }
  return false;
}
```

---

### Refactoring Deep Nesting

**Strategy 1: Guard Clauses**
```javascript
// ✅ Better with guard clauses
function canAccessFeature(user, feature) {
  if (!user.isLoggedIn) {
    return false;
  }

  if (user.subscription !== 'premium') {
    return false;
  }

  return feature.requiresPremium;
}
```

**Strategy 2: Combine Conditions**
```javascript
// ✅ Combine with logical operators
function canAccessFeature(user, feature) {
  return user.isLoggedIn &&
         user.subscription === 'premium' &&
         feature.requiresPremium;
}
```

**Strategy 3: Extract Functions**
```javascript
// ✅ Extract complex logic
function canAccessFeature(user, feature) {
  return isPremiumUser(user) && requiresPremium(feature);
}

function isPremiumUser(user) {
  return user.isLoggedIn && user.subscription === 'premium';
}

function requiresPremium(feature) {
  return feature.requiresPremium;
}
```

---

## Worked Examples

### Example 1: Authentication System (Simple - 30 lines)

**Objective:** Implement user authentication with multiple validation checks.

```javascript
/**
 * Example: User Authentication System
 *
 * Demonstrates:
 * - Guard clauses for validation
 * - Comparison operators
 * - Early returns
 * - Error handling
 */

const users = [
  { username: 'alice', password: 'secret123', isActive: true },
  { username: 'bob', password: 'pass456', isActive: false },
];

const authenticate = (username, password) => {
  // Guard clause: Empty inputs
  if (!username || !password) {
    return { success: false, message: 'Username and password required' };
  }

  // Find user
  const user = users.find(u => u.username === username);

  // Guard clause: User not found
  if (!user) {
    return { success: false, message: 'Invalid credentials' };
  }

  // Guard clause: Inactive account
  if (!user.isActive) {
    return { success: false, message: 'Account is deactivated' };
  }

  // Check password
  if (user.password !== password) {
    return { success: false, message: 'Invalid credentials' };
  }

  // Success
  return { success: true, message: 'Login successful', user: user.username };
};

// --- Tests ---
import { expect } from 'vitest';

expect(authenticate('alice', 'secret123')).toMatchObject({
  success: true,
  message: 'Login successful',
});

expect(authenticate('alice', 'wrong')).toMatchObject({
  success: false,
  message: 'Invalid credentials',
});

expect(authenticate('bob', 'pass456')).toMatchObject({
  success: false,
  message: 'Account is deactivated',
});

expect(authenticate('', '')).toMatchObject({
  success: false,
  message: 'Username and password required',
});

console.log('✓ All authentication tests passed');
```

---

### Example 2: Shipping Calculator (Intermediate - 50 lines)

**Objective:** Calculate shipping costs based on multiple factors using complex conditionals.

```javascript
/**
 * Example: Shipping Cost Calculator
 *
 * Demonstrates:
 * - Complex conditional logic
 * - Switch statements
 * - Ternary operators
 * - Nullish coalescing
 */

const calculateShipping = (order) => {
  // Guard clauses
  if (!order || typeof order !== 'object') {
    throw new TypeError('Order must be an object');
  }

  const {
    weight = 0,
    destination = 'domestic',
    total = 0,
    isPremium = false,
  } = order;

  // Validation
  if (weight <= 0) {
    throw new Error('Weight must be positive');
  }

  if (total < 0) {
    throw new Error('Total cannot be negative');
  }

  // Free shipping for premium members or orders over $100
  if (isPremium || total >= 100) {
    return 0;
  }

  // Base rate by destination
  let baseRate;
  switch (destination) {
    case 'domestic':
      baseRate = 5;
      break;
    case 'international':
      baseRate = 15;
      break;
    case 'express':
      baseRate = 25;
      break;
    default:
      throw new Error(`Unknown destination: ${destination}`);
  }

  // Weight multiplier
  let weightCharge;
  if (weight <= 1) {
    weightCharge = 0;
  } else if (weight <= 5) {
    weightCharge = 2;
  } else if (weight <= 10) {
    weightCharge = 5;
  } else {
    weightCharge = 10;
  }

  const totalShipping = baseRate + weightCharge;

  // Apply discount for orders over $50
  const finalCost = total > 50 ? totalShipping * 0.9 : totalShipping;

  return parseFloat(finalCost.toFixed(2));
};

// --- Tests ---
expect(calculateShipping({
  weight: 2,
  destination: 'domestic',
  total: 30,
})).toBe(7); // Base 5 + Weight 2 = 7

expect(calculateShipping({
  weight: 2,
  destination: 'domestic',
  total: 60,
})).toBe(6.3); // (5 + 2) * 0.9 = 6.3

expect(calculateShipping({
  weight: 2,
  destination: 'domestic',
  total: 120,
  isPremium: false,
})).toBe(0); // Free over $100

expect(calculateShipping({
  weight: 15,
  destination: 'international',
  total: 40,
  isPremium: true,
})).toBe(0); // Free for premium

console.log('✓ All shipping calculator tests passed');
```

---

### Example 3: Smart Form Validator (Advanced - 70 lines)

**Objective:** Build a comprehensive form validation system with multiple rules.

```javascript
/**
 * Example: Advanced Form Validator
 *
 * Demonstrates:
 * - Complex validation logic
 * - Optional chaining
 * - Nullish coalescing
 * - Object-based conditional patterns
 */

const ValidationRules = {
  required: (value) => {
    const valid = value !== null && value !== undefined && value !== '';
    return { valid, message: valid ? '' : 'This field is required' };
  },

  email: (value) => {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    const valid = emailRegex.test(value);
    return { valid, message: valid ? '' : 'Invalid email format' };
  },

  minLength: (min) => (value) => {
    const valid = value?.length >= min;
    return {
      valid,
      message: valid ? '' : `Minimum ${min} characters required`,
    };
  },

  maxLength: (max) => (value) => {
    const valid = value?.length <= max;
    return {
      valid,
      message: valid ? '' : `Maximum ${max} characters allowed`,
    };
  },

  pattern: (regex, errorMsg) => (value) => {
    const valid = regex.test(value);
    return { valid, message: valid ? '' : errorMsg };
  },
};

const validateField = (value, rules) => {
  // Early return if no rules
  if (!rules || rules.length === 0) {
    return { valid: true, errors: [] };
  }

  const errors = [];

  // Run each validation rule
  for (const rule of rules) {
    const result = rule(value);

    if (!result.valid) {
      errors.push(result.message);
    }
  }

  return {
    valid: errors.length === 0,
    errors,
  };
};

const validateForm = (formData, schema) => {
  const results = {};
  let isFormValid = true;

  // Validate each field
  for (const [fieldName, rules] of Object.entries(schema)) {
    const fieldValue = formData?.[fieldName] ?? '';
    const validation = validateField(fieldValue, rules);

    results[fieldName] = validation;

    if (!validation.valid) {
      isFormValid = false;
    }
  }

  return {
    valid: isFormValid,
    fields: results,
  };
};

// --- Usage Example ---
const registrationSchema = {
  username: [
    ValidationRules.required,
    ValidationRules.minLength(3),
    ValidationRules.maxLength(20),
    ValidationRules.pattern(/^[a-zA-Z0-9_]+$/, 'Only letters, numbers, and underscores'),
  ],
  email: [
    ValidationRules.required,
    ValidationRules.email,
  ],
  password: [
    ValidationRules.required,
    ValidationRules.minLength(8),
    ValidationRules.pattern(/[A-Z]/, 'Must contain uppercase letter'),
    ValidationRules.pattern(/[0-9]/, 'Must contain number'),
  ],
};

const formData = {
  username: 'alice',
  email: 'alice@example.com',
  password: 'Secret123',
};

const validation = validateForm(formData, registrationSchema);

// --- Tests ---
expect(validation.valid).toBe(true);
expect(validation.fields.username.valid).toBe(true);
expect(validation.fields.email.valid).toBe(true);

const invalidData = {
  username: 'ab', // Too short
  email: 'invalid-email',
  password: 'weak',
};

const invalidValidation = validateForm(invalidData, registrationSchema);
expect(invalidValidation.valid).toBe(false);
expect(invalidValidation.fields.username.errors).toContain('Minimum 3 characters required');
expect(invalidValidation.fields.email.errors).toContain('Invalid email format');

console.log('✓ All form validation tests passed');
```

---

## Hands-on Exercises

### Exercise 1: Grade Calculator (Easy)

**Task:** Create a function that converts a numerical score to a letter grade with +/- modifiers.

**Requirements:**
- A: 90-100 (A+: 97-100, A: 93-96, A-: 90-92)
- B: 80-89 (B+: 87-89, B: 83-86, B-: 80-82)
- C: 70-79 (C+: 77-79, C: 73-76, C-: 70-72)
- D: 60-69 (D+: 67-69, D: 63-66, D-: 60-62)
- F: 0-59
- Handle invalid inputs (negative, > 100, non-numbers)

**Example:**
```javascript
calculateGrade(95);  // 'A'
calculateGrade(87);  // 'B+'
calculateGrade(101); // Error: Score must be 0-100
```

**Solution:** See `/home/user/CG/JavaScript_for_backend/03.Control_Structures_Conditionals/solutions/01-grade-calculator.js`

---

### Exercise 2: Access Control System (Medium)

**Task:** Implement a role-based access control function.

**Requirements:**
- Roles: admin, editor, viewer, guest
- Resources: users, posts, comments, settings
- Actions: create, read, update, delete
- Define permission matrix
- Return boolean for access allowed/denied

**Permission Rules:**
```
Admin: All actions on all resources
Editor: CRUD on posts/comments, Read on users
Viewer: Read on all resources
Guest: Read on posts/comments only
```

**Example:**
```javascript
canAccess('admin', 'users', 'delete');    // true
canAccess('viewer', 'settings', 'read');  // true
canAccess('guest', 'users', 'read');      // false
canAccess('editor', 'posts', 'create');   // true
```

**Solution:** See `/home/user/CG/JavaScript_for_backend/03.Control_Structures_Conditionals/solutions/02-access-control.js`

---

### Exercise 3: Date Range Validator (Medium)

**Task:** Create a function to validate if a date falls within a specific range and category.

**Requirements:**
- Check if date is valid
- Determine if date is in the past, present (today), or future
- Check if date falls on weekend or weekday
- Determine season (Winter, Spring, Summer, Fall)
- Return comprehensive analysis object

**Example:**
```javascript
analyzeDatestring('2025-12-25');
// {
//   valid: true,
//   temporal: 'future',
//   dayType: 'weekday',
//   season: 'winter',
//   daysUntil: 400
// }
```

**Solution:** See `/home/user/CG/JavaScript_for_backend/03.Control_Structures_Conditionals/solutions/03-date-validator.js`

---

### Exercise 4: Smart Discount Calculator (Medium-Hard)

**Task:** Build a discount calculator with complex rules and stacking logic.

**Requirements:**
- Base discounts: Member (10%), Senior (15%), Student (10%)
- Holiday discounts: Black Friday (25%), Cyber Monday (20%)
- Volume discounts: $100+ (5%), $500+ (10%), $1000+ (15%)
- Discounts can stack with specific rules:
  - Base + Holiday (take higher)
  - Volume applies after other discounts
  - Max total discount: 50%
- Return detailed breakdown

**Example:**
```javascript
calculateDiscount({
  total: 600,
  isMember: true,
  isHoliday: 'blackfriday',
});
// {
//   baseDiscount: 25, // Holiday wins over member
//   volumeDiscount: 10,
//   totalDiscount: 35,
//   finalPrice: 390,
//   savings: 210
// }
```

**Solution:** See `/home/user/CG/JavaScript_for_backend/03.Control_Structures_Conditionals/solutions/04-discount-calculator.js`

---

### Exercise 5: Password Strength Checker (Hard)

**Task:** Create a comprehensive password strength analyzer with detailed feedback.

**Requirements:**
- Check multiple criteria:
  - Length (8+ chars)
  - Uppercase letters
  - Lowercase letters
  - Numbers
  - Special characters
  - No common patterns (123, abc, qwerty)
  - Not in common passwords list
- Return strength rating: weak, fair, good, strong, excellent
- Provide specific improvement suggestions
- Calculate estimated crack time

**Example:**
```javascript
checkPasswordStrength('Password123!');
// {
//   strength: 'good',
//   score: 75,
//   passed: ['length', 'uppercase', 'lowercase', 'numbers', 'special'],
//   failed: ['commonPattern'],
//   suggestions: ['Avoid common patterns'],
//   estimatedCrackTime: '3 months'
// }
```

**Solution:** See `/home/user/CG/JavaScript_for_backend/03.Control_Structures_Conditionals/solutions/05-password-strength.js`

---

### Exercise 6: Traffic Light Controller (Advanced)

**Task:** Simulate a traffic light system with multiple intersections and timing logic.

**Requirements:**
- Four-way intersection with sensors
- Time-based light changes (green: 30s, yellow: 5s, red: 35s)
- Emergency vehicle override
- Pedestrian crossing requests
- Handle multiple intersections
- Return current state and next transition time

**Example:**
```javascript
const controller = new TrafficController();
controller.tick(10); // Simulate 10 seconds
controller.requestPedestrian('north');
controller.emergencyVehicle('south');
controller.getState();
// {
//   north: 'red',
//   south: 'green',
//   east: 'red',
//   west: 'red',
//   nextChange: 20,
//   pedestrianActive: false
// }
```

**Solution:** See `/home/user/CG/JavaScript_for_backend/03.Control_Structures_Conditionals/solutions/06-traffic-light.js`

---

## Real-World Applications

### 1. E-commerce Checkout Flow

```javascript
const processCheckout = (cart, user, paymentInfo) => {
  // Guard clauses for required data
  if (!cart || cart.items.length === 0) {
    return { error: 'Cart is empty' };
  }

  if (!user?.isLoggedIn) {
    return { error: 'Please log in to checkout' };
  }

  if (!paymentInfo?.method) {
    return { error: 'Payment method required' };
  }

  // Calculate totals
  const subtotal = cart.items.reduce((sum, item) => sum + item.price, 0);
  const shipping = calculateShipping(cart);
  const discount = calculateDiscount(user, subtotal);
  const total = subtotal + shipping - discount;

  // Payment processing
  const payment = processPayment(total, paymentInfo);

  if (!payment.success) {
    return { error: 'Payment failed', details: payment.message };
  }

  // Create order
  return {
    success: true,
    orderId: generateOrderId(),
    total,
    estimatedDelivery: calculateDeliveryDate(shipping),
  };
};
```

---

### 2. API Request Authorization

```javascript
const authorizeRequest = (req) => {
  // Extract token
  const token = req.headers?.authorization?.split(' ')[1];

  if (!token) {
    return { authorized: false, status: 401, message: 'No token provided' };
  }

  // Verify token
  const decoded = verifyToken(token);

  if (!decoded) {
    return { authorized: false, status: 401, message: 'Invalid token' };
  }

  // Check expiration
  if (decoded.exp < Date.now() / 1000) {
    return { authorized: false, status: 401, message: 'Token expired' };
  }

  // Check user permissions
  const hasPermission = checkPermission(decoded.userId, req.method, req.path);

  if (!hasPermission) {
    return { authorized: false, status: 403, message: 'Insufficient permissions' };
  }

  return { authorized: true, user: decoded };
};
```

---

### 3. Content Recommendation Engine

```javascript
const recommendContent = (user, contentPool) => {
  // Filter based on user preferences
  let candidates = contentPool.filter(content => {
    // Check age restriction
    if (content.ageRating && user.age < content.ageRating) {
      return false;
    }

    // Check language preference
    if (!user.languages?.includes(content.language)) {
      return false;
    }

    // Skip already consumed content
    if (user.watchedIds?.includes(content.id)) {
      return false;
    }

    return true;
  });

  // Score and rank content
  candidates = candidates.map(content => {
    let score = 0;

    // Genre matching
    const genreMatch = content.genres.filter(g => user.favoriteGenres?.includes(g));
    score += genreMatch.length * 10;

    // Popularity boost
    score += content.views / 1000;

    // Recency boost
    const daysOld = (Date.now() - content.publishedAt) / (1000 * 60 * 60 * 24);
    score += daysOld < 7 ? 20 : daysOld < 30 ? 10 : 0;

    return { ...content, score };
  });

  // Return top 10
  return candidates
    .sort((a, b) => b.score - a.score)
    .slice(0, 10);
};
```

---

## Common Pitfalls & Anti-patterns

### Pitfall 1: Assignment Instead of Comparison

```javascript
// ❌ WRONG: Single = is assignment, not comparison
if (user = admin) { // Always true! Sets user = admin
  console.log('Admin access');
}

// ✅ CORRECT: Use === for comparison
if (user === admin) {
  console.log('Admin access');
}
```

**Prevention:** Enable ESLint rule `no-cond-assign`

---

### Pitfall 2: Forgetting `break` in Switch

```javascript
// ❌ WRONG: Missing break causes fall-through
switch (status) {
  case 'pending':
    console.log('Processing...');
    // Missing break!
  case 'complete':
    console.log('Done!'); // Executes for 'pending' too!
    break;
}

// ✅ CORRECT: Always include break
switch (status) {
  case 'pending':
    console.log('Processing...');
    break;
  case 'complete':
    console.log('Done!');
    break;
}
```

---

### Pitfall 3: Truthy/Falsy Confusion

```javascript
// ❌ WRONG: Empty array is truthy!
if (array) {
  console.log('Array has items'); // Wrong! Executes even for []
}

// ✅ CORRECT: Check length
if (array && array.length > 0) {
  console.log('Array has items');
}

// Or use optional chaining
if (array?.length) {
  console.log('Array has items');
}
```

---

### Pitfall 4: Loose Equality Gotchas

```javascript
// ❌ WRONG: Unexpected coercion with ==
if ('0' == 0) {        // true (string coerced to number)
if (false == '0') {    // true
if (null == undefined) { // true
if ('' == 0) {         // true

// ✅ CORRECT: Strict equality prevents coercion
if ('0' === 0) {        // false
if (false === '0') {    // false
if (null === undefined) { // false
if ('' === 0) {         // false
```

---

### Anti-pattern 1: Else After Return

```javascript
// ❌ ANTI-PATTERN: Unnecessary else
function getStatus(code) {
  if (code === 200) {
    return 'OK';
  } else { // Redundant
    return 'Error';
  }
}

// ✅ BETTER: Remove unnecessary else
function getStatus(code) {
  if (code === 200) {
    return 'OK';
  }
  return 'Error';
}
```

---

### Anti-pattern 2: Comparing to Boolean Literals

```javascript
// ❌ ANTI-PATTERN: Redundant comparison
if (isValid === true) {
  console.log('Valid');
}

// ✅ BETTER: Direct boolean check
if (isValid) {
  console.log('Valid');
}

// Similarly for false
// ❌ WRONG
if (isValid === false) {
  console.log('Invalid');
}

// ✅ BETTER
if (!isValid) {
  console.log('Invalid');
}
```

---

### Anti-pattern 3: Yoda Conditions

```javascript
// ❌ ANTI-PATTERN: Yoda condition (value first)
if (42 === age) {
  console.log('The answer to everything');
}

// ✅ BETTER: Natural reading order
if (age === 42) {
  console.log('The answer to everything');
}
```

**Note:** Yoda conditions were historically used to prevent assignment bugs (`if (age = 42)`), but modern linters catch this.

---

## Testing & Verification

### Unit Testing Conditionals

```javascript
// conditional-utils.test.js
import { describe, it, expect } from 'vitest';
import { isAdult, getAccessLevel, formatMessage } from './conditional-utils.js';

describe('Conditional Logic Tests', () => {
  describe('isAdult()', () => {
    it('should return true for age 18 and above', () => {
      expect(isAdult(18)).toBe(true);
      expect(isAdult(25)).toBe(true);
      expect(isAdult(100)).toBe(true);
    });

    it('should return false for age below 18', () => {
      expect(isAdult(17)).toBe(false);
      expect(isAdult(0)).toBe(false);
    });

    it('should handle edge cases', () => {
      expect(isAdult(17.9)).toBe(false);
      expect(isAdult(18.0)).toBe(true);
    });
  });

  describe('getAccessLevel()', () => {
    it('should grant admin access', () => {
      expect(getAccessLevel({ role: 'admin' })).toBe('full');
    });

    it('should grant limited access for regular users', () => {
      expect(getAccessLevel({ role: 'user' })).toBe('limited');
    });

    it('should deny access for null/undefined', () => {
      expect(getAccessLevel(null)).toBe('none');
      expect(getAccessLevel(undefined)).toBe('none');
    });
  });
});
```

---

### Branch Coverage

Ensure **all code paths** are tested:

```javascript
// Function with multiple branches
const categorizeAge = (age) => {
  if (age < 0) {
    throw new Error('Age cannot be negative');
  } else if (age < 13) {
    return 'child';
  } else if (age < 20) {
    return 'teenager';
  } else if (age < 65) {
    return 'adult';
  } else {
    return 'senior';
  }
};

// Tests covering all branches
describe('categorizeAge() - 100% branch coverage', () => {
  it('should throw for negative age', () => {
    expect(() => categorizeAge(-1)).toThrow('Age cannot be negative');
  });

  it('should return child for age 0-12', () => {
    expect(categorizeAge(0)).toBe('child');
    expect(categorizeAge(12)).toBe('child');
  });

  it('should return teenager for age 13-19', () => {
    expect(categorizeAge(13)).toBe('teenager');
    expect(categorizeAge(19)).toBe('teenager');
  });

  it('should return adult for age 20-64', () => {
    expect(categorizeAge(20)).toBe('adult');
    expect(categorizeAge(64)).toBe('adult');
  });

  it('should return senior for age 65+', () => {
    expect(categorizeAge(65)).toBe('senior');
    expect(categorizeAge(100)).toBe('senior');
  });
});
```

**Run tests with coverage:**
```bash
npm test -- --coverage
```

---

## Performance Considerations

### 1. Short-Circuit Evaluation

Place expensive operations last:

```javascript
// ✅ GOOD: Cheap check first
if (user.isLoggedIn && expensiveDatabaseQuery()) {
  // expensiveDatabaseQuery() only runs if user.isLoggedIn is true
}

// ❌ BAD: Expensive operation always runs
if (expensiveDatabaseQuery() && user.isLoggedIn) {
  // Database queried even if user not logged in
}
```

---

### 2. Switch vs If-Else Performance

For many conditions (10+), `switch` can be slightly faster due to jump table optimization:

```javascript
// Slightly faster for many cases
switch (action) {
  case 'create': return handleCreate();
  case 'read': return handleRead();
  case 'update': return handleUpdate();
  case 'delete': return handleDelete();
  // ... 20 more cases
}

// Slower for many cases (linear search)
if (action === 'create') return handleCreate();
else if (action === 'read') return handleRead();
else if (action === 'update') return handleUpdate();
// ... 20 more conditions
```

**Note:** Readability matters more than micro-optimizations. Modern JavaScript engines optimize both well.

---

### 3. Object Lookup for Dynamic Dispatch

For truly large condition sets, use object lookup:

```javascript
// ✅ FASTEST: O(1) lookup
const handlers = {
  create: handleCreate,
  read: handleRead,
  update: handleUpdate,
  delete: handleDelete,
};

const result = handlers[action]?.();

// vs. switch/if-else: O(n) linear search
```

---

## Summary & Next Steps

### Key Takeaways

1. **Use strict equality (`===`)** to avoid type coercion bugs
2. **Prefer guard clauses** over deep nesting for better readability
3. **Understand truthy/falsy** values to avoid unexpected behavior
4. **Use switch** for exact value matching, **if-else** for ranges and complex logic
5. **Leverage modern operators** (`?.`, `??`) for safe property access
6. **Test all branches** to ensure conditional logic is correct
7. **Write readable code** over micro-optimizations

### What You've Accomplished

- ✅ Mastered all conditional statement types (if, switch, ternary)
- ✅ Understood truthy/falsy values and type coercion
- ✅ Applied modern ES2020+ conditional patterns
- ✅ Implemented guard clauses and early returns
- ✅ Built real-world validation and authorization systems
- ✅ Learned to avoid common pitfalls and anti-patterns

### Next Topics to Study

1. **Loops** → [04.Loops.md](../04.Control_Structures_Loop/04.Loops.md)
2. **Functions** → [05.Functions.md](../05.Functions/05.Functions.md)
3. **Arrays** → [06.Arrays.md](../06.Arrays/06.Arrays.md)

### Practice Projects

1. Build a CLI-based quiz game with scoring
2. Create an expense tracker with category validation
3. Implement a booking system with date/availability checks
4. Build a chatbot with intent recognition

---

## References

### Official Documentation

- [MDN: if...else](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else)
- [MDN: switch](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/switch)
- [MDN: Conditional (ternary) operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator)
- [MDN: Optional chaining (?.)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining)
- [MDN: Nullish coalescing (??)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing)

### Best Practices

- [Airbnb JavaScript Style Guide - Comparison Operators](https://github.com/airbnb/javascript#comparison-operators--equality)
- [Clean Code JavaScript - Conditionals](https://github.com/ryanmcdermott/clean-code-javascript#conditionals)

### Tools

- [ESLint](https://eslint.org/) - Catch conditional logic errors
- [Vitest](https://vitest.dev/) - Test framework

---

**Last Updated:** 2025-11-22
**Curriculum Version:** 2.0.0
**Maintainer:** Code Galaxy Contributors

**Next Lesson:** [Loops](../04.Control_Structures_Loop/04.Loops.md) →
