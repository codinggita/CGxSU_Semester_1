# Promises in JavaScript

**Difficulty:** Intermediate
**Estimated Time:** 60-75 minutes
**Prerequisites:** Callbacks, asynchronous JavaScript basics, error handling
**Target:** Node.js 18+ LTS, Modern Browsers (ES2021+)

---

## Learning Objectives

By the end of this lesson, you will be able to:

1. Understand Promise fundamentals and the three states
2. Create Promises using new Promise(), Promise.resolve(), and Promise.reject()
3. Consume Promises with .then(), .catch(), and .finally()
4. Chain Promises for sequential async operations
5. Implement proper error handling in Promise chains
6. Use Promise.all(), Promise.race(), Promise.allSettled(), and Promise.any()
7. Convert callback-based functions to Promises (promisify)
8. Apply common Promise patterns in real-world scenarios
9. Debug Promise-related issues and unhandled rejections
10. Make informed decisions between Promises and callbacks

---

## Table of Contents

1. [Introduction](#introduction)
2. [Promise Fundamentals](#promise-fundamentals)
3. [Creating Promises](#creating-promises)
4. [Consuming Promises](#consuming-promises)
5. [Promise Chaining](#promise-chaining)
6. [Error Handling](#error-handling)
7. [Promise Combinators](#promise-combinators)
8. [Converting Callbacks to Promises](#converting-callbacks-to-promises)
9. [Common Promise Patterns](#common-promise-patterns)
10. [Worked Examples](#worked-examples)
11. [Exercises](#exercises)
12. [Testing & Verification](#testing--verification)
13. [Best Practices](#best-practices)
14. [Common Pitfalls](#common-pitfalls)
15. [Performance Considerations](#performance-considerations)
16. [Summary & Next Steps](#summary--next-steps)
17. [References](#references)

---

## Introduction

**Promises** are JavaScript objects representing the eventual completion (or failure) of an asynchronous operation. Introduced in ES6 (2015), Promises provide a cleaner, more powerful alternative to callbacks.

**Why Promises Matter:**

- **Avoid Callback Hell:** Chain operations cleanly without deep nesting
- **Better Error Handling:** Centralized error handling with .catch()
- **Composition:** Combine multiple async operations elegantly
- **Standardization:** Consistent API across libraries and platforms
- **Foundation for async/await:** Enable modern async syntax

**Real-World Applications:**

- **API Requests:** Fetch data from servers
- **File Operations:** Read/write files asynchronously
- **Database Queries:** Query databases without blocking
- **Image Loading:** Load images asynchronously in browsers
- **Animations:** Sequence complex animations
- **User Authentication:** Handle multi-step auth flows

---

## Promise Fundamentals

### The Three States

A Promise can be in one of three states:

```javascript
/**
 * Promise States
 */

// 1. PENDING: Initial state, neither fulfilled nor rejected
const pendingPromise = new Promise((resolve, reject) => {
  // Operation in progress...
});

// 2. FULFILLED: Operation completed successfully
const fulfilledPromise = Promise.resolve('Success!');

// 3. REJECTED: Operation failed
const rejectedPromise = Promise.reject(new Error('Failed!'));
```

### State Transitions

```
         ┌─────────────┐
         │   PENDING   │
         └──────┬──────┘
                │
         ┌──────┴──────┐
         │             │
         ▼             ▼
  ┌───────────┐   ┌──────────┐
  │ FULFILLED │   │ REJECTED │
  └───────────┘   └──────────┘
   (immutable)     (immutable)
```

**Key Points:**
- Once settled (fulfilled or rejected), state cannot change
- Promises are immutable after settling
- Handlers can be attached before or after settling

### Basic Promise Example

```javascript
/**
 * Simple Promise demonstration
 */

const myPromise = new Promise((resolve, reject) => {
  const success = Math.random() > 0.5;

  setTimeout(() => {
    if (success) {
      resolve('Operation succeeded!');
    } else {
      reject(new Error('Operation failed!'));
    }
  }, 1000);
});

myPromise
  .then(result => {
    console.log('Success:', result);
  })
  .catch(error => {
    console.error('Error:', error.message);
  });
```

---

## Creating Promises

### Using the Promise Constructor

```javascript
/**
 * Creating Promises with new Promise()
 */

const fetchUserData = userId => {
  return new Promise((resolve, reject) => {
    // Executor function runs immediately
    console.log('Fetching user data...');

    setTimeout(() => {
      if (userId > 0) {
        const user = { id: userId, name: 'Alice', email: 'alice@example.com' };
        resolve(user);  // Fulfill the promise
      } else {
        reject(new Error('Invalid user ID'));  // Reject the promise
      }
    }, 1000);
  });
};

// Usage
fetchUserData(123)
  .then(user => console.log('User:', user))
  .catch(error => console.error('Error:', error.message));
```

### Promise.resolve()

```javascript
/**
 * Creating immediately resolved promises
 */

// Create fulfilled promise with value
const promise1 = Promise.resolve(42);
promise1.then(value => console.log(value));  // 42

// Useful for wrapping non-promise values
const promise2 = Promise.resolve({ name: 'Alice' });

// If passed a promise, returns that promise
const promise3 = Promise.resolve(promise1);
console.log(promise1 === promise3);  // true

// Common pattern: return early from async function
const getUserFromCache = userId => {
  const cached = cache.get(userId);
  if (cached) {
    return Promise.resolve(cached);  // Immediate return
  }
  return fetchUserFromAPI(userId);  // Async operation
};
```

### Promise.reject()

```javascript
/**
 * Creating immediately rejected promises
 */

// Create rejected promise with error
const promise1 = Promise.reject(new Error('Operation failed'));
promise1.catch(error => console.error(error.message));

// Useful for validation
const validateAge = age => {
  if (age < 0 || age > 150) {
    return Promise.reject(new Error('Invalid age'));
  }
  return Promise.resolve(age);
};

validateAge(-5)
  .then(age => console.log('Valid age:', age))
  .catch(error => console.error('Validation error:', error.message));
```

### Executor Function Details

```javascript
/**
 * Understanding the executor function
 */

const promise = new Promise((resolve, reject) => {
  // This function executes IMMEDIATELY (synchronously)
  console.log('Executor running');

  // resolve and reject are functions
  // Call resolve(value) to fulfill
  // Call reject(reason) to reject

  // Only the FIRST call to resolve/reject matters
  resolve('First');
  resolve('Second');  // Ignored
  reject(new Error('Error'));  // Ignored
});

console.log('After promise creation');

// Output:
// "Executor running"
// "After promise creation"
// (then handlers run asynchronously)
```

---

## Consuming Promises

### The .then() Method

```javascript
/**
 * Consuming promises with .then()
 */

const fetchData = () => Promise.resolve({ data: 'Hello World' });

// .then() takes up to 2 arguments: onFulfilled, onRejected
fetchData().then(
  result => {
    console.log('Success:', result);
  },
  error => {
    console.error('Error:', error);
  }
);

// More commonly: use only onFulfilled
fetchData().then(result => {
  console.log('Data:', result.data);
});

// .then() returns a new Promise
const promise1 = fetchData();
const promise2 = promise1.then(result => result.data);
const promise3 = promise2.then(data => data.toUpperCase());

console.log(promise1 === promise2);  // false (different promises)
```

### The .catch() Method

```javascript
/**
 * Error handling with .catch()
 */

const riskyOperation = () => {
  return new Promise((resolve, reject) => {
    const random = Math.random();
    if (random > 0.5) {
      resolve('Success!');
    } else {
      reject(new Error('Random failure'));
    }
  });
};

// .catch() is shorthand for .then(null, errorHandler)
riskyOperation()
  .then(result => console.log(result))
  .catch(error => console.error('Caught:', error.message));

// Equivalent to:
riskyOperation().then(
  result => console.log(result),
  error => console.error('Caught:', error.message)
);

// .catch() also returns a Promise
riskyOperation()
  .catch(error => {
    console.error('Error handled:', error.message);
    return 'Default value';  // Recovery
  })
  .then(result => {
    console.log('Continuing with:', result);
  });
```

### The .finally() Method

```javascript
/**
 * Cleanup with .finally()
 */

const fetchWithLoading = () => {
  console.log('Loading: true');

  return fetch('/api/data')
    .then(response => response.json())
    .then(data => {
      console.log('Data received:', data);
      return data;
    })
    .catch(error => {
      console.error('Error:', error);
      throw error;  // Re-throw
    })
    .finally(() => {
      // Runs regardless of success or failure
      console.log('Loading: false');
      // Return value is ignored
      // Cannot change the promise result
    });
};

// .finally() doesn't receive arguments
Promise.resolve('value')
  .finally(() => {
    console.log('Cleanup');
    // No access to resolved value
  })
  .then(value => console.log(value));  // "value" still passes through
```

---

## Promise Chaining

Promises can be chained to perform sequential async operations.

### Basic Chaining

```javascript
/**
 * Basic Promise chain
 */

const getUser = userId => {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve({ id: userId, name: 'Alice' });
    }, 100);
  });
};

const getOrders = userId => {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve([{ id: 1, total: 100 }, { id: 2, total: 200 }]);
    }, 100);
  });
};

const getOrderDetails = orderId => {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve({ id: orderId, items: ['Book', 'Pen'] });
    }, 100);
  });
};

// Clean sequential chain (no callback hell!)
getUser(123)
  .then(user => {
    console.log('User:', user.name);
    return getOrders(user.id);
  })
  .then(orders => {
    console.log('Orders:', orders.length);
    return getOrderDetails(orders[0].id);
  })
  .then(details => {
    console.log('Items:', details.items);
  })
  .catch(error => {
    console.error('Error:', error);
  });
```

### Returning Values vs Promises

```javascript
/**
 * What you return in .then() matters
 */

// Returning a value
Promise.resolve(1)
  .then(value => {
    console.log(value);  // 1
    return value * 2;  // Return value
  })
  .then(value => {
    console.log(value);  // 2
  });

// Returning a Promise
Promise.resolve(1)
  .then(value => {
    console.log(value);  // 1
    return Promise.resolve(value * 2);  // Return promise
  })
  .then(value => {
    console.log(value);  // 2 (promise unwrapped automatically)
  });

// Returning nothing (undefined)
Promise.resolve(1)
  .then(value => {
    console.log(value);  // 1
    // No return
  })
  .then(value => {
    console.log(value);  // undefined
  });
```

### Nested Promises (Anti-pattern)

```javascript
/**
 * AVOID: Nesting promises (defeats the purpose!)
 */

// ❌ BAD: Nested promises (like callback hell)
getUser(123)
  .then(user => {
    getOrders(user.id)
      .then(orders => {
        getOrderDetails(orders[0].id)
          .then(details => {
            console.log(details);
          });
      });
  });

// ✅ GOOD: Flat chain
getUser(123)
  .then(user => getOrders(user.id))
  .then(orders => getOrderDetails(orders[0].id))
  .then(details => console.log(details))
  .catch(error => console.error(error));
```

---

## Error Handling

Proper error handling is crucial for robust Promise-based code.

### Error Propagation

```javascript
/**
 * Errors propagate down the chain
 */

Promise.resolve(1)
  .then(value => {
    console.log('Step 1:', value);
    return value * 2;
  })
  .then(value => {
    console.log('Step 2:', value);
    throw new Error('Something went wrong!');
  })
  .then(value => {
    console.log('Step 3:', value);  // Skipped!
  })
  .then(value => {
    console.log('Step 4:', value);  // Skipped!
  })
  .catch(error => {
    console.error('Caught:', error.message);  // Catches the error
  })
  .then(() => {
    console.log('Continues after catch');  // This runs!
  });
```

### Multiple .catch() Handlers

```javascript
/**
 * Strategic error handling
 */

fetchUser(123)
  .then(user => {
    return processUser(user);
  })
  .catch(error => {
    // Handle user fetch errors
    console.error('User error:', error);
    return getDefaultUser();  // Fallback
  })
  .then(user => {
    return saveToDatabase(user);
  })
  .catch(error => {
    // Handle database errors
    console.error('Database error:', error);
    throw error;  // Re-throw if can't recover
  })
  .finally(() => {
    console.log('Operation complete');
  });
```

### Catching Specific Errors

```javascript
/**
 * Pattern for handling specific error types
 */

class NetworkError extends Error {
  constructor(message) {
    super(message);
    this.name = 'NetworkError';
  }
}

class ValidationError extends Error {
  constructor(message) {
    super(message);
    this.name = 'ValidationError';
  }
}

const fetchData = () => {
  return fetch('/api/data')
    .then(response => {
      if (!response.ok) {
        throw new NetworkError(`HTTP ${response.status}`);
      }
      return response.json();
    })
    .then(data => {
      if (!data.valid) {
        throw new ValidationError('Invalid data format');
      }
      return data;
    })
    .catch(error => {
      if (error instanceof NetworkError) {
        console.error('Network issue:', error.message);
        return getFromCache();  // Fallback
      } else if (error instanceof ValidationError) {
        console.error('Validation failed:', error.message);
        return getDefaultData();
      } else {
        throw error;  // Unknown error, re-throw
      }
    });
};
```

### Unhandled Promise Rejections

```javascript
/**
 * Unhandled rejection detection
 */

// ❌ BAD: Unhandled rejection
const badPromise = Promise.reject(new Error('Unhandled'));
// This will trigger a warning in Node.js and browsers

// ✅ GOOD: Always handle rejections
const goodPromise = Promise.reject(new Error('Handled'));
goodPromise.catch(error => console.error('Handled:', error));

// Global handlers (last resort)
if (typeof process !== 'undefined') {
  // Node.js
  process.on('unhandledRejection', (reason, promise) => {
    console.error('Unhandled Rejection at:', promise, 'reason:', reason);
  });
}

if (typeof window !== 'undefined') {
  // Browser
  window.addEventListener('unhandledrejection', event => {
    console.error('Unhandled rejection:', event.reason);
    event.preventDefault();  // Prevent default handling
  });
}
```

---

## Promise Combinators

Methods for working with multiple promises simultaneously.

### Promise.all()

Waits for all promises to resolve, or rejects if any promise rejects.

```javascript
/**
 * Promise.all() - All or nothing
 */

const promise1 = Promise.resolve(1);
const promise2 = Promise.resolve(2);
const promise3 = Promise.resolve(3);

Promise.all([promise1, promise2, promise3])
  .then(results => {
    console.log('All resolved:', results);  // [1, 2, 3]
  });

// Practical example: Parallel API calls
const fetchUserData = userId => {
  const userPromise = fetch(`/api/users/${userId}`).then(r => r.json());
  const ordersPromise = fetch(`/api/orders/${userId}`).then(r => r.json());
  const settingsPromise = fetch(`/api/settings/${userId}`).then(r => r.json());

  return Promise.all([userPromise, ordersPromise, settingsPromise])
    .then(([user, orders, settings]) => {
      return { user, orders, settings };
    });
};

// If ANY promise rejects, Promise.all() rejects
Promise.all([
  Promise.resolve(1),
  Promise.reject(new Error('Failed!')),
  Promise.resolve(3)
])
  .then(results => console.log(results))  // Never called
  .catch(error => console.error(error.message));  // "Failed!"
```

### Promise.race()

Returns the result of the first promise to settle (fulfill or reject).

```javascript
/**
 * Promise.race() - First to finish wins
 */

const slow = new Promise(resolve => setTimeout(() => resolve('Slow'), 1000));
const fast = new Promise(resolve => setTimeout(() => resolve('Fast'), 100));

Promise.race([slow, fast])
  .then(result => console.log('Winner:', result));  // "Fast"

// Practical example: Timeout implementation
const fetchWithTimeout = (url, timeoutMs) => {
  const fetchPromise = fetch(url);
  const timeoutPromise = new Promise((_, reject) => {
    setTimeout(() => reject(new Error('Request timeout')), timeoutMs);
  });

  return Promise.race([fetchPromise, timeoutPromise]);
};

fetchWithTimeout('/api/data', 5000)
  .then(response => response.json())
  .catch(error => console.error(error.message));

// Race can also reject first
Promise.race([
  new Promise(resolve => setTimeout(() => resolve('OK'), 1000)),
  new Promise((_, reject) => setTimeout(() => reject(new Error('Error')), 100))
])
  .catch(error => console.error('First to fail:', error.message));
```

### Promise.allSettled()

Waits for all promises to settle, regardless of outcome.

```javascript
/**
 * Promise.allSettled() - Wait for all (ES2020)
 */

const promises = [
  Promise.resolve(1),
  Promise.reject(new Error('Failed')),
  Promise.resolve(3)
];

Promise.allSettled(promises)
  .then(results => {
    console.log(results);
    /*
    [
      { status: 'fulfilled', value: 1 },
      { status: 'rejected', reason: Error: Failed },
      { status: 'fulfilled', value: 3 }
    ]
    */

    // Process results
    results.forEach((result, index) => {
      if (result.status === 'fulfilled') {
        console.log(`Promise ${index}: ${result.value}`);
      } else {
        console.error(`Promise ${index} failed:`, result.reason.message);
      }
    });
  });

// Practical example: Multiple independent operations
const saveMultipleItems = async items => {
  const savePromises = items.map(item => saveToDatabase(item));

  const results = await Promise.allSettled(savePromises);

  const successful = results.filter(r => r.status === 'fulfilled').length;
  const failed = results.filter(r => r.status === 'rejected').length;

  console.log(`Saved: ${successful}, Failed: ${failed}`);

  return results;
};
```

### Promise.any()

Returns the first promise to fulfill (ignores rejections unless all reject).

```javascript
/**
 * Promise.any() - First success wins (ES2021)
 */

const promises = [
  Promise.reject(new Error('Error 1')),
  Promise.resolve('Success!'),
  Promise.reject(new Error('Error 2'))
];

Promise.any(promises)
  .then(result => console.log('First success:', result))  // "Success!"
  .catch(error => console.error('All failed:', error));

// Practical example: Fetch from multiple mirrors
const fetchFromFastestMirror = data => {
  const mirrors = [
    fetch('https://mirror1.example.com/data'),
    fetch('https://mirror2.example.com/data'),
    fetch('https://mirror3.example.com/data')
  ];

  return Promise.any(mirrors)
    .then(response => response.json())
    .catch(error => {
      // AggregateError if all fail
      console.error('All mirrors failed:', error.errors);
      throw new Error('No mirrors available');
    });
};

// All rejected = AggregateError
Promise.any([
  Promise.reject(new Error('A')),
  Promise.reject(new Error('B')),
  Promise.reject(new Error('C'))
])
  .catch(error => {
    console.log(error.name);  // "AggregateError"
    console.log(error.errors);  // [Error: A, Error: B, Error: C]
  });
```

### Comparison Table

| Method | Resolves When | Rejects When | Use Case |
|--------|---------------|--------------|----------|
| `Promise.all()` | All fulfill | Any rejects | All operations must succeed |
| `Promise.race()` | First settles | First rejects | First result needed |
| `Promise.allSettled()` | All settle | Never | Need all results regardless |
| `Promise.any()` | First fulfills | All reject | First success needed |

---

## Converting Callbacks to Promises

Transform callback-based APIs into Promise-based ones.

### Manual Promisification

```javascript
/**
 * Converting callbacks to promises manually
 */

// Callback-based function
const callbackFunction = (param, callback) => {
  setTimeout(() => {
    if (param > 0) {
      callback(null, param * 2);
    } else {
      callback(new Error('Invalid param'));
    }
  }, 100);
};

// Promise wrapper
const promiseFunction = param => {
  return new Promise((resolve, reject) => {
    callbackFunction(param, (err, result) => {
      if (err) reject(err);
      else resolve(result);
    });
  });
};

// Usage
promiseFunction(5)
  .then(result => console.log('Result:', result))
  .catch(error => console.error('Error:', error));
```

### Generic Promisify Function

```javascript
/**
 * Generic promisify utility
 */

const promisify = fn => {
  return (...args) => {
    return new Promise((resolve, reject) => {
      fn(...args, (err, result) => {
        if (err) reject(err);
        else resolve(result);
      });
    });
  };
};

// Example usage
const fs = require('fs');  // Node.js
const readFilePromise = promisify(fs.readFile);

readFilePromise('file.txt', 'utf8')
  .then(data => console.log(data))
  .catch(error => console.error(error));

// Node.js built-in promisify
const { promisify: nodePromisify } = require('util');
const readFileAsync = nodePromisify(fs.readFile);
```

### Promisifying Event Emitters

```javascript
/**
 * Converting event-based APIs to promises
 */

const waitForEvent = (emitter, eventName, timeout = 5000) => {
  return new Promise((resolve, reject) => {
    const timer = setTimeout(() => {
      cleanup();
      reject(new Error(`Timeout waiting for ${eventName}`));
    }, timeout);

    const onEvent = (...args) => {
      cleanup();
      resolve(args);
    };

    const onError = error => {
      cleanup();
      reject(error);
    };

    const cleanup = () => {
      clearTimeout(timer);
      emitter.removeListener(eventName, onEvent);
      emitter.removeListener('error', onError);
    };

    emitter.once(eventName, onEvent);
    emitter.once('error', onError);
  });
};

// Usage with Node.js streams
const stream = fs.createReadStream('large-file.txt');
waitForEvent(stream, 'end', 10000)
  .then(() => console.log('Stream ended'))
  .catch(error => console.error('Stream error:', error));
```

---

## Common Promise Patterns

### Sequential Execution

```javascript
/**
 * Execute promises in sequence
 */

const tasks = [
  () => Promise.resolve(1),
  () => Promise.resolve(2),
  () => Promise.resolve(3)
];

// Using reduce
const runSequentially = tasks => {
  return tasks.reduce((promiseChain, currentTask) => {
    return promiseChain.then(results => {
      return currentTask().then(result => {
        return [...results, result];
      });
    });
  }, Promise.resolve([]));
};

runSequentially(tasks)
  .then(results => console.log(results));  // [1, 2, 3]

// Using for loop
const runSequentiallyLoop = async tasks => {
  const results = [];
  for (const task of tasks) {
    results.push(await task());
  }
  return results;
};
```

### Retry Pattern

```javascript
/**
 * Retry failed promises
 */

const retryPromise = (promiseFn, maxRetries = 3, delay = 1000) => {
  return new Promise((resolve, reject) => {
    const attempt = retryCount => {
      promiseFn()
        .then(resolve)
        .catch(error => {
          if (retryCount >= maxRetries) {
            reject(new Error(`Failed after ${maxRetries} retries: ${error.message}`));
          } else {
            console.log(`Retry ${retryCount + 1}/${maxRetries}`);
            setTimeout(() => attempt(retryCount + 1), delay);
          }
        });
    };

    attempt(0);
  });
};

// Usage
retryPromise(() => fetch('/api/data'), 3, 2000)
  .then(response => response.json())
  .catch(error => console.error(error));
```

### Caching Pattern

```javascript
/**
 * Cache promise results
 */

const createCachedPromise = promiseFn => {
  let cachedPromise = null;

  return (...args) => {
    if (cachedPromise === null) {
      cachedPromise = promiseFn(...args);
    }
    return cachedPromise;
  };
};

const expensiveOperation = () => {
  console.log('Executing expensive operation...');
  return new Promise(resolve => {
    setTimeout(() => resolve('Result'), 1000);
  });
};

const cachedOperation = createCachedPromise(expensiveOperation);

// First call: executes operation
cachedOperation().then(result => console.log(result));

// Subsequent calls: return cached promise
cachedOperation().then(result => console.log(result));  // No execution!
```

---

## Worked Examples

### Example 1: User Authentication Flow

```javascript
/**
 * Worked Example 1: Multi-step authentication
 *
 * Demonstrates:
 * - Promise chaining
 * - Error handling
 * - Data transformation
 */

const validateCredentials = (username, password) => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (username === 'admin' && password === 'secret') {
        resolve({ username, validated: true });
      } else {
        reject(new Error('Invalid credentials'));
      }
    }, 500);
  });
};

const fetchUserProfile = username => {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve({
        username,
        email: `${username}@example.com`,
        role: 'admin'
      });
    }, 500);
  });
};

const generateToken = user => {
  return new Promise(resolve => {
    setTimeout(() => {
      const token = `token_${Date.now()}_${user.username}`;
      resolve({ ...user, token });
    }, 500);
  });
};

// Complete authentication flow
const authenticateUser = (username, password) => {
  return validateCredentials(username, password)
    .then(credentials => {
      console.log('✓ Credentials validated');
      return fetchUserProfile(credentials.username);
    })
    .then(profile => {
      console.log('✓ Profile fetched');
      return generateToken(profile);
    })
    .then(authData => {
      console.log('✓ Token generated');
      return authData;
    })
    .catch(error => {
      console.error('✗ Authentication failed:', error.message);
      throw error;
    });
};

// Test
authenticateUser('admin', 'secret')
  .then(user => console.log('Logged in:', user))
  .catch(() => console.log('Login failed'));
```

### Example 2: Parallel Data Fetching with Aggregation

```javascript
/**
 * Worked Example 2: Dashboard data aggregation
 *
 * Demonstrates:
 * - Promise.all() for parallel execution
 * - Data aggregation
 * - Partial failure handling
 */

const fetchStats = () => {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve({ totalUsers: 1250, activeUsers: 842 });
    }, 300);
  });
};

const fetchRevenue = () => {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve({ total: 98500, monthly: 12300 });
    }, 200);
  });
};

const fetchAlerts = () => {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve([
        { type: 'warning', message: 'High CPU usage' },
        { type: 'info', message: 'Update available' }
      ]);
    }, 400);
  });
};

const loadDashboard = () => {
  console.log('Loading dashboard...');

  return Promise.all([
    fetchStats().catch(err => ({ error: err.message })),
    fetchRevenue().catch(err => ({ error: err.message })),
    fetchAlerts().catch(err => ({ error: err.message }))
  ])
    .then(([stats, revenue, alerts]) => {
      return {
        stats: stats.error ? null : stats,
        revenue: revenue.error ? null : revenue,
        alerts: alerts.error ? [] : alerts,
        loadedAt: new Date().toISOString()
      };
    });
};

// Test
loadDashboard()
  .then(dashboard => {
    console.log('Dashboard loaded:', dashboard);
  });
```

### Example 3: Rate-Limited API Calls

```javascript
/**
 * Worked Example 3: Rate-limited promise queue
 *
 * Demonstrates:
 * - Controlled concurrency
 * - Queue management
 * - Promise patterns
 */

class PromiseQueue {
  constructor(concurrency = 2) {
    this.concurrency = concurrency;
    this.running = 0;
    this.queue = [];
  }

  enqueue(promiseFn) {
    return new Promise((resolve, reject) => {
      this.queue.push({ promiseFn, resolve, reject });
      this.dequeue();
    });
  }

  dequeue() {
    if (this.running >= this.concurrency || this.queue.length === 0) {
      return;
    }

    const { promiseFn, resolve, reject } = this.queue.shift();
    this.running++;

    promiseFn()
      .then(resolve, reject)
      .finally(() => {
        this.running--;
        this.dequeue();
      });
  }
}

// Usage
const queue = new PromiseQueue(2);  // Max 2 concurrent

const fetchUser = id => {
  return new Promise(resolve => {
    console.log(`Fetching user ${id}...`);
    setTimeout(() => {
      console.log(`User ${id} fetched`);
      resolve({ id, name: `User${id}` });
    }, 1000);
  });
};

// Queue 5 requests (only 2 run at a time)
const userIds = [1, 2, 3, 4, 5];
const promises = userIds.map(id => queue.enqueue(() => fetchUser(id)));

Promise.all(promises)
  .then(users => console.log('All users:', users));
```

---

## Exercises

### Exercise 1: Promise Wrapper (Easy)

**Problem:**
Create a function that wraps a value in a promise that resolves after a specified delay.

```javascript
/**
 * Exercise 1: delay
 *
 * @param {number} ms - Delay in milliseconds
 * @param {*} value - Value to resolve with
 * @returns {Promise} Promise that resolves after delay
 */
const delay = (ms, value) => {
  // Your code here
};

// Test
delay(1000, 'Hello').then(result => console.log(result));  // After 1 second: "Hello"
```

**Solution:** See `solutions/exercise1_promises.js`

---

### Exercise 2: Promise Chain (Medium)

**Problem:**
Implement a function that chains multiple async operations to calculate compound interest.

```javascript
/**
 * Exercise 2: calculateCompoundInterest
 *
 * Chain promises to:
 * 1. Validate inputs
 * 2. Calculate interest
 * 3. Format result
 */
const calculateCompoundInterest = (principal, rate, years) => {
  // Your code here
  // Return a promise that resolves to formatted result
};

// Test
calculateCompoundInterest(1000, 5, 10)
  .then(result => console.log(result))
  .catch(error => console.error(error));
```

**Solution:** See `solutions/exercise2_promises.js`

---

### Exercise 3: Parallel Fetching (Medium)

**Problem:**
Fetch multiple resources in parallel and combine results.

```javascript
/**
 * Exercise 3: fetchMultipleUsers
 *
 * Fetch multiple user profiles in parallel using Promise.all()
 */
const fetchMultipleUsers = userIds => {
  // Your code here
};

// Test
fetchMultipleUsers([1, 2, 3])
  .then(users => console.log(users))
  .catch(error => console.error(error));
```

**Solution:** See `solutions/exercise3_promises.js`

---

### Exercise 4: Race with Timeout (Medium)

**Problem:**
Implement a fetch with timeout using Promise.race().

```javascript
/**
 * Exercise 4: fetchWithTimeout
 *
 * Fetch with automatic timeout
 */
const fetchWithTimeout = (url, timeoutMs) => {
  // Your code here
};

// Test
fetchWithTimeout('/api/data', 3000)
  .then(data => console.log(data))
  .catch(error => console.error(error));
```

**Solution:** See `solutions/exercise4_promises.js`

---

### Exercise 5: Promisify Callback (Hard)

**Problem:**
Create a generic promisify function that works with any callback-based function.

```javascript
/**
 * Exercise 5: promisify
 *
 * Convert callback-based functions to promises
 */
const promisify = fn => {
  // Your code here
};

// Test
const callbackFn = (a, b, callback) => {
  setTimeout(() => callback(null, a + b), 100);
};

const promiseFn = promisify(callbackFn);
promiseFn(2, 3).then(result => console.log(result));  // 5
```

**Solution:** See `solutions/exercise5_promises.js`

---

### Exercise 6: Promise Pool (Hard)

**Problem:**
Implement a promise pool that limits concurrent promise execution.

```javascript
/**
 * Exercise 6: promisePool
 *
 * Execute promises with concurrency limit
 */
const promisePool = (promiseFns, concurrency) => {
  // Your code here
};

// Test
const tasks = Array.from({ length: 10 }, (_, i) => {
  return () => new Promise(resolve => {
    setTimeout(() => resolve(i), 100);
  });
});

promisePool(tasks, 3)
  .then(results => console.log(results));
```

**Solution:** See `solutions/exercise6_promises.js`

---

## Testing & Verification

### Testing Promises with Vitest

```javascript
/**
 * Testing promise-based functions
 */

import { describe, it, expect, vi } from 'vitest';

describe('Promise functions', () => {
  it('should resolve with value', async () => {
    const promise = Promise.resolve(42);
    await expect(promise).resolves.toBe(42);
  });

  it('should reject with error', async () => {
    const promise = Promise.reject(new Error('Failed'));
    await expect(promise).rejects.toThrow('Failed');
  });

  it('should chain promises', async () => {
    const result = await Promise.resolve(1)
      .then(x => x + 1)
      .then(x => x * 2);

    expect(result).toBe(4);
  });

  it('should handle Promise.all()', async () => {
    const promises = [
      Promise.resolve(1),
      Promise.resolve(2),
      Promise.resolve(3)
    ];

    const results = await Promise.all(promises);
    expect(results).toEqual([1, 2, 3]);
  });
});
```

---

## Best Practices

1. **Always return promises from functions**
2. **Handle all rejections with .catch()**
3. **Avoid mixing callbacks and promises**
4. **Use Promise.all() for parallel operations**
5. **Keep promise chains flat (avoid nesting)**
6. **Prefer async/await for complex flows**

---

## Common Pitfalls

1. **Forgetting to return promises in chains**
2. **Not handling promise rejections**
3. **Nesting promises (callback hell 2.0)**
4. **Creating unnecessary promises**
5. **Modifying promise state after settling**

---

## Performance Considerations

- Use Promise.all() for parallel operations
- Avoid creating promises in loops
- Consider caching for expensive operations
- Implement timeouts for network requests

---

## Summary & Next Steps

### Key Takeaways

- Promises represent eventual completion/failure of async operations
- Three states: pending, fulfilled, rejected
- Chain with .then(), handle errors with .catch(), cleanup with .finally()
- Combinators: all(), race(), allSettled(), any()
- Convert callbacks to promises with promisify

### Related Topics

- [Async/Await](./24.Async_Await.md)
- [Event Loop Deep Dive](./25.Event_Loop_Deep_Dive.md)
- [Working with APIs](./26.Working_With_APIs.md)

### Further Reading

- [MDN: Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)
- [Promises/A+ Specification](https://promisesaplus.com/)

---

**Next Lesson:** [Async/Await](./24.Async_Await.md)
