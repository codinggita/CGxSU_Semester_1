# Callbacks and Callback Hell in JavaScript

**Difficulty:** Introductory to Intermediate
**Estimated Time:** 45-60 minutes
**Prerequisites:** Functions, scope, closures, basic error handling
**Target:** Node.js 18+ LTS, Modern Browsers (ES2021+)

---

## Learning Objectives

By the end of this lesson, you will be able to:

1. Understand what callbacks are and why they're fundamental to JavaScript
2. Distinguish between synchronous and asynchronous code execution
3. Visualize and explain the event loop mechanism
4. Implement callback patterns for asynchronous operations
5. Apply the error-first callback convention (Node.js style)
6. Recognize callback hell (pyramid of doom) and its problems
7. Implement solutions to avoid callback hell
8. Use callbacks in real-world scenarios (file operations, timers, events)
9. Debug common callback-related issues
10. Make informed decisions about when to use callbacks vs alternatives

---

## Table of Contents

1. [Introduction](#introduction)
2. [What Are Callbacks?](#what-are-callbacks)
3. [Synchronous vs Asynchronous Code](#synchronous-vs-asynchronous-code)
4. [The Event Loop Visualization](#the-event-loop-visualization)
5. [Callback Patterns](#callback-patterns)
6. [Error-First Callbacks](#error-first-callbacks)
7. [Callback Hell / Pyramid of Doom](#callback-hell--pyramid-of-doom)
8. [Solutions to Callback Hell](#solutions-to-callback-hell)
9. [Real-World Examples](#real-world-examples)
10. [Worked Examples](#worked-examples)
11. [Exercises](#exercises)
12. [Testing & Verification](#testing--verification)
13. [Best Practices](#best-practices)
14. [Common Pitfalls](#common-pitfalls)
15. [Performance Considerations](#performance-considerations)
16. [Summary & Next Steps](#summary--next-steps)
17. [References](#references)

---

## Introduction

**Callbacks** are the foundation of asynchronous programming in JavaScript. Understanding callbacks is crucial because they:

- Enable non-blocking operations in a single-threaded environment
- Form the basis for Promises and async/await
- Are still widely used in event handling and Node.js APIs
- Help you understand JavaScript's execution model

**Why Callbacks Matter:**

JavaScript is single-threaded, meaning it can only execute one operation at a time. Without asynchronous mechanisms, long-running operations (network requests, file I/O, timers) would freeze the entire application. Callbacks allow JavaScript to remain responsive by deferring execution until an operation completes.

**Historical Context:**

Before Promises (ES6) and async/await (ES2017), callbacks were the primary way to handle asynchronous operations. Many legacy codebases and Node.js core modules still use callbacks extensively.

---

## What Are Callbacks?

A **callback** is a function passed as an argument to another function, to be executed later (usually after an asynchronous operation completes).

### Basic Callback Example

```javascript
/**
 * Simple callback demonstration
 */

// Function that accepts a callback
const greet = (name, callback) => {
  const message = `Hello, ${name}!`;
  callback(message);
};

// Callback function
const displayMessage = msg => {
  console.log(msg);
};

// Usage
greet('Alice', displayMessage);  // Output: "Hello, Alice!"

// Inline callback (anonymous function)
greet('Bob', msg => {
  console.log(`Message received: ${msg}`);
});
```

### Callbacks in Array Methods

```javascript
// Callbacks are used extensively in array methods
const numbers = [1, 2, 3, 4, 5];

// map with callback
const doubled = numbers.map(n => n * 2);
console.log(doubled);  // [2, 4, 6, 8, 10]

// filter with callback
const evens = numbers.filter(n => n % 2 === 0);
console.log(evens);  // [2, 4]

// forEach with callback
numbers.forEach((n, index) => {
  console.log(`Index ${index}: ${n}`);
});
```

---

## Synchronous vs Asynchronous Code

Understanding the difference between synchronous and asynchronous execution is fundamental to mastering callbacks.

### Synchronous Code

Synchronous code executes line by line, blocking until each operation completes.

```javascript
/**
 * Synchronous execution example
 */

console.log('Start');

// This blocks execution for 3 seconds (DON'T DO THIS!)
const blockFor3Seconds = () => {
  const start = Date.now();
  while (Date.now() - start < 3000) {
    // Busy waiting - blocks everything!
  }
};

blockFor3Seconds();
console.log('End');

// Output:
// "Start"
// (3 second pause)
// "End"
```

**Problems with synchronous blocking:**
- UI freezes
- No other code can run
- Poor user experience
- Inefficient resource usage

### Asynchronous Code

Asynchronous code allows operations to run in the background, invoking callbacks when complete.

```javascript
/**
 * Asynchronous execution example
 */

console.log('Start');

// setTimeout schedules the callback to run after 3 seconds
setTimeout(() => {
  console.log('Timeout complete');
}, 3000);

console.log('End');

// Output:
// "Start"
// "End"
// (3 second pause)
// "Timeout complete"
```

**Benefits of asynchronous code:**
- Non-blocking execution
- Responsive applications
- Efficient resource utilization
- Better user experience

### Side-by-Side Comparison

```javascript
/**
 * Comparison: Synchronous vs Asynchronous
 */

// SYNCHRONOUS (blocking)
const processSync = () => {
  console.log('1. Start processing');

  // Simulate long operation (blocks!)
  let sum = 0;
  for (let i = 0; i < 1000000000; i++) {
    sum += i;
  }

  console.log('2. Processing complete');
  console.log('3. Sum:', sum);
};

processSync();
console.log('4. After processing');

// Output order: 1, 2, 3, 4 (sequential)

// ASYNCHRONOUS (non-blocking)
const processAsync = callback => {
  console.log('1. Start processing');

  // Simulate async operation
  setTimeout(() => {
    let sum = 0;
    for (let i = 0; i < 1000000; i++) {
      sum += i;
    }
    console.log('2. Processing complete');
    callback(sum);
  }, 0);  // Even 0ms makes it async!
};

processAsync(sum => {
  console.log('3. Sum:', sum);
});
console.log('4. After processing');

// Output order: 1, 4, 2, 3 (asynchronous)
```

---

## The Event Loop Visualization

The **event loop** is JavaScript's mechanism for handling asynchronous operations.

### JavaScript Runtime Components

```
┌─────────────────────────────────────────────────┐
│              JavaScript Runtime                 │
├─────────────────────────────────────────────────┤
│                                                 │
│  ┌──────────────┐      ┌──────────────────┐   │
│  │  Call Stack  │      │    Web APIs      │   │
│  │              │      │  - setTimeout    │   │
│  │   main()     │      │  - fetch         │   │
│  │   foo()      │      │  - DOM events    │   │
│  │   bar()      │      │  - File I/O      │   │
│  └──────────────┘      └──────────────────┘   │
│                                                 │
│  ┌──────────────────────────────────────────┐  │
│  │         Callback Queue (Task Queue)      │  │
│  │  [callback1] [callback2] [callback3]     │  │
│  └──────────────────────────────────────────┘  │
│                      ▲                          │
│                      │                          │
│                 Event Loop                      │
│  "Is call stack empty? Move callback to stack" │
└─────────────────────────────────────────────────┘
```

### Event Loop Algorithm

```
1. Execute synchronous code (call stack)
2. When async operation completes, add callback to queue
3. Event loop checks: Is call stack empty?
   - YES: Move first callback from queue to call stack
   - NO: Wait and check again
4. Repeat steps 3-4 forever
```

### Visual Example

```javascript
/**
 * Event loop execution trace
 */

console.log('A');  // 1. Added to call stack, executes immediately

setTimeout(() => {
  console.log('B');  // 4. Executed from callback queue
}, 0);

console.log('C');  // 2. Added to call stack, executes immediately

// Execution trace:
// 1. "A" - synchronous, runs immediately
// 2. setTimeout - registers callback in Web API, continues
// 3. "C" - synchronous, runs immediately
// 4. Call stack empty, event loop moves setTimeout callback to stack
// 5. "B" - callback executes

// Output: A, C, B
```

### Detailed Timeline

```javascript
/**
 * Step-by-step event loop timeline
 */

// TIME: 0ms
console.log('1. Start');

// TIME: ~0ms - Register timer
setTimeout(() => {
  console.log('3. First timeout (100ms)');
}, 100);

// TIME: ~0ms - Register timer
setTimeout(() => {
  console.log('4. Second timeout (0ms)');
}, 0);

// TIME: ~1ms
console.log('2. End of synchronous code');

// Timeline:
// 0ms:   "1. Start" (call stack)
// 0ms:   Register 100ms timer (Web API)
// 0ms:   Register 0ms timer (Web API)
// 1ms:   "2. End of synchronous code" (call stack)
// 1ms:   Call stack empty, 0ms timer callback queued
// 1ms:   "4. Second timeout (0ms)" (from queue)
// 100ms: "3. First timeout (100ms)" (from queue)
```

---

## Callback Patterns

Common patterns for using callbacks effectively.

### Basic Callback Pattern

```javascript
/**
 * Standard callback pattern
 */

const fetchUser = (userId, callback) => {
  // Simulate async database query
  setTimeout(() => {
    const user = { id: userId, name: 'Alice', email: 'alice@example.com' };
    callback(user);
  }, 1000);
};

// Usage
fetchUser(123, user => {
  console.log('User fetched:', user);
});
```

### Multiple Callbacks (Success/Error)

```javascript
/**
 * Success/error callback pattern
 */

const fetchUserWithHandlers = (userId, onSuccess, onError) => {
  setTimeout(() => {
    if (userId > 0) {
      const user = { id: userId, name: 'Alice' };
      onSuccess(user);
    } else {
      onError(new Error('Invalid user ID'));
    }
  }, 1000);
};

// Usage
fetchUserWithHandlers(
  123,
  user => console.log('Success:', user),
  error => console.error('Error:', error.message)
);
```

### Callback with Context (this binding)

```javascript
/**
 * Callbacks with proper context handling
 */

const UserManager = {
  users: [],

  addUser(user, callback) {
    this.users.push(user);
    // Use arrow function to preserve 'this'
    setTimeout(() => {
      callback(this.users.length);
    }, 100);
  },

  // OR bind explicitly
  addUserBound(user, callback) {
    this.users.push(user);
    setTimeout(function() {
      callback(this.users.length);
    }.bind(this), 100);
  }
};

UserManager.addUser({ name: 'Alice' }, count => {
  console.log(`Total users: ${count}`);
});
```

---

## Error-First Callbacks

The **error-first callback** convention is standard in Node.js.

### Error-First Pattern

```javascript
/**
 * Error-first callback pattern (Node.js convention)
 * Callback signature: (error, result) => {}
 */

const readFileSimulated = (filename, callback) => {
  setTimeout(() => {
    if (filename.endsWith('.txt')) {
      // Success: error is null, result is provided
      callback(null, `Contents of ${filename}`);
    } else {
      // Error: error object is first parameter
      callback(new Error('Only .txt files supported'), null);
    }
  }, 1000);
};

// Usage: Always check error first!
readFileSimulated('data.txt', (error, data) => {
  if (error) {
    console.error('Error reading file:', error.message);
    return;  // Important: exit early on error
  }

  console.log('File data:', data);
});
```

### Real Node.js Example

```javascript
/**
 * Node.js fs module uses error-first callbacks
 */

import fs from 'fs';

// Reading a file (error-first callback)
fs.readFile('example.txt', 'utf8', (err, data) => {
  if (err) {
    console.error('Failed to read file:', err.message);
    return;
  }

  console.log('File contents:', data);
});

// Writing a file (error-first callback)
fs.writeFile('output.txt', 'Hello World', err => {
  if (err) {
    console.error('Failed to write file:', err.message);
    return;
  }

  console.log('File written successfully');
});
```

### Error Handling Best Practices

```javascript
/**
 * Proper error handling in callbacks
 */

const processData = (data, callback) => {
  setTimeout(() => {
    try {
      if (!data) {
        throw new Error('Data is required');
      }

      if (typeof data !== 'string') {
        throw new TypeError('Data must be a string');
      }

      const result = data.toUpperCase();
      callback(null, result);
    } catch (error) {
      // Catch synchronous errors and pass to callback
      callback(error, null);
    }
  }, 100);
};

// Usage with proper error handling
processData('hello', (err, result) => {
  if (err) {
    console.error('Processing failed:', err.message);
    return;
  }

  console.log('Result:', result);  // "HELLO"
});
```

---

## Callback Hell / Pyramid of Doom

**Callback hell** occurs when multiple nested callbacks create deeply indented, hard-to-read code.

### The Problem: Nested Callbacks

```javascript
/**
 * Classic callback hell example
 * This code is hard to read and maintain!
 */

const getUser = (userId, callback) => {
  setTimeout(() => callback(null, { id: userId, name: 'Alice' }), 100);
};

const getOrders = (userId, callback) => {
  setTimeout(() => callback(null, [{ id: 1, total: 100 }]), 100);
};

const getOrderDetails = (orderId, callback) => {
  setTimeout(() => callback(null, { items: ['Book', 'Pen'] }), 100);
};

// Callback hell begins...
getUser(123, (err, user) => {
  if (err) {
    console.error(err);
    return;
  }

  console.log('User:', user.name);

  getOrders(user.id, (err, orders) => {
    if (err) {
      console.error(err);
      return;
    }

    console.log('Orders:', orders.length);

    getOrderDetails(orders[0].id, (err, details) => {
      if (err) {
        console.error(err);
        return;
      }

      console.log('First order items:', details.items);

      // Imagine more nesting here...
      // This becomes a pyramid of doom!
    });
  });
});
```

### Why Callback Hell is Bad

1. **Readability:** Hard to follow the logic flow
2. **Maintainability:** Difficult to add features or fix bugs
3. **Error Handling:** Repetitive error checking code
4. **Debugging:** Hard to trace execution path
5. **Testing:** Complex to write unit tests
6. **Scope Issues:** Variable scoping becomes confusing

### Visualizing the Pyramid

```javascript
/**
 * The "pyramid of doom" shape
 */

operation1(param1, (err, result1) => {
  if (err) handleError(err);

    operation2(result1, (err, result2) => {
      if (err) handleError(err);

        operation3(result2, (err, result3) => {
          if (err) handleError(err);

            operation4(result3, (err, result4) => {
              if (err) handleError(err);

                operation5(result4, (err, result5) => {
                  if (err) handleError(err);
                  // Finally done!
                });
            });
        });
    });
});
```

---

## Solutions to Callback Hell

Several techniques can flatten callback pyramids.

### Solution 1: Named Functions

```javascript
/**
 * Extract callbacks into named functions
 */

const handleOrderDetails = (err, details) => {
  if (err) {
    console.error('Order details error:', err);
    return;
  }
  console.log('First order items:', details.items);
};

const handleOrders = user => (err, orders) => {
  if (err) {
    console.error('Orders error:', err);
    return;
  }
  console.log('Orders:', orders.length);
  getOrderDetails(orders[0].id, handleOrderDetails);
};

const handleUser = (err, user) => {
  if (err) {
    console.error('User error:', err);
    return;
  }
  console.log('User:', user.name);
  getOrders(user.id, handleOrders(user));
};

// Much flatter!
getUser(123, handleUser);
```

### Solution 2: Modularization

```javascript
/**
 * Break into separate modules/functions
 */

const fetchUserData = userId => {
  return new Promise((resolve, reject) => {
    getUser(userId, (err, user) => {
      if (err) reject(err);
      else resolve(user);
    });
  });
};

const fetchUserOrders = userId => {
  return new Promise((resolve, reject) => {
    getOrders(userId, (err, orders) => {
      if (err) reject(err);
      else resolve(orders);
    });
  });
};

// Now can be chained or used with async/await
```

### Solution 3: Control Flow Libraries

```javascript
/**
 * Using async.js library for control flow
 * (Note: This is legacy, use Promises/async-await in modern code)
 */

import async from 'async';

async.waterfall([
  // Step 1: Get user
  callback => {
    getUser(123, callback);
  },

  // Step 2: Get orders
  (user, callback) => {
    console.log('User:', user.name);
    getOrders(user.id, callback);
  },

  // Step 3: Get order details
  (orders, callback) => {
    console.log('Orders:', orders.length);
    getOrderDetails(orders[0].id, callback);
  }
], (err, details) => {
  if (err) {
    console.error('Error:', err);
    return;
  }
  console.log('Order items:', details.items);
});
```

### Solution 4: Early Returns

```javascript
/**
 * Use early returns to reduce nesting
 */

const processUserOrders = userId => {
  getUser(userId, (err, user) => {
    if (err) return console.error('User error:', err);

    console.log('User:', user.name);

    getOrders(user.id, (err, orders) => {
      if (err) return console.error('Orders error:', err);

      console.log('Orders:', orders.length);

      getOrderDetails(orders[0].id, (err, details) => {
        if (err) return console.error('Details error:', err);

        console.log('Items:', details.items);
      });
    });
  });
};
```

---

## Real-World Examples

### Example 1: setTimeout and Timers

```javascript
/**
 * Using callbacks with setTimeout
 */

const delayedGreeting = (name, delay, callback) => {
  console.log(`Setting timer for ${delay}ms...`);

  setTimeout(() => {
    const greeting = `Hello, ${name}!`;
    callback(greeting);
  }, delay);
};

delayedGreeting('Alice', 2000, message => {
  console.log(message);  // Runs after 2 seconds
});

// Chaining timeouts
setTimeout(() => {
  console.log('First');
  setTimeout(() => {
    console.log('Second');
    setTimeout(() => {
      console.log('Third');
    }, 1000);
  }, 1000);
}, 1000);
// Output after 3 seconds: "First", "Second", "Third"
```

### Example 2: Event Handlers

```javascript
/**
 * Callbacks in event listeners
 */

// Browser environment
if (typeof document !== 'undefined') {
  const button = document.querySelector('#myButton');

  // Callback executed when button is clicked
  button.addEventListener('click', event => {
    console.log('Button clicked!');
    console.log('Event:', event.type);
  });

  // Multiple event handlers
  button.addEventListener('click', () => {
    console.log('First handler');
  });

  button.addEventListener('click', () => {
    console.log('Second handler');
  });
}
```

### Example 3: File Operations (Node.js)

```javascript
/**
 * Reading and writing files with callbacks
 */

import fs from 'fs';
import path from 'path';

// Read file, transform, write to new file
const transformFile = (inputPath, outputPath, transformFn, callback) => {
  fs.readFile(inputPath, 'utf8', (err, data) => {
    if (err) return callback(err);

    try {
      const transformed = transformFn(data);

      fs.writeFile(outputPath, transformed, err => {
        if (err) return callback(err);
        callback(null, 'Success');
      });
    } catch (error) {
      callback(error);
    }
  });
};

// Usage
transformFile(
  'input.txt',
  'output.txt',
  data => data.toUpperCase(),
  (err, result) => {
    if (err) {
      console.error('Transform failed:', err.message);
      return;
    }
    console.log('Transform complete:', result);
  }
);
```

---

## Worked Examples

### Example 1: Simple Async Counter

```javascript
/**
 * Worked Example 1: Async counter with callbacks
 *
 * Demonstrates:
 * - Callback execution order
 * - Asynchronous timing
 * - State management with callbacks
 */

class AsyncCounter {
  constructor() {
    this.count = 0;
  }

  increment(callback) {
    setTimeout(() => {
      this.count++;
      callback(null, this.count);
    }, 100);
  }

  decrement(callback) {
    setTimeout(() => {
      this.count--;
      callback(null, this.count);
    }, 100);
  }

  getValue(callback) {
    setTimeout(() => {
      callback(null, this.count);
    }, 50);
  }
}

// Usage
const counter = new AsyncCounter();

counter.increment((err, value) => {
  console.log('After increment:', value);  // 1

  counter.increment((err, value) => {
    console.log('After second increment:', value);  // 2

    counter.decrement((err, value) => {
      console.log('After decrement:', value);  // 1
    });
  });
});
```

### Example 2: Simulated API Request Queue

```javascript
/**
 * Worked Example 2: API request queue with rate limiting
 *
 * Demonstrates:
 * - Queue management with callbacks
 * - Rate limiting
 * - Error-first callbacks
 */

class RequestQueue {
  constructor(delayMs = 1000) {
    this.queue = [];
    this.processing = false;
    this.delayMs = delayMs;
  }

  enqueue(task, callback) {
    this.queue.push({ task, callback });
    this.process();
  }

  process() {
    if (this.processing || this.queue.length === 0) {
      return;
    }

    this.processing = true;
    const { task, callback } = this.queue.shift();

    setTimeout(() => {
      try {
        const result = task();
        callback(null, result);
      } catch (error) {
        callback(error, null);
      }

      this.processing = false;
      this.process();  // Process next item
    }, this.delayMs);
  }
}

// Usage
const queue = new RequestQueue(500);

queue.enqueue(
  () => ({ data: 'First request' }),
  (err, result) => console.log('1:', result)
);

queue.enqueue(
  () => ({ data: 'Second request' }),
  (err, result) => console.log('2:', result)
);

queue.enqueue(
  () => ({ data: 'Third request' }),
  (err, result) => console.log('3:', result)
);

// Output (with 500ms delays):
// 1: { data: 'First request' }
// 2: { data: 'Second request' }
// 3: { data: 'Third request' }
```

### Example 3: Callback-based Data Validator

```javascript
/**
 * Worked Example 3: Async data validation
 *
 * Demonstrates:
 * - Multiple validation steps
 * - Error accumulation
 * - Callback composition
 */

const validateEmail = (email, callback) => {
  setTimeout(() => {
    const isValid = /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
    if (isValid) {
      callback(null, email);
    } else {
      callback(new Error('Invalid email format'));
    }
  }, 100);
};

const validateAge = (age, callback) => {
  setTimeout(() => {
    if (typeof age !== 'number') {
      callback(new Error('Age must be a number'));
    } else if (age < 0 || age > 150) {
      callback(new Error('Age must be between 0 and 150'));
    } else {
      callback(null, age);
    }
  }, 100);
};

const validateUsername = (username, callback) => {
  setTimeout(() => {
    if (username.length < 3) {
      callback(new Error('Username must be at least 3 characters'));
    } else if (!/^[a-zA-Z0-9_]+$/.test(username)) {
      callback(new Error('Username can only contain letters, numbers, and underscores'));
    } else {
      callback(null, username);
    }
  }, 100);
};

// Validate user object
const validateUser = (user, callback) => {
  const errors = [];
  let completedValidations = 0;
  const totalValidations = 3;

  const checkComplete = () => {
    completedValidations++;
    if (completedValidations === totalValidations) {
      if (errors.length > 0) {
        callback(new Error(errors.join(', ')), null);
      } else {
        callback(null, user);
      }
    }
  };

  validateEmail(user.email, err => {
    if (err) errors.push(err.message);
    checkComplete();
  });

  validateAge(user.age, err => {
    if (err) errors.push(err.message);
    checkComplete();
  });

  validateUsername(user.username, err => {
    if (err) errors.push(err.message);
    checkComplete();
  });
};

// Test
const validUser = {
  email: 'alice@example.com',
  age: 25,
  username: 'alice_123'
};

validateUser(validUser, (err, user) => {
  if (err) {
    console.error('Validation failed:', err.message);
  } else {
    console.log('User is valid:', user);
  }
});
```

---

## Exercises

### Exercise 1: Basic Callback Implementation (Easy)

**Problem:**
Create a function `repeatOperation` that takes a number, an operation function, and a callback. It should execute the operation the specified number of times with a 500ms delay between each execution, then call the callback with the results array.

**Starter Code:**
```javascript
/**
 * Exercise 1: repeatOperation
 *
 * @param {number} times - Number of times to repeat
 * @param {function} operation - Function to execute
 * @param {function} callback - Called with results array
 */
const repeatOperation = (times, operation, callback) => {
  // Your code here
};

// Test
repeatOperation(3, () => Math.random(), (results) => {
  console.log('Results:', results);
  // Should print array of 3 random numbers
});
```

**Solution:** See `solutions/exercise1.js`

---

### Exercise 2: Error-First File Reader (Medium)

**Problem:**
Implement a simulated file reader that follows the error-first callback pattern. If the filename starts with "error", call the callback with an error. Otherwise, simulate reading the file and return mock content.

**Starter Code:**
```javascript
/**
 * Exercise 2: readFileMock
 *
 * @param {string} filename - File to read
 * @param {function} callback - Error-first callback (err, data)
 */
const readFileMock = (filename, callback) => {
  // Your code here
  // Simulate async with setTimeout (100ms)
  // If filename starts with "error", callback with error
  // Otherwise callback with mock content
};

// Test
readFileMock('data.txt', (err, data) => {
  if (err) console.error(err);
  else console.log(data);
});

readFileMock('error.txt', (err, data) => {
  if (err) console.error('Expected error:', err.message);
  else console.log(data);
});
```

**Solution:** See `solutions/exercise2.js`

---

### Exercise 3: Callback Waterfall (Medium)

**Problem:**
Create a `waterfall` function that executes an array of async functions in sequence, passing the result of each to the next. Use callbacks.

**Starter Code:**
```javascript
/**
 * Exercise 3: waterfall
 *
 * @param {Array<function>} tasks - Array of callback functions
 * @param {function} finalCallback - Called with final result
 */
const waterfall = (tasks, finalCallback) => {
  // Your code here
};

// Test
waterfall([
  callback => {
    setTimeout(() => callback(null, 1), 100);
  },
  (result, callback) => {
    setTimeout(() => callback(null, result * 2), 100);
  },
  (result, callback) => {
    setTimeout(() => callback(null, result + 10), 100);
  }
], (err, result) => {
  console.log('Final result:', result);  // Should be 12
});
```

**Solution:** See `solutions/exercise3.js`

---

### Exercise 4: Parallel Callbacks (Medium)

**Problem:**
Create a function that executes multiple async operations in parallel and calls the final callback when all are complete.

**Starter Code:**
```javascript
/**
 * Exercise 4: parallel
 *
 * @param {Array<function>} tasks - Array of async functions
 * @param {function} callback - Called when all complete
 */
const parallel = (tasks, callback) => {
  // Your code here
};

// Test
parallel([
  cb => setTimeout(() => cb(null, 'A'), 200),
  cb => setTimeout(() => cb(null, 'B'), 100),
  cb => setTimeout(() => cb(null, 'C'), 300)
], (err, results) => {
  console.log('Results:', results);  // ['A', 'B', 'C']
});
```

**Solution:** See `solutions/exercise4.js`

---

### Exercise 5: Callback Retry Logic (Hard)

**Problem:**
Implement a retry function that attempts an async operation up to N times before giving up.

**Starter Code:**
```javascript
/**
 * Exercise 5: retry
 *
 * @param {number} maxAttempts - Maximum retry attempts
 * @param {function} operation - Async operation to retry
 * @param {function} callback - Final callback
 */
const retry = (maxAttempts, operation, callback) => {
  // Your code here
};

// Test with flaky operation
let attempts = 0;
const flakyOperation = callback => {
  attempts++;
  setTimeout(() => {
    if (attempts < 3) {
      callback(new Error('Failed'));
    } else {
      callback(null, 'Success!');
    }
  }, 100);
};

retry(5, flakyOperation, (err, result) => {
  if (err) console.error('All attempts failed');
  else console.log('Result:', result);
});
```

**Solution:** See `solutions/exercise5.js`

---

### Exercise 6: Callback Debounce (Hard)

**Problem:**
Create a debounce function that delays callback execution until after N milliseconds have elapsed since the last call.

**Starter Code:**
```javascript
/**
 * Exercise 6: debounce
 *
 * @param {function} func - Function to debounce
 * @param {number} delay - Delay in milliseconds
 * @returns {function} Debounced function
 */
const debounce = (func, delay) => {
  // Your code here
};

// Test
const logMessage = msg => console.log('Message:', msg);
const debouncedLog = debounce(logMessage, 1000);

debouncedLog('First');   // Won't log
debouncedLog('Second');  // Won't log
debouncedLog('Third');   // Will log after 1 second
```

**Solution:** See `solutions/exercise6.js`

---

## Testing & Verification

### Testing Callbacks with Vitest

```javascript
/**
 * Testing callback-based functions
 */

import { describe, it, expect, vi } from 'vitest';

describe('Callback functions', () => {
  it('should execute callback with result', done => {
    const asyncFunction = callback => {
      setTimeout(() => {
        callback('result');
      }, 100);
    };

    asyncFunction(result => {
      expect(result).toBe('result');
      done();  // Tell Vitest async test is complete
    });
  });

  it('should handle errors in error-first callbacks', done => {
    const asyncFunction = callback => {
      setTimeout(() => {
        callback(new Error('Test error'), null);
      }, 100);
    };

    asyncFunction((err, data) => {
      expect(err).toBeInstanceOf(Error);
      expect(err.message).toBe('Test error');
      expect(data).toBeNull();
      done();
    });
  });

  it('should call callback correct number of times', () => {
    const mockCallback = vi.fn();
    const numbers = [1, 2, 3];

    numbers.forEach(mockCallback);

    expect(mockCallback).toHaveBeenCalledTimes(3);
    expect(mockCallback).toHaveBeenNthCalledWith(1, 1, 0, numbers);
  });
});
```

### Testing with Promises (Modern Approach)

```javascript
/**
 * Convert callbacks to promises for easier testing
 */

import { describe, it, expect } from 'vitest';

// Promisify callback function
const promisify = fn => {
  return (...args) => {
    return new Promise((resolve, reject) => {
      fn(...args, (err, result) => {
        if (err) reject(err);
        else resolve(result);
      });
    });
  };
};

const asyncOperation = (value, callback) => {
  setTimeout(() => {
    if (value > 0) {
      callback(null, value * 2);
    } else {
      callback(new Error('Value must be positive'));
    }
  }, 100);
};

const asyncOperationPromise = promisify(asyncOperation);

describe('Promisified callbacks', () => {
  it('should resolve with result', async () => {
    const result = await asyncOperationPromise(5);
    expect(result).toBe(10);
  });

  it('should reject with error', async () => {
    await expect(asyncOperationPromise(-1))
      .rejects
      .toThrow('Value must be positive');
  });
});
```

---

## Best Practices

### 1. Always Handle Errors

```javascript
// ✅ GOOD: Check for errors
callback((err, result) => {
  if (err) {
    console.error('Error:', err);
    return;
  }
  console.log(result);
});

// ❌ BAD: Ignoring errors
callback((err, result) => {
  console.log(result);  // Could be undefined!
});
```

### 2. Use Error-First Convention

```javascript
// ✅ GOOD: Error-first
const myFunction = (param, callback) => {
  if (error) {
    callback(new Error('Something went wrong'), null);
  } else {
    callback(null, result);
  }
};

// ❌ BAD: Inconsistent signature
const myFunction = (param, callback) => {
  if (error) {
    callback(result, error);  // Backwards!
  }
};
```

### 3. Call Callback Only Once

```javascript
// ✅ GOOD: Single callback invocation
const processData = (data, callback) => {
  if (!data) {
    return callback(new Error('No data'));
  }

  callback(null, data.toUpperCase());
};

// ❌ BAD: Multiple callbacks
const processData = (data, callback) => {
  if (!data) {
    callback(new Error('No data'));
    // Falls through and calls callback again!
  }

  callback(null, data.toUpperCase());
};
```

### 4. Make Callbacks Optional

```javascript
// ✅ GOOD: Optional callback
const processData = (data, callback) => {
  const result = data.toUpperCase();

  if (callback) {
    callback(null, result);
  }

  return result;
};
```

### 5. Use Named Functions for Clarity

```javascript
// ✅ GOOD: Named function
const handleUserData = (err, user) => {
  if (err) return console.error(err);
  console.log(user);
};

fetchUser(123, handleUserData);

// ❌ ACCEPTABLE but less clear: Anonymous function
fetchUser(123, (err, user) => {
  if (err) return console.error(err);
  console.log(user);
});
```

---

## Common Pitfalls

### Pitfall 1: Callback Called Multiple Times

```javascript
// ❌ WRONG
const fetchData = callback => {
  if (cache) {
    callback(null, cache);
  }

  fetch('/api/data')
    .then(data => callback(null, data));  // Called twice!
};

// ✅ CORRECT
const fetchData = callback => {
  if (cache) {
    return callback(null, cache);  // Early return
  }

  fetch('/api/data')
    .then(data => callback(null, data));
};
```

### Pitfall 2: Forgetting to Bind Context

```javascript
// ❌ WRONG
class Counter {
  constructor() {
    this.count = 0;
  }

  increment(callback) {
    setTimeout(function() {
      this.count++;  // 'this' is undefined!
      callback(this.count);
    }, 100);
  }
}

// ✅ CORRECT
class Counter {
  constructor() {
    this.count = 0;
  }

  increment(callback) {
    setTimeout(() => {
      this.count++;  // Arrow function preserves 'this'
      callback(this.count);
    }, 100);
  }
}
```

### Pitfall 3: Zalgo (Mixed Sync/Async)

```javascript
// ❌ WRONG: Sometimes sync, sometimes async
const getData = (useCache, callback) => {
  if (useCache) {
    callback(cachedData);  // Synchronous!
  } else {
    fetchData(data => {
      callback(data);  // Asynchronous!
    });
  }
};

// ✅ CORRECT: Always async
const getData = (useCache, callback) => {
  if (useCache) {
    process.nextTick(() => callback(cachedData));
  } else {
    fetchData(callback);
  }
};
```

### Pitfall 4: Not Catching Errors in Callbacks

```javascript
// ❌ WRONG: Uncaught errors
const processData = (data, callback) => {
  setTimeout(() => {
    const result = data.toUpperCase();  // What if data is undefined?
    callback(null, result);
  }, 100);
};

// ✅ CORRECT: Catch and handle errors
const processData = (data, callback) => {
  setTimeout(() => {
    try {
      if (!data) throw new Error('Data required');
      const result = data.toUpperCase();
      callback(null, result);
    } catch (error) {
      callback(error, null);
    }
  }, 100);
};
```

---

## Performance Considerations

### 1. Avoid Synchronous Operations in Callbacks

```javascript
// ❌ BAD: Blocking operation in callback
setTimeout(() => {
  for (let i = 0; i < 1000000000; i++) {
    // This blocks the event loop!
  }
}, 0);

// ✅ GOOD: Break into chunks
const processInChunks = (total, chunkSize, callback) => {
  let processed = 0;

  const processChunk = () => {
    const end = Math.min(processed + chunkSize, total);

    for (let i = processed; i < end; i++) {
      // Process item
    }

    processed = end;

    if (processed < total) {
      setTimeout(processChunk, 0);  // Let event loop breathe
    } else {
      callback();
    }
  };

  processChunk();
};
```

### 2. Limit Concurrent Callbacks

```javascript
/**
 * Process items with concurrency limit
 */
const processWithLimit = (items, limit, processor, callback) => {
  let index = 0;
  let active = 0;
  let results = [];

  const next = () => {
    while (active < limit && index < items.length) {
      const currentIndex = index++;
      active++;

      processor(items[currentIndex], (err, result) => {
        results[currentIndex] = result;
        active--;

        if (index >= items.length && active === 0) {
          callback(null, results);
        } else {
          next();
        }
      });
    }
  };

  next();
};
```

---

## Summary & Next Steps

### Key Takeaways

- Callbacks are functions passed as arguments to be executed later
- JavaScript's event loop enables non-blocking asynchronous operations
- Error-first callbacks (Node.js convention) put error as first parameter
- Callback hell makes code hard to read, maintain, and debug
- Solutions include named functions, modularization, and promises
- Always handle errors and call callbacks only once
- Modern JavaScript favors Promises and async/await over callbacks

### When to Use Callbacks

**Use callbacks for:**
- Event handlers (click, keypress, etc.)
- Simple one-off async operations
- Working with legacy APIs
- Low-level library code

**Avoid callbacks for:**
- Complex async workflows (use Promises/async-await)
- Multiple sequential operations (use async/await)
- Error-prone nested operations

### Related Topics

- [Promises](./23.Promises.md) - Modern alternative to callbacks
- [Async/Await](./24.Async_Await.md) - Syntactic sugar for promises
- [Event Loop Deep Dive](./25.Event_Loop_Deep_Dive.md) - Detailed event loop mechanics

### Further Reading

- [MDN: Callback Function](https://developer.mozilla.org/en-US/docs/Glossary/Callback_function)
- [Node.js: Error-First Callbacks](https://nodejs.org/en/knowledge/getting-started/control-flow/what-are-callbacks/)
- [JavaScript Event Loop Explained](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop)
- [You Don't Know JS: Async & Performance](https://github.com/getify/You-Dont-Know-JS)

---

**Next Lesson:** [Promises](./23.Promises.md)

---

**Practice Project:** Build a callback-based task runner that executes a series of async operations with proper error handling, retry logic, and timeout support.

