# Async/Await in JavaScript

**Difficulty:** Intermediate
**Estimated Time:** 50-65 minutes
**Prerequisites:** Promises, async JavaScript fundamentals, error handling
**Target:** Node.js 18+ LTS, Modern Browsers (ES2021+)

---

## Learning Objectives

By the end of this lesson, you will be able to:

1. Understand async/await syntax and how it relates to Promises
2. Write async functions and use the await keyword correctly
3. Implement proper error handling with try-catch blocks
4. Distinguish between sequential and parallel execution patterns
5. Combine async/await with Promise.all() for optimal performance
6. Use top-level await in ES2022+ environments
7. Compare async/await, Promises, and callbacks effectively
8. Apply async/await best practices in production code
9. Debug common async/await issues
10. Write clean, maintainable asynchronous code

---

## Table of Contents

1. [Introduction](#introduction)
2. [Async Function Syntax](#async-function-syntax)
3. [The Await Keyword](#the-await-keyword)
4. [Error Handling](#error-handling)
5. [Sequential vs Parallel Execution](#sequential-vs-parallel-execution)
6. [Async/Await with Promise Methods](#asyncawait-with-promise-methods)
7. [Top-Level Await](#top-level-await)
8. [Comparison: Async/Await vs Promises vs Callbacks](#comparison-asyncawait-vs-promises-vs-callbacks)
9. [Worked Examples](#worked-examples)
10. [Exercises](#exercises)
11. [Testing & Verification](#testing--verification)
12. [Best Practices](#best-practices)
13. [Common Pitfalls](#common-pitfalls)
14. [Performance Considerations](#performance-considerations)
15. [Summary & Next Steps](#summary--next-steps)
16. [References](#references)

---

## Introduction

**Async/await** is syntactic sugar over Promises, introduced in ES2017 (ES8). It makes asynchronous code look and behave more like synchronous code, improving readability and maintainability.

**Why Async/Await Matters:**

- **Readability:** Looks like synchronous code, easier to understand
- **Debugging:** Better stack traces and breakpoint support
- **Error Handling:** Use familiar try-catch syntax
- **Flow Control:** Natural use of if/else, loops, etc.
- **Less Boilerplate:** Cleaner than .then() chains

**Real-World Applications:**

- **API Integration:** Cleaner HTTP request handling
- **Database Operations:** Sequential queries without nesting
- **File Processing:** Multi-step file operations
- **Authentication Flows:** Complex auth sequences
- **Data Pipelines:** Transform data through async steps

---

## Async Function Syntax

### Basic Async Function

```javascript
/**
 * Async function declaration
 */

// Regular async function
async function fetchData() {
  return 'Hello, World!';
}

// This is equivalent to:
function fetchDataPromise() {
  return Promise.resolve('Hello, World!');
}

// Async functions ALWAYS return a Promise
fetchData().then(result => {
  console.log(result);  // "Hello, World!"
});

// Even if you return a non-Promise value
async function getValue() {
  return 42;
}

getValue().then(value => console.log(value));  // 42
```

### Different Async Function Forms

```javascript
/**
 * Various async function syntaxes
 */

// Function declaration
async function funcDeclaration() {
  return 'Declaration';
}

// Function expression
const funcExpression = async function() {
  return 'Expression';
};

// Arrow function
const arrowFunc = async () => {
  return 'Arrow';
};

// Method in object
const obj = {
  async method() {
    return 'Method';
  }
};

// Method in class
class MyClass {
  async classMethod() {
    return 'Class method';
  }
}

// All work the same way
funcDeclaration().then(console.log);
funcExpression().then(console.log);
arrowFunc().then(console.log);
obj.method().then(console.log);
new MyClass().classMethod().then(console.log);
```

### Async Functions Return Promises

```javascript
/**
 * Understanding async function return values
 */

async function example1() {
  return 'value';  // Returns Promise<string>
}

async function example2() {
  return Promise.resolve('value');  // Also Promise<string>
}

async function example3() {
  throw new Error('Failed');  // Returns rejected Promise
}

// All return promises
console.log(example1() instanceof Promise);  // true
console.log(example2() instanceof Promise);  // true
console.log(example3() instanceof Promise);  // true

// Handle results
example1().then(val => console.log(val));  // "value"
example2().then(val => console.log(val));  // "value"
example3().catch(err => console.error(err.message));  // "Failed"
```

---

## The Await Keyword

### Basic Await Usage

```javascript
/**
 * Using await to pause execution
 */

const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

async function example() {
  console.log('Start');

  // Await pauses execution until promise resolves
  await delay(1000);

  console.log('After 1 second');

  await delay(1000);

  console.log('After 2 seconds');

  return 'Done';
}

example().then(result => console.log(result));

// Output (with delays):
// "Start"
// (1 second pause)
// "After 1 second"
// (1 second pause)
// "After 2 seconds"
// "Done"
```

### Await Unwraps Promises

```javascript
/**
 * Await extracts the resolved value
 */

const fetchUser = () => Promise.resolve({ name: 'Alice', age: 30 });

// Without await (returns Promise)
async function withoutAwait() {
  const userPromise = fetchUser();
  console.log(userPromise);  // Promise { <pending> }
}

// With await (unwraps to value)
async function withAwait() {
  const user = await fetchUser();
  console.log(user);  // { name: 'Alice', age: 30 }
  console.log(user.name);  // 'Alice'
}

withAwait();
```

### Await Can Only Be Used in Async Functions

```javascript
/**
 * Await restrictions
 */

// ❌ ERROR: await outside async function
function regularFunction() {
  await Promise.resolve();  // SyntaxError!
}

// ✅ CORRECT: await inside async function
async function asyncFunction() {
  await Promise.resolve();  // OK
}

// ✅ CORRECT: Top-level await (ES2022, in modules)
// await Promise.resolve();  // OK in module scope

// ❌ ERROR: Can't make callback async and use await
[1, 2, 3].forEach(async n => {
  await delay(100);  // This doesn't work as expected!
  console.log(n);  // All log immediately, forEach doesn't wait
});

// ✅ CORRECT: Use for...of instead
async function processArray() {
  for (const n of [1, 2, 3]) {
    await delay(100);
    console.log(n);  // Logs with delays: 1, 2, 3
  }
}
```

### Multiple Awaits

```javascript
/**
 * Sequential await calls
 */

const fetchUser = () => {
  return new Promise(resolve => {
    setTimeout(() => resolve({ id: 1, name: 'Alice' }), 100);
  });
};

const fetchOrders = userId => {
  return new Promise(resolve => {
    setTimeout(() => resolve([{ id: 1 }, { id: 2 }]), 100);
  });
};

async function getUserOrders() {
  console.log('Fetching user...');
  const user = await fetchUser();

  console.log('Fetching orders for', user.name);
  const orders = await fetchOrders(user.id);

  console.log('Orders:', orders);
  return { user, orders };
}

getUserOrders();
```

---

## Error Handling

### Try-Catch with Async/Await

```javascript
/**
 * Error handling with try-catch
 */

const riskyOperation = shouldFail => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (shouldFail) {
        reject(new Error('Operation failed'));
      } else {
        resolve('Success');
      }
    }, 100);
  });
};

async function handleErrors() {
  try {
    const result = await riskyOperation(false);
    console.log('Result:', result);

    const result2 = await riskyOperation(true);
    console.log('Result2:', result2);  // Never reached
  } catch (error) {
    console.error('Caught error:', error.message);
  }
}

handleErrors();
```

### Handling Multiple Operations

```javascript
/**
 * Error handling for multiple operations
 */

async function multipleOperations() {
  try {
    const user = await fetchUser(123);
    console.log('User fetched:', user.name);

    const orders = await fetchOrders(user.id);
    console.log('Orders fetched:', orders.length);

    const details = await fetchOrderDetails(orders[0].id);
    console.log('Details fetched:', details);

    return { user, orders, details };
  } catch (error) {
    console.error('Error in operation:', error.message);
    throw error;  // Re-throw if can't recover
  }
}

// Handle at call site
multipleOperations()
  .then(data => console.log('Success:', data))
  .catch(error => console.error('Final error:', error));
```

### Specific Error Handling

```javascript
/**
 * Handle different error types
 */

class NetworkError extends Error {
  constructor(message) {
    super(message);
    this.name = 'NetworkError';
  }
}

class ValidationError extends Error {
  constructor(message) {
    super(message);
    this.name = 'ValidationError';
  }
}

async function fetchData(url) {
  try {
    const response = await fetch(url);

    if (!response.ok) {
      throw new NetworkError(`HTTP ${response.status}`);
    }

    const data = await response.json();

    if (!data.valid) {
      throw new ValidationError('Invalid data format');
    }

    return data;
  } catch (error) {
    if (error instanceof NetworkError) {
      console.error('Network error:', error.message);
      return getCachedData();  // Fallback
    } else if (error instanceof ValidationError) {
      console.error('Validation error:', error.message);
      return getDefaultData();
    } else {
      throw error;  // Unknown error
    }
  }
}
```

### Finally Block

```javascript
/**
 * Cleanup with finally
 */

async function fetchWithLoading(url) {
  let isLoading = true;
  console.log('Loading started');

  try {
    const response = await fetch(url);
    const data = await response.json();
    console.log('Data received');
    return data;
  } catch (error) {
    console.error('Error:', error);
    throw error;
  } finally {
    isLoading = false;
    console.log('Loading finished');
    // Cleanup code runs regardless of success/failure
  }
}
```

---

## Sequential vs Parallel Execution

Understanding when operations run in sequence vs parallel is critical for performance.

### Sequential Execution (One After Another)

```javascript
/**
 * Sequential execution - slower but sometimes necessary
 */

async function sequentialExample() {
  console.log('Start');
  const start = Date.now();

  // These run ONE AT A TIME
  const user = await fetchUser();  // Wait 100ms
  const orders = await fetchOrders(user.id);  // Wait another 100ms
  const details = await fetchOrderDetails(orders[0].id);  // Wait another 100ms

  const elapsed = Date.now() - start;
  console.log(`Total time: ${elapsed}ms`);  // ~300ms

  return { user, orders, details };
}

// Use sequential when:
// - Next operation depends on previous result
// - Order matters
// - Operations must not overlap
```

### Parallel Execution (All at Once)

```javascript
/**
 * Parallel execution - faster when operations are independent
 */

async function parallelExample() {
  console.log('Start');
  const start = Date.now();

  // Start all operations simultaneously
  const userPromise = fetchUser();
  const settingsPromise = fetchSettings();
  const notificationsPromise = fetchNotifications();

  // Wait for all to complete
  const [user, settings, notifications] = await Promise.all([
    userPromise,
    settingsPromise,
    notificationsPromise
  ]);

  const elapsed = Date.now() - start;
  console.log(`Total time: ${elapsed}ms`);  // ~100ms (not 300ms!)

  return { user, settings, notifications };
}

// Use parallel when:
// - Operations are independent
// - Order doesn't matter
// - Want to minimize total time
```

### Comparison: Sequential vs Parallel

```javascript
/**
 * Side-by-side comparison
 */

// SEQUENTIAL: 300ms total
async function sequential() {
  const a = await delay(100, 'A');  // 0-100ms
  const b = await delay(100, 'B');  // 100-200ms
  const c = await delay(100, 'C');  // 200-300ms
  return [a, b, c];
}

// PARALLEL: 100ms total
async function parallel() {
  const [a, b, c] = await Promise.all([
    delay(100, 'A'),  // 0-100ms
    delay(100, 'B'),  // 0-100ms (concurrent!)
    delay(100, 'C')   // 0-100ms (concurrent!)
  ]);
  return [a, b, c];
}

// MIXED: 200ms total (2 parallel, then 1 sequential)
async function mixed() {
  const [a, b] = await Promise.all([
    delay(100, 'A'),  // 0-100ms
    delay(100, 'B')   // 0-100ms (concurrent)
  ]);

  const c = await delay(100, 'C');  // 100-200ms (sequential)

  return [a, b, c];
}
```

### Common Pattern: Independent Then Dependent

```javascript
/**
 * Fetch independent data in parallel, then process sequentially
 */

async function loadDashboard(userId) {
  // Phase 1: Fetch independent data in parallel
  const [user, settings, preferences] = await Promise.all([
    fetchUser(userId),
    fetchSettings(userId),
    fetchPreferences(userId)
  ]);

  // Phase 2: Use results for dependent operations
  const theme = await loadTheme(preferences.themeId);
  const layout = await loadLayout(settings.layoutId);

  // Phase 3: Final assembly
  return {
    user,
    settings,
    preferences,
    theme,
    layout
  };
}
```

---

## Async/Await with Promise Methods

Combine async/await with Promise static methods for powerful patterns.

### Promise.all() with Async/Await

```javascript
/**
 * Process multiple items in parallel
 */

async function fetchMultipleUsers(userIds) {
  // Map to array of promises
  const promises = userIds.map(id => fetchUser(id));

  // Wait for all
  const users = await Promise.all(promises);

  return users;
}

// Usage
const users = await fetchMultipleUsers([1, 2, 3, 4, 5]);
console.log('All users:', users);
```

### Promise.allSettled() for Partial Failures

```javascript
/**
 * Handle operations that might partially fail
 */

async function fetchAllData() {
  const results = await Promise.allSettled([
    fetchUser(1),
    fetchUser(999),  // Might fail
    fetchUser(3)
  ]);

  const successful = results
    .filter(r => r.status === 'fulfilled')
    .map(r => r.value);

  const failed = results
    .filter(r => r.status === 'rejected')
    .map(r => r.reason);

  console.log(`Success: ${successful.length}, Failed: ${failed.length}`);

  return successful;
}
```

### Promise.race() for Timeouts

```javascript
/**
 * Implement timeout with async/await
 */

const timeout = ms => {
  return new Promise((_, reject) => {
    setTimeout(() => reject(new Error('Timeout')), ms);
  });
};

async function fetchWithTimeout(url, ms) {
  try {
    const result = await Promise.race([
      fetch(url),
      timeout(ms)
    ]);

    return await result.json();
  } catch (error) {
    if (error.message === 'Timeout') {
      console.error('Request timed out');
      throw error;
    }
    throw error;
  }
}

// Usage
try {
  const data = await fetchWithTimeout('/api/slow', 3000);
  console.log(data);
} catch (error) {
  console.error('Failed:', error.message);
}
```

---

## Top-Level Await

ES2022 introduced top-level await in modules.

### Top-Level Await in Modules

```javascript
/**
 * Top-level await (ES2022+)
 * Only works in ES modules (type: "module")
 */

// Before: Had to wrap in async function
// (async () => {
//   const data = await fetchData();
//   console.log(data);
// })();

// Now: Can use await at module top level
const data = await fetchData();
console.log(data);

// Useful for module initialization
const config = await fetch('/api/config').then(r => r.json());
export { config };

// Database connection
const db = await connectToDatabase();
export { db };
```

### Top-Level Await Use Cases

```javascript
/**
 * Practical top-level await patterns
 */

// Dynamic imports
const theme = await import(`./themes/${themeName}.js`);

// Feature detection
const hasFeature = await checkFeatureAvailability();
if (!hasFeature) {
  console.warn('Feature not available');
}

// Config loading
const config = await loadConfig();
const api = createAPI(config);
export { api };

// Dependency loading
const [user, settings] = await Promise.all([
  fetchUser(),
  fetchSettings()
]);

export { user, settings };
```

---

## Comparison: Async/Await vs Promises vs Callbacks

### Same Operation, Three Styles

```javascript
/**
 * Callback style
 */
function getUserOrdersCallback(userId, callback) {
  getUser(userId, (err, user) => {
    if (err) return callback(err);

    getOrders(user.id, (err, orders) => {
      if (err) return callback(err);

      getOrderDetails(orders[0].id, (err, details) => {
        if (err) return callback(err);

        callback(null, { user, orders, details });
      });
    });
  });
}

/**
 * Promise style
 */
function getUserOrdersPromise(userId) {
  return getUser(userId)
    .then(user => {
      return getOrders(user.id)
        .then(orders => {
          return getOrderDetails(orders[0].id)
            .then(details => {
              return { user, orders, details };
            });
        });
    });
}

/**
 * Async/await style
 */
async function getUserOrdersAsync(userId) {
  const user = await getUser(userId);
  const orders = await getOrders(user.id);
  const details = await getOrderDetails(orders[0].id);
  return { user, orders, details };
}

// Async/await is clearly the cleanest!
```

### Decision Matrix

| Aspect | Callbacks | Promises | Async/Await |
|--------|-----------|----------|-------------|
| **Readability** | Poor (nested) | Good | Excellent |
| **Error Handling** | Manual, repetitive | .catch() | try-catch |
| **Debugging** | Difficult | Better | Best |
| **Browser Support** | All | Modern (IE11+) | Modern (no IE) |
| **Learning Curve** | Easy | Moderate | Easy |
| **Composability** | Poor | Good | Excellent |

### When to Use Each

```javascript
/**
 * Use callbacks for:
 */
// - Event handlers
button.addEventListener('click', () => console.log('Clicked'));

// - Simple one-off operations
setTimeout(() => console.log('Done'), 1000);

// - Legacy API compatibility
fs.readFile('file.txt', (err, data) => {});

/**
 * Use promises for:
 */
// - Complex chaining with branching
fetchUser()
  .then(user => user.isPremium ? fetchPremiumData() : fetchBasicData())
  .then(data => processData(data));

// - Parallel operations
Promise.all([fetch1(), fetch2(), fetch3()]);

/**
 * Use async/await for:
 */
// - Sequential operations (most common)
async function process() {
  const user = await fetchUser();
  const data = await fetchData(user.id);
  return processData(data);
}

// - Complex logic with conditions/loops
async function processUsers(userIds) {
  for (const id of userIds) {
    const user = await fetchUser(id);
    if (user.active) {
      await processActiveUser(user);
    }
  }
}
```

---

## Worked Examples

### Example 1: User Authentication Flow

```javascript
/**
 * Worked Example 1: Complete auth flow
 *
 * Demonstrates:
 * - Sequential async operations
 * - Error handling
 * - Data transformation
 */

const validateCredentials = async (username, password) => {
  await delay(200);

  if (username === 'admin' && password === 'secret') {
    return { username, valid: true };
  }

  throw new Error('Invalid credentials');
};

const fetchUserProfile = async username => {
  await delay(200);
  return {
    username,
    email: `${username}@example.com`,
    role: 'admin',
    permissions: ['read', 'write', 'delete']
  };
};

const generateAuthToken = async user => {
  await delay(200);
  const token = `token_${Date.now()}_${user.username}`;
  return { ...user, token };
};

const authenticateUser = async (username, password) => {
  try {
    console.log('Validating credentials...');
    const credentials = await validateCredentials(username, password);

    console.log('Fetching user profile...');
    const profile = await fetchUserProfile(credentials.username);

    console.log('Generating auth token...');
    const authData = await generateAuthToken(profile);

    console.log('Authentication successful!');
    return authData;
  } catch (error) {
    console.error('Authentication failed:', error.message);
    throw error;
  }
};

// Test
authenticateUser('admin', 'secret')
  .then(user => console.log('Logged in:', user))
  .catch(error => console.log('Login failed'));
```

### Example 2: Parallel Data Processing

```javascript
/**
 * Worked Example 2: Process multiple items efficiently
 *
 * Demonstrates:
 * - Parallel execution
 * - Error handling for individual items
 * - Result aggregation
 */

const processItem = async (item, index) => {
  await delay(100 * Math.random());

  if (item.value < 0) {
    throw new Error(`Invalid item at index ${index}`);
  }

  return {
    ...item,
    processed: true,
    result: item.value * 2
  };
};

const processItemsInParallel = async items => {
  console.log(`Processing ${items.length} items...`);

  const results = await Promise.allSettled(
    items.map((item, index) => processItem(item, index))
  );

  const successful = results.filter(r => r.status === 'fulfilled');
  const failed = results.filter(r => r.status === 'rejected');

  console.log(`Success: ${successful.length}, Failed: ${failed.length}`);

  return {
    successful: successful.map(r => r.value),
    failed: failed.map((r, i) => ({
      index: i,
      error: r.reason.message
    }))
  };
};

// Test
const items = [
  { id: 1, value: 10 },
  { id: 2, value: -5 },  // Will fail
  { id: 3, value: 20 },
  { id: 4, value: 30 }
];

processItemsInParallel(items)
  .then(results => console.log('Results:', results));
```

### Example 3: Retry with Exponential Backoff

```javascript
/**
 * Worked Example 3: Robust retry logic
 *
 * Demonstrates:
 * - Retry patterns
 * - Exponential backoff
 * - Error handling
 */

const wait = ms => new Promise(resolve => setTimeout(resolve, ms));

const retryWithBackoff = async (
  fn,
  maxRetries = 3,
  baseDelay = 1000
) => {
  let lastError;

  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      console.log(`Attempt ${attempt + 1}/${maxRetries + 1}`);
      const result = await fn();
      console.log('Success!');
      return result;
    } catch (error) {
      lastError = error;
      console.error(`Attempt ${attempt + 1} failed:`, error.message);

      if (attempt < maxRetries) {
        const delay = baseDelay * Math.pow(2, attempt);
        console.log(`Waiting ${delay}ms before retry...`);
        await wait(delay);
      }
    }
  }

  throw new Error(`Failed after ${maxRetries + 1} attempts: ${lastError.message}`);
};

// Flaky operation for testing
let attempts = 0;
const flakyOperation = async () => {
  attempts++;
  await delay(100);

  if (attempts < 3) {
    throw new Error('Temporary failure');
  }

  return 'Success!';
};

// Test
retryWithBackoff(flakyOperation, 5, 500)
  .then(result => console.log('Final result:', result))
  .catch(error => console.error('All attempts failed:', error.message));
```

---

## Exercises

### Exercise 1: Convert Promise Chain (Easy)

**Problem:** Convert this Promise chain to async/await.

```javascript
// Original Promise chain
function getUser Data(userId) {
  return fetchUser(userId)
    .then(user => fetchOrders(user.id))
    .then(orders => processOrders(orders))
    .catch(error => console.error(error));
}

// Convert to async/await
async function getUserDataAsync(userId) {
  // Your code here
}
```

**Solution:** See `solutions/exercise1_async_await.js`

---

### Exercise 2: Parallel Fetching (Medium)

**Problem:** Fetch multiple users in parallel and return their data.

```javascript
async function fetchMultipleUsersOptimized(userIds) {
  // Your code here
  // Use Promise.all() with async/await
}
```

**Solution:** See `solutions/exercise2_async_await.js`

---

### Exercise 3: Error Recovery (Medium)

**Problem:** Implement retry logic with async/await.

```javascript
async function retryOperation(fn, maxRetries) {
  // Your code here
}
```

**Solution:** See `solutions/exercise3_async_await.js`

---

### Exercise 4: Sequential Processing (Medium)

**Problem:** Process an array of items sequentially with async/await.

```javascript
async function processSequentially(items, processFn) {
  // Your code here
}
```

**Solution:** See `solutions/exercise4_async_await.js`

---

### Exercise 5: Timeout Implementation (Hard)

**Problem:** Create a generic timeout wrapper for async functions.

```javascript
async function withTimeout(fn, timeoutMs) {
  // Your code here
}
```

**Solution:** See `solutions/exercise5_async_await.js`

---

## Testing & Verification

```javascript
import { describe, it, expect } from 'vitest';

describe('Async/await functions', () => {
  it('should handle async operations', async () => {
    const result = await fetchData();
    expect(result).toBeDefined();
  });

  it('should handle errors', async () => {
    await expect(fetchInvalidData()).rejects.toThrow('Error');
  });

  it('should process in parallel', async () => {
    const start = Date.now();
    await processParallel();
    const elapsed = Date.now() - start;
    expect(elapsed).toBeLessThan(200);
  });
});
```

---

## Best Practices

1. **Always use try-catch in async functions**
2. **Prefer async/await over .then() chains**
3. **Use Promise.all() for parallel operations**
4. **Don't use await in loops unless necessary**
5. **Handle all promise rejections**

---

## Common Pitfalls

1. **Forgetting await keyword**
2. **Sequential execution when parallel is possible**
3. **Using await in array callbacks**
4. **Not handling errors**
5. **Mixing async/await and .then()**

---

## Performance Considerations

- Identify opportunities for parallel execution
- Avoid unnecessary sequential awaits
- Use Promise.all() for independent operations
- Implement timeouts for network requests

---

## Summary & Next Steps

### Key Takeaways

- Async/await provides clean syntax for async code
- Always use try-catch for error handling
- Combine with Promise.all() for parallelism
- Understand sequential vs parallel execution

### Related Topics

- [Event Loop Deep Dive](./25.Event_Loop_Deep_Dive.md)
- [Working with APIs](./26.Working_With_APIs.md)

### Further Reading

- [MDN: async function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function)
- [MDN: await](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await)

---

**Next Lesson:** [Event Loop Deep Dive](./25.Event_Loop_Deep_Dive.md)
