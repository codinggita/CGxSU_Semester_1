# Working with APIs in JavaScript

**Difficulty:** Intermediate to Advanced
**Estimated Time:** 70-90 minutes
**Prerequisites:** Promises, async/await, HTTP basics, error handling
**Target:** Node.js 18+ LTS, Modern Browsers (ES2021+)

---

## Learning Objectives

By the end of this lesson, you will be able to:

1. Master the Fetch API for HTTP requests
2. Implement all HTTP methods (GET, POST, PUT, PATCH, DELETE)
3. Work with headers and request options effectively
4. Handle JSON and other response types
5. Implement comprehensive error handling for network requests
6. Understand and work with CORS policies
7. Use AbortController for request cancellation
8. Implement retry logic with exponential backoff
9. Handle rate limiting and throttling
10. Integrate real APIs in production applications

---

## Table of Contents

1. [Introduction](#introduction)
2. [Fetch API Deep Dive](#fetch-api-deep-dive)
3. [HTTP Methods](#http-methods)
4. [Headers and Request Options](#headers-and-request-options)
5. [Handling Responses](#handling-responses)
6. [Error Handling](#error-handling)
7. [CORS Understanding](#cors-understanding)
8. [Request Cancellation](#request-cancellation)
9. [Retry Logic and Exponential Backoff](#retry-logic-and-exponential-backoff)
10. [Rate Limiting](#rate-limiting)
11. [Real API Examples](#real-api-examples)
12. [Worked Examples](#worked-examples)
13. [Exercises](#exercises)
14. [Testing & Verification](#testing--verification)
15. [Best Practices](#best-practices)
16. [Common Pitfalls](#common-pitfalls)
17. [Performance Considerations](#performance-considerations)
18. [Summary & Next Steps](#summary--next-steps)
19. [References](#references)

---

## Introduction

Working with APIs is fundamental to modern web development. The **Fetch API** provides a powerful, promise-based interface for making HTTP requests.

**Why API Integration Matters:**

- **Data Access:** Retrieve data from servers
- **CRUD Operations:** Create, Read, Update, Delete resources
- **Authentication:** User login and session management
- **Third-Party Services:** Integrate external services
- **Real-Time Updates:** Fetch latest data
- **Microservices:** Communicate between services

**Real-World Applications:**

- User authentication and authorization
- E-commerce product catalogs and checkout
- Social media feeds and interactions
- Weather data and maps integration
- Payment processing
- Analytics and tracking

---

## Fetch API Deep Dive

### Basic Fetch Syntax

```javascript
/**
 * Basic fetch request
 */

// Simple GET request
fetch('https://api.example.com/users')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));

// With async/await (preferred)
async function fetchUsers() {
  try {
    const response = await fetch('https://api.example.com/users');
    const data = await response.json();
    console.log(data);
    return data;
  } catch (error) {
    console.error('Error:', error);
    throw error;
  }
}
```

### Fetch Return Value

```javascript
/**
 * Understanding fetch response
 */

const response = await fetch('https://api.example.com/data');

console.log(response.ok);           // true if status 200-299
console.log(response.status);       // 200, 404, 500, etc.
console.log(response.statusText);   // "OK", "Not Found", etc.
console.log(response.headers);      // Headers object
console.log(response.url);          // Final URL (after redirects)
console.log(response.redirected);   // true if redirected
console.log(response.type);         // "basic", "cors", "opaque"

// Response body can only be read once!
const data = await response.json();
// const data2 = await response.json(); // Error: body already consumed
```

### Fetch vs XMLHttpRequest

```javascript
/**
 * Comparison: Modern fetch vs legacy XHR
 */

// OLD: XMLHttpRequest (avoid in new code)
const xhr = new XMLHttpRequest();
xhr.open('GET', 'https://api.example.com/data');
xhr.onload = function() {
  if (xhr.status === 200) {
    const data = JSON.parse(xhr.responseText);
    console.log(data);
  }
};
xhr.onerror = function() {
  console.error('Request failed');
};
xhr.send();

// NEW: Fetch API (use this!)
async function fetchData() {
  const response = await fetch('https://api.example.com/data');
  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }
  const data = await response.json();
  return data;
}
```

---

## HTTP Methods

### GET - Retrieve Data

```javascript
/**
 * GET request - fetch data from server
 */

// Simple GET
async function getUser(userId) {
  const response = await fetch(`https://api.example.com/users/${userId}`);

  if (!response.ok) {
    throw new Error(`Failed to fetch user: ${response.status}`);
  }

  return await response.json();
}

// GET with query parameters
async function searchUsers(query) {
  const params = new URLSearchParams({
    q: query,
    limit: 10,
    sort: 'name'
  });

  const url = `https://api.example.com/users/search?${params}`;
  const response = await fetch(url);

  return await response.json();
}

// Usage
const user = await getUser(123);
const results = await searchUsers('john');
```

### POST - Create Resource

```javascript
/**
 * POST request - create new resource
 */

async function createUser(userData) {
  const response = await fetch('https://api.example.com/users', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(userData)
  });

  if (!response.ok) {
    throw new Error(`Failed to create user: ${response.status}`);
  }

  return await response.json();
}

// Usage
const newUser = await createUser({
  name: 'Alice',
  email: 'alice@example.com',
  age: 30
});
```

### PUT - Replace Resource

```javascript
/**
 * PUT request - completely replace resource
 */

async function updateUser(userId, userData) {
  const response = await fetch(`https://api.example.com/users/${userId}`, {
    method: 'PUT',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(userData)
  });

  if (!response.ok) {
    throw new Error(`Failed to update user: ${response.status}`);
  }

  return await response.json();
}

// Usage - replaces entire user object
const updated = await updateUser(123, {
  name: 'Alice Updated',
  email: 'alice.new@example.com',
  age: 31
});
```

### PATCH - Partial Update

```javascript
/**
 * PATCH request - partially update resource
 */

async function patchUser(userId, updates) {
  const response = await fetch(`https://api.example.com/users/${userId}`, {
    method: 'PATCH',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(updates)
  });

  if (!response.ok) {
    throw new Error(`Failed to patch user: ${response.status}`);
  }

  return await response.json();
}

// Usage - updates only specified fields
const patched = await patchUser(123, {
  email: 'newemail@example.com'  // Only update email
});
```

### DELETE - Remove Resource

```javascript
/**
 * DELETE request - remove resource
 */

async function deleteUser(userId) {
  const response = await fetch(`https://api.example.com/users/${userId}`, {
    method: 'DELETE'
  });

  if (!response.ok) {
    throw new Error(`Failed to delete user: ${response.status}`);
  }

  // DELETE often returns 204 No Content (no body)
  if (response.status === 204) {
    return { success: true };
  }

  return await response.json();
}

// Usage
await deleteUser(123);
```

---

## Headers and Request Options

### Common Headers

```javascript
/**
 * Working with request headers
 */

async function fetchWithHeaders() {
  const response = await fetch('https://api.example.com/data', {
    method: 'GET',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': 'Bearer your-token-here',
      'Accept': 'application/json',
      'User-Agent': 'MyApp/1.0',
      'X-Custom-Header': 'custom-value'
    }
  });

  return await response.json();
}

// Headers object (alternative)
const headers = new Headers();
headers.append('Content-Type', 'application/json');
headers.append('Authorization', 'Bearer token');

const response = await fetch(url, { headers });
```

### Request Options

```javascript
/**
 * All fetch options
 */

const response = await fetch('https://api.example.com/data', {
  method: 'POST',           // HTTP method
  headers: {},              // Request headers
  body: JSON.stringify({}), // Request body (not for GET)
  mode: 'cors',             // cors, no-cors, same-origin
  credentials: 'include',   // include, same-origin, omit
  cache: 'default',         // default, no-cache, reload, force-cache
  redirect: 'follow',       // follow, error, manual
  referrer: 'client',       // URL or no-referrer
  referrerPolicy: 'no-referrer',
  integrity: '',            // Subresource integrity
  keepalive: false,         // Keep connection alive
  signal: null              // AbortSignal for cancellation
});
```

### Authentication Headers

```javascript
/**
 * Common authentication patterns
 */

// Bearer token (JWT)
async function fetchWithBearerToken(token) {
  const response = await fetch('https://api.example.com/protected', {
    headers: {
      'Authorization': `Bearer ${token}`
    }
  });

  return await response.json();
}

// Basic authentication
async function fetchWithBasicAuth(username, password) {
  const credentials = btoa(`${username}:${password}`);

  const response = await fetch('https://api.example.com/protected', {
    headers: {
      'Authorization': `Basic ${credentials}`
    }
  });

  return await response.json();
}

// API key
async function fetchWithApiKey(apiKey) {
  const response = await fetch('https://api.example.com/data', {
    headers: {
      'X-API-Key': apiKey
    }
  });

  return await response.json();
}
```

---

## Handling Responses

### JSON Responses

```javascript
/**
 * Handling JSON data
 */

async function fetchJSON(url) {
  const response = await fetch(url);

  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }

  // Check content type
  const contentType = response.headers.get('content-type');
  if (!contentType || !contentType.includes('application/json')) {
    throw new TypeError("Response was not JSON");
  }

  return await response.json();
}

// Usage
try {
  const data = await fetchJSON('https://api.example.com/users');
  console.log(data);
} catch (error) {
  console.error('Failed to fetch:', error);
}
```

### Text Responses

```javascript
/**
 * Handling text/HTML responses
 */

async function fetchHTML(url) {
  const response = await fetch(url);

  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }

  const html = await response.text();
  return html;
}

// CSV or plain text
async function fetchCSV(url) {
  const response = await fetch(url);
  const csv = await response.text();

  // Parse CSV
  const rows = csv.split('\n').map(row => row.split(','));
  return rows;
}
```

### Binary Responses

```javascript
/**
 * Handling binary data (images, files)
 */

// Blob for images, PDFs, etc.
async function fetchImage(url) {
  const response = await fetch(url);
  const blob = await response.blob();

  // Create object URL
  const objectURL = URL.createObjectURL(blob);
  return objectURL;
}

// ArrayBuffer for raw binary
async function fetchBinary(url) {
  const response = await fetch(url);
  const buffer = await response.arrayBuffer();
  return buffer;
}

// Usage: Display image
const imageUrl = await fetchImage('https://example.com/image.jpg');
document.getElementById('img').src = imageUrl;
```

### Stream Responses

```javascript
/**
 * Streaming large responses
 */

async function streamResponse(url) {
  const response = await fetch(url);
  const reader = response.body.getReader();

  while (true) {
    const { done, value } = await reader.read();

    if (done) break;

    console.log(`Received ${value.length} bytes`);
    // Process chunk
  }
}

// Read response incrementally
async function readStreamAsText(url) {
  const response = await fetch(url);
  const reader = response.body.getReader();
  const decoder = new TextDecoder();

  let result = '';

  while (true) {
    const { done, value } = await reader.read();

    if (done) break;

    result += decoder.decode(value, { stream: true });
  }

  return result;
}
```

---

## Error Handling

### Network Errors vs HTTP Errors

```javascript
/**
 * Comprehensive error handling
 */

async function fetchWithErrorHandling(url) {
  try {
    const response = await fetch(url);

    // fetch() only rejects on network errors, not HTTP errors!
    if (!response.ok) {
      // Create error for HTTP errors
      const error = new Error(`HTTP error! status: ${response.status}`);
      error.response = response;
      throw error;
    }

    return await response.json();
  } catch (error) {
    if (error.name === 'TypeError') {
      // Network error (no connection, DNS failure, etc.)
      console.error('Network error:', error.message);
      throw new Error('Network request failed. Please check your connection.');
    } else if (error.response) {
      // HTTP error (4xx, 5xx)
      const status = error.response.status;

      if (status === 404) {
        throw new Error('Resource not found');
      } else if (status === 401) {
        throw new Error('Unauthorized. Please log in.');
      } else if (status === 403) {
        throw new Error('Forbidden. You do not have access.');
      } else if (status >= 500) {
        throw new Error('Server error. Please try again later.');
      } else {
        throw error;
      }
    } else {
      throw error;
    }
  }
}
```

### Custom Error Classes

```javascript
/**
 * Specialized error types for better handling
 */

class NetworkError extends Error {
  constructor(message) {
    super(message);
    this.name = 'NetworkError';
  }
}

class HTTPError extends Error {
  constructor(response) {
    super(`HTTP Error ${response.status}`);
    this.name = 'HTTPError';
    this.response = response;
    this.status = response.status;
  }
}

class TimeoutError extends Error {
  constructor(message) {
    super(message);
    this.name = 'TimeoutError';
  }
}

async function fetchWithCustomErrors(url) {
  try {
    const response = await fetch(url);

    if (!response.ok) {
      throw new HTTPError(response);
    }

    return await response.json();
  } catch (error) {
    if (error.name === 'TypeError') {
      throw new NetworkError('Network request failed');
    }
    throw error;
  }
}

// Usage with specific error handling
try {
  const data = await fetchWithCustomErrors(url);
} catch (error) {
  if (error instanceof NetworkError) {
    showNetworkErrorUI();
  } else if (error instanceof HTTPError) {
    if (error.status === 401) {
      redirectToLogin();
    }
  } else if (error instanceof TimeoutError) {
    retryRequest();
  }
}
```

---

## CORS Understanding

### What is CORS?

```javascript
/**
 * Cross-Origin Resource Sharing (CORS)
 *
 * Browser security feature that restricts cross-origin HTTP requests
 */

// Same origin: OK
fetch('https://example.com/api/data');  // OK

// Different origin: Requires CORS headers from server
fetch('https://different-domain.com/api/data');  // May fail without CORS

// Server must respond with:
// Access-Control-Allow-Origin: *
// or
// Access-Control-Allow-Origin: https://your-domain.com
```

### CORS Modes

```javascript
/**
 * Fetch modes for CORS
 */

// 'cors' - default, follows CORS protocol
fetch(url, { mode: 'cors' });

// 'no-cors' - limited access to response
fetch(url, { mode: 'no-cors' })
  .then(response => {
    // Can't read response body!
    // Useful for caching, side effects
  });

// 'same-origin' - only allow same-origin requests
fetch(url, { mode: 'same-origin' });
```

### Credentials and CORS

```javascript
/**
 * Sending credentials (cookies, auth) with CORS
 */

// Include credentials in cross-origin requests
fetch('https://api.example.com/data', {
  credentials: 'include'  // Sends cookies
});

// Server must respond with:
// Access-Control-Allow-Credentials: true
// Access-Control-Allow-Origin: https://your-domain.com (not *)

// Other credential options:
// 'omit' - never send credentials
// 'same-origin' - only for same-origin requests
```

---

## Request Cancellation

### AbortController

```javascript
/**
 * Cancel fetch requests with AbortController
 */

const controller = new AbortController();
const signal = controller.signal;

// Start fetch with signal
fetch('https://api.example.com/large-file', { signal })
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => {
    if (error.name === 'AbortError') {
      console.log('Fetch aborted');
    } else {
      console.error('Fetch error:', error);
    }
  });

// Cancel the request
setTimeout(() => {
  controller.abort();
  console.log('Request cancelled');
}, 1000);
```

### Timeout Implementation

```javascript
/**
 * Implement fetch timeout with AbortController
 */

async function fetchWithTimeout(url, timeout = 5000) {
  const controller = new AbortController();
  const id = setTimeout(() => controller.abort(), timeout);

  try {
    const response = await fetch(url, {
      signal: controller.signal
    });

    clearTimeout(id);
    return await response.json();
  } catch (error) {
    clearTimeout(id);

    if (error.name === 'AbortError') {
      throw new Error('Request timeout');
    }

    throw error;
  }
}

// Usage
try {
  const data = await fetchWithTimeout('https://api.example.com/slow', 3000);
} catch (error) {
  console.error('Timeout or error:', error.message);
}
```

### Cancellable Requests Class

```javascript
/**
 * Reusable cancellable request class
 */

class CancellableRequest {
  constructor() {
    this.controller = null;
  }

  async fetch(url, options = {}) {
    // Cancel previous request if exists
    if (this.controller) {
      this.controller.abort();
    }

    this.controller = new AbortController();

    try {
      const response = await fetch(url, {
        ...options,
        signal: this.controller.signal
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      return await response.json();
    } catch (error) {
      if (error.name === 'AbortError') {
        console.log('Request cancelled');
        return null;
      }
      throw error;
    }
  }

  cancel() {
    if (this.controller) {
      this.controller.abort();
      this.controller = null;
    }
  }
}

// Usage
const request = new CancellableRequest();

request.fetch('https://api.example.com/search?q=first');

// User types more, cancel previous request
request.fetch('https://api.example.com/search?q=second');
```

---

## Retry Logic and Exponential Backoff

### Simple Retry

```javascript
/**
 * Basic retry logic
 */

async function fetchWithRetry(url, maxRetries = 3) {
  for (let i = 0; i <= maxRetries; i++) {
    try {
      const response = await fetch(url);

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      return await response.json();
    } catch (error) {
      if (i === maxRetries) {
        throw new Error(`Failed after ${maxRetries} retries: ${error.message}`);
      }

      console.log(`Retry ${i + 1}/${maxRetries}...`);
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }
}
```

### Exponential Backoff

```javascript
/**
 * Retry with exponential backoff
 */

async function fetchWithExponentialBackoff(
  url,
  maxRetries = 5,
  baseDelay = 1000
) {
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      const response = await fetch(url);

      if (!response.ok) {
        // Only retry on 5xx errors
        if (response.status >= 500 && attempt < maxRetries) {
          throw new Error('Server error, retrying...');
        }

        throw new Error(`HTTP error! status: ${response.status}`);
      }

      return await response.json();
    } catch (error) {
      if (attempt === maxRetries) {
        throw error;
      }

      // Exponential backoff: 1s, 2s, 4s, 8s, 16s
      const delay = baseDelay * Math.pow(2, attempt);

      // Add jitter to prevent thundering herd
      const jitter = Math.random() * 1000;

      console.log(`Retry ${attempt + 1}/${maxRetries} in ${delay + jitter}ms`);

      await new Promise(resolve => setTimeout(resolve, delay + jitter));
    }
  }
}
```

### Conditional Retry

```javascript
/**
 * Retry only for specific errors
 */

async function fetchWithConditionalRetry(url, maxRetries = 3) {
  const retryableStatuses = [408, 429, 500, 502, 503, 504];

  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      const response = await fetch(url);

      if (!response.ok) {
        if (retryableStatuses.includes(response.status) && attempt < maxRetries) {
          const retryAfter = response.headers.get('Retry-After');
          const delay = retryAfter ? parseInt(retryAfter) * 1000 : 1000 * Math.pow(2, attempt);

          console.log(`Status ${response.status}, retrying after ${delay}ms`);
          await new Promise(resolve => setTimeout(resolve, delay));
          continue;
        }

        throw new Error(`HTTP error! status: ${response.status}`);
      }

      return await response.json();
    } catch (error) {
      if (attempt === maxRetries) {
        throw error;
      }
    }
  }
}
```

---

## Rate Limiting

### Client-Side Rate Limiting

```javascript
/**
 * Rate limiter using token bucket algorithm
 */

class RateLimiter {
  constructor(maxRequests, perMilliseconds) {
    this.maxRequests = maxRequests;
    this.perMilliseconds = perMilliseconds;
    this.tokens = maxRequests;
    this.lastRefill = Date.now();
  }

  async acquire() {
    this.refill();

    if (this.tokens > 0) {
      this.tokens--;
      return Promise.resolve();
    }

    // Wait until next refill
    const waitTime = this.perMilliseconds - (Date.now() - this.lastRefill);
    await new Promise(resolve => setTimeout(resolve, waitTime));

    return this.acquire();
  }

  refill() {
    const now = Date.now();
    const timePassed = now - this.lastRefill;

    if (timePassed >= this.perMilliseconds) {
      this.tokens = this.maxRequests;
      this.lastRefill = now;
    }
  }
}

// Usage: Max 5 requests per second
const limiter = new RateLimiter(5, 1000);

async function rateLimitedFetch(url) {
  await limiter.acquire();
  return fetch(url);
}

// All requests automatically rate-limited
const promises = Array.from({ length: 20 }, (_, i) => {
  return rateLimitedFetch(`https://api.example.com/item/${i}`);
});

const results = await Promise.all(promises);
```

### Request Queue with Concurrency Limit

```javascript
/**
 * Process requests with max concurrency
 */

class RequestQueue {
  constructor(concurrency = 3) {
    this.concurrency = concurrency;
    this.running = 0;
    this.queue = [];
  }

  async enqueue(url, options) {
    return new Promise((resolve, reject) => {
      this.queue.push({ url, options, resolve, reject });
      this.process();
    });
  }

  async process() {
    if (this.running >= this.concurrency || this.queue.length === 0) {
      return;
    }

    this.running++;
    const { url, options, resolve, reject } = this.queue.shift();

    try {
      const response = await fetch(url, options);
      const data = await response.json();
      resolve(data);
    } catch (error) {
      reject(error);
    } finally {
      this.running--;
      this.process();
    }
  }
}

// Usage: Max 3 concurrent requests
const queue = new RequestQueue(3);

const urls = Array.from({ length: 10 }, (_, i) => {
  return `https://jsonplaceholder.typicode.com/users/${i + 1}`;
});

const results = await Promise.all(
  urls.map(url => queue.enqueue(url))
);
```

---

## Real API Examples

### JSONPlaceholder API

```javascript
/**
 * Working with JSONPlaceholder (free test API)
 */

const API_BASE = 'https://jsonplaceholder.typicode.com';

// Get all posts
async function getAllPosts() {
  const response = await fetch(`${API_BASE}/posts`);
  return await response.json();
}

// Get single post
async function getPost(id) {
  const response = await fetch(`${API_BASE}/posts/${id}`);

  if (!response.ok) {
    throw new Error('Post not found');
  }

  return await response.json();
}

// Create post
async function createPost(post) {
  const response = await fetch(`${API_BASE}/posts`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(post)
  });

  return await response.json();
}

// Update post
async function updatePost(id, updates) {
  const response = await fetch(`${API_BASE}/posts/${id}`, {
    method: 'PATCH',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(updates)
  });

  return await response.json();
}

// Delete post
async function deletePost(id) {
  const response = await fetch(`${API_BASE}/posts/${id}`, {
    method: 'DELETE'
  });

  return response.ok;
}

// Usage
const posts = await getAllPosts();
const post = await getPost(1);
const newPost = await createPost({ title: 'Test', body: 'Content', userId: 1 });
await updatePost(1, { title: 'Updated' });
await deletePost(1);
```

### GitHub API

```javascript
/**
 * GitHub API integration
 */

const GITHUB_API = 'https://api.github.com';

async function getGitHubUser(username) {
  const response = await fetch(`${GITHUB_API}/users/${username}`, {
    headers: {
      'Accept': 'application/vnd.github.v3+json'
    }
  });

  if (!response.ok) {
    throw new Error(`User ${username} not found`);
  }

  return await response.json();
}

async function getUserRepos(username) {
  const response = await fetch(`${GITHUB_API}/users/${username}/repos?sort=updated`, {
    headers: {
      'Accept': 'application/vnd.github.v3+json'
    }
  });

  return await response.json();
}

// With authentication
async function getAuthenticatedUser(token) {
  const response = await fetch(`${GITHUB_API}/user`, {
    headers: {
      'Authorization': `token ${token}`,
      'Accept': 'application/vnd.github.v3+json'
    }
  });

  return await response.json();
}
```

---

## Worked Examples

### Example 1: Complete API Client

```javascript
/**
 * Worked Example 1: Robust API client class
 */

class APIClient {
  constructor(baseURL, options = {}) {
    this.baseURL = baseURL;
    this.defaultHeaders = options.headers || {};
    this.timeout = options.timeout || 10000;
  }

  async request(endpoint, options = {}) {
    const url = `${this.baseURL}${endpoint}`;

    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), this.timeout);

    try {
      const response = await fetch(url, {
        ...options,
        headers: {
          ...this.defaultHeaders,
          ...options.headers
        },
        signal: controller.signal
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        const error = await this.parseError(response);
        throw error;
      }

      return await response.json();
    } catch (error) {
      clearTimeout(timeoutId);

      if (error.name === 'AbortError') {
        throw new Error('Request timeout');
      }

      throw error;
    }
  }

  async parseError(response) {
    try {
      const body = await response.json();
      return new Error(body.message || `HTTP error ${response.status}`);
    } catch {
      return new Error(`HTTP error ${response.status}`);
    }
  }

  async get(endpoint, params) {
    const queryString = params ? `?${new URLSearchParams(params)}` : '';
    return this.request(`${endpoint}${queryString}`);
  }

  async post(endpoint, data) {
    return this.request(endpoint, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    });
  }

  async put(endpoint, data) {
    return this.request(endpoint, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    });
  }

  async patch(endpoint, data) {
    return this.request(endpoint, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    });
  }

  async delete(endpoint) {
    return this.request(endpoint, { method: 'DELETE' });
  }
}

// Usage
const api = new APIClient('https://api.example.com', {
  headers: { 'Authorization': 'Bearer token' },
  timeout: 5000
});

const user = await api.get('/users/123');
const newPost = await api.post('/posts', { title: 'Test' });
```

---

## Exercises

### Exercise 1: Basic Fetch (Easy)

Fetch user data from JSONPlaceholder API.

**Solution:** See `solutions/exercise1_api.js`

### Exercise 2: POST Request (Medium)

Create a function that posts data to an API.

**Solution:** See `solutions/exercise2_api.js`

### Exercise 3: Error Handling (Medium)

Implement comprehensive error handling for fetch.

**Solution:** See `solutions/exercise3_api.js`

### Exercise 4: Retry Logic (Hard)

Implement fetch with exponential backoff.

**Solution:** See `solutions/exercise4_api.js`

### Exercise 5: Rate Limiter (Hard)

Build a rate limiter for API requests.

**Solution:** See `solutions/exercise5_api.js`

---

## Best Practices

1. Always check response.ok before parsing
2. Use async/await over .then() chains
3. Implement proper error handling
4. Add timeouts to prevent hanging
5. Use AbortController for cancellation
6. Respect rate limits
7. Cache responses when appropriate

---

## Common Pitfalls

1. Not checking response.ok
2. Ignoring CORS errors
3. Not handling network failures
4. Reading response body twice
5. Not setting Content-Type headers
6. Blocking UI with synchronous operations

---

## Performance Considerations

- Use connection pooling in Node.js
- Implement request caching
- Compress request/response bodies
- Use HTTP/2 when available
- Monitor API response times

---

## Summary & Next Steps

Master API integration for real-world applications.

**Next:** [Async Patterns and Best Practices](./27.Async_Patterns_And_Best_Practices.md)

