# Event Loop Deep Dive in JavaScript

**Difficulty:** Advanced
**Estimated Time:** 60-80 minutes
**Prerequisites:** Callbacks, Promises, async/await, async fundamentals
**Target:** Node.js 18+ LTS, Modern Browsers (ES2021+)

---

## Learning Objectives

By the end of this lesson, you will be able to:

1. Understand JavaScript runtime architecture in detail
2. Explain the call stack and its role in execution
3. Identify Web APIs and Node.js APIs
4. Distinguish between the callback queue and microtask queue
5. Explain the event loop algorithm step by step
6. Differentiate between macro tasks and micro tasks
7. Predict execution order of complex async code
8. Understand setTimeout(0) behavior and use cases
9. Create visualizations and timeline diagrams of code execution
10. Optimize code based on event loop understanding

---

## Table of Contents

1. [Introduction](#introduction)
2. [JavaScript Runtime Architecture](#javascript-runtime-architecture)
3. [The Call Stack](#the-call-stack)
4. [Web APIs and Node APIs](#web-apis-and-node-apis)
5. [Task Queue (Callback Queue)](#task-queue-callback-queue)
6. [Microtask Queue](#microtask-queue)
7. [The Event Loop Algorithm](#the-event-loop-algorithm)
8. [Macro Tasks vs Micro Tasks](#macro-tasks-vs-micro-tasks)
9. [SetTimeout(0) Behavior](#settimeout0-behavior)
10. [Execution Timeline Examples](#execution-timeline-examples)
11. [Worked Examples](#worked-examples)
12. [Exercises](#exercises)
13. [Testing & Verification](#testing--verification)
14. [Best Practices](#best-practices)
15. [Common Pitfalls](#common-pitfalls)
16. [Performance Implications](#performance-implications)
17. [Summary & Next Steps](#summary--next-steps)
18. [References](#references)

---

## Introduction

The **Event Loop** is the heart of JavaScript's asynchronous programming model. Understanding it deeply is crucial for writing efficient, non-blocking code and debugging complex async issues.

**Why Event Loop Mastery Matters:**

- **Performance:** Avoid blocking the main thread
- **Debugging:** Predict execution order
- **Optimization:** Write efficient async code
- **Interviews:** Common advanced interview topic
- **Architecture:** Design scalable applications

**Real-World Impact:**

- Responsive UIs that don't freeze
- High-throughput servers in Node.js
- Smooth animations and interactions
- Efficient resource utilization
- Better user experience

---

## JavaScript Runtime Architecture

### Complete Runtime Diagram

```
┌─────────────────────────────────────────────────────────────┐
│                   JAVASCRIPT RUNTIME                        │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌────────────────────┐      ┌──────────────────────────┐ │
│  │    HEAP            │      │      CALL STACK          │ │
│  │  (Memory)          │      │  ┌─────────────────┐    │ │
│  │                    │      │  │ main()          │    │ │
│  │  Objects, closures │      │  ├─────────────────┤    │ │
│  │  Variables, etc.   │      │  │ foo()           │    │ │
│  │                    │      │  ├─────────────────┤    │ │
│  └────────────────────┘      │  │ bar()           │    │ │
│                              │  └─────────────────┘    │ │
│                              └──────────────────────────┘ │
│                                                             │
│  ┌───────────────────────────────────────────────────────┐ │
│  │             WEB APIs / NODE APIs                      │ │
│  │  • setTimeout/setInterval                             │ │
│  │  • fetch / XMLHttpRequest                             │ │
│  │  • DOM Events (click, scroll, etc.)                   │ │
│  │  • File I/O (Node.js)                                 │ │
│  │  • Network I/O                                        │ │
│  └───────────────────────────────────────────────────────┘ │
│                              │                              │
│                              ▼                              │
│  ┌───────────────────────────────────────────────────────┐ │
│  │             MICROTASK QUEUE                           │ │
│  │  [Promise.then] [queueMicrotask] [process.nextTick]  │ │
│  └───────────────────────────────────────────────────────┘ │
│                              │                              │
│                              ▼                              │
│  ┌───────────────────────────────────────────────────────┐ │
│  │      TASK QUEUE (Callback/Macro Task Queue)          │ │
│  │  [setTimeout] [setInterval] [setImmediate] [I/O]     │ │
│  └───────────────────────────────────────────────────────┘ │
│                              │                              │
│                  ◄───────────┘                              │
│                  EVENT LOOP                                 │
│         "Is stack empty? Process queues"                    │
└─────────────────────────────────────────────────────────────┘
```

### Key Components

1. **Heap:** Memory allocation for objects
2. **Call Stack:** Tracks function execution
3. **Web/Node APIs:** Handle async operations
4. **Microtask Queue:** High-priority async tasks
5. **Task Queue:** Standard async tasks
6. **Event Loop:** Coordinates everything

---

## The Call Stack

The call stack is a LIFO (Last In, First Out) data structure that tracks function calls.

### Call Stack Basics

```javascript
/**
 * Call stack demonstration
 */

function first() {
  console.log('First function');
  second();
  console.log('First function end');
}

function second() {
  console.log('Second function');
  third();
  console.log('Second function end');
}

function third() {
  console.log('Third function');
}

first();

/*
Call Stack Timeline:

1. [main]
2. [main, first]
3. [main, first] → logs "First function"
4. [main, first, second]
5. [main, first, second] → logs "Second function"
6. [main, first, second, third]
7. [main, first, second, third] → logs "Third function"
8. [main, first, second]
9. [main, first, second] → logs "Second function end"
10. [main, first]
11. [main, first] → logs "First function end"
12. [main]
13. []

Output:
First function
Second function
Third function
Second function end
First function end
*/
```

### Stack Overflow

```javascript
/**
 * Stack overflow demonstration
 */

function recursiveFunction() {
  recursiveFunction();  // Infinite recursion
}

// recursiveFunction();  // Uncaught RangeError: Maximum call stack size exceeded

// Safe recursion with base case
function safeRecursion(n) {
  if (n <= 0) return;  // Base case prevents stack overflow
  console.log(n);
  safeRecursion(n - 1);
}

safeRecursion(5);  // Works fine
```

### Visualizing the Stack

```javascript
/**
 * Stack visualization with console
 */

function trackStack(name) {
  console.log(`Entering: ${name}`);
  console.trace();  // Shows current stack
  console.log(`Exiting: ${name}`);
}

function a() {
  trackStack('a');
  b();
}

function b() {
  trackStack('b');
  c();
}

function c() {
  trackStack('c');
}

a();
```

---

## Web APIs and Node APIs

Async operations are delegated to Web APIs (browser) or Node APIs (Node.js).

### Browser Web APIs

```javascript
/**
 * Browser Web APIs
 */

// setTimeout/setInterval
setTimeout(() => console.log('Timer'), 1000);

// DOM Events
if (typeof document !== 'undefined') {
  document.getElementById('btn')?.addEventListener('click', () => {
    console.log('Clicked');
  });
}

// Fetch API
if (typeof fetch !== 'undefined') {
  fetch('https://api.example.com/data')
    .then(response => response.json())
    .then(data => console.log(data));
}

// IndexedDB
// WebRTC
// WebSockets
// Geolocation API
```

### Node.js APIs

```javascript
/**
 * Node.js APIs
 */

import fs from 'fs';
import http from 'http';

// File System
fs.readFile('file.txt', 'utf8', (err, data) => {
  if (err) console.error(err);
  else console.log(data);
});

// Networking
const server = http.createServer((req, res) => {
  res.end('Hello');
});

// Timers
setImmediate(() => console.log('Immediate'));
process.nextTick(() => console.log('Next tick'));

// Streams
// Child processes
// Crypto
```

---

## Task Queue (Callback Queue)

The task queue holds callbacks from completed async operations.

### Task Queue Operations

```javascript
/**
 * Task queue demonstration
 */

console.log('Start');

setTimeout(() => {
  console.log('Timeout 1');
}, 0);

setTimeout(() => {
  console.log('Timeout 2');
}, 0);

console.log('End');

/*
Execution:
1. "Start" (synchronous, call stack)
2. setTimeout registered (Web API)
3. setTimeout registered (Web API)
4. "End" (synchronous, call stack)
5. Stack empty, event loop checks queues
6. "Timeout 1" (from task queue)
7. "Timeout 2" (from task queue)

Output:
Start
End
Timeout 1
Timeout 2
*/
```

### Task Queue Sources

```javascript
/**
 * What goes into the task queue?
 */

// setTimeout/setInterval
setTimeout(() => console.log('setTimeout'), 0);
setInterval(() => console.log('setInterval'), 1000);

// setImmediate (Node.js)
if (typeof setImmediate !== 'undefined') {
  setImmediate(() => console.log('setImmediate'));
}

// I/O operations
import fs from 'fs';
fs.readFile('file.txt', () => console.log('File read'));

// UI rendering (browser)
// requestAnimationFrame (browser)
```

---

## Microtask Queue

Microtasks have higher priority than regular tasks.

### Microtask Sources

```javascript
/**
 * What creates microtasks?
 */

// Promise callbacks
Promise.resolve().then(() => console.log('Promise 1'));

// queueMicrotask
queueMicrotask(() => console.log('Microtask'));

// process.nextTick (Node.js - even higher priority!)
if (typeof process !== 'undefined') {
  process.nextTick(() => console.log('Next tick'));
}

// MutationObserver (browser)
// async/await resolution points
```

### Microtask vs Task Priority

```javascript
/**
 * Microtasks run before tasks
 */

console.log('1: Script start');

setTimeout(() => {
  console.log('4: setTimeout');
}, 0);

Promise.resolve().then(() => {
  console.log('3: Promise');
});

console.log('2: Script end');

/*
Output:
1: Script start
2: Script end
3: Promise        ← Microtask runs first
4: setTimeout     ← Task runs second

Why?
1. All synchronous code runs first
2. Call stack empties
3. Event loop processes ALL microtasks
4. Then processes ONE task
5. Repeat from step 3
*/
```

---

## The Event Loop Algorithm

Step-by-step breakdown of how the event loop works.

### Event Loop Steps

```
1. Execute all synchronous code (until call stack is empty)
2. Process ALL microtasks:
   a. Process all process.nextTick callbacks (Node.js only)
   b. Process all other microtasks (Promises, queueMicrotask)
   c. Repeat until microtask queue is empty
3. Render UI (browser only, if needed)
4. Process ONE macro task from task queue
5. Go to step 2 (check microtasks again)
6. Repeat indefinitely
```

### Detailed Algorithm

```javascript
/**
 * Event loop pseudocode
 */

while (eventLoop.waitForTask()) {
  const task = eventLoop.getNextTask();

  // Execute task (call stack)
  execute(task);

  // Process ALL microtasks
  while (microtaskQueue.hasTasks()) {
    const microtask = microtaskQueue.getNext();
    execute(microtask);

    // Important: New microtasks added during processing
    // are also executed in this phase
  }

  // Render (browser)
  if (shouldRender()) {
    render();
  }
}
```

### Example with Detailed Trace

```javascript
/**
 * Complete execution trace
 */

console.log('1');

setTimeout(() => console.log('2'), 0);

Promise.resolve()
  .then(() => console.log('3'))
  .then(() => console.log('4'));

setTimeout(() => console.log('5'), 0);

Promise.resolve().then(() => console.log('6'));

console.log('7');

/*
Detailed trace:

SYNCHRONOUS PHASE:
  Stack: [main]
  Output: "1"
  Action: Register setTimeout (Task Queue: [callback-2])

  Stack: [main]
  Action: Create Promise chain (registers microtasks)

  Stack: [main]
  Action: Register setTimeout (Task Queue: [callback-2, callback-5])

  Stack: [main]
  Action: Register Promise (Microtask Queue: [callback-3, callback-6])

  Stack: [main]
  Output: "7"

  Stack: [] (empty)

MICROTASK PHASE:
  Execute callback-3:
    Output: "3"
    Adds callback-4 to microtask queue

  Execute callback-6:
    Output: "6"

  Execute callback-4:
    Output: "4"

  Microtask queue empty

TASK PHASE:
  Execute callback-2:
    Output: "2"

  Check microtasks (none)

  Execute callback-5:
    Output: "5"

Final output:
1
7
3
6
4
2
5
*/
```

---

## Macro Tasks vs Micro Tasks

Understanding the difference is crucial for predicting execution order.

### Comparison Table

| Macro Tasks | Micro Tasks |
|-------------|-------------|
| setTimeout | Promise.then/catch/finally |
| setInterval | queueMicrotask |
| setImmediate (Node.js) | process.nextTick (Node.js) |
| I/O operations | MutationObserver (browser) |
| UI rendering | async function await points |
| requestAnimationFrame | - |

### Priority Demonstration

```javascript
/**
 * Priority: Microtasks > Macro tasks
 */

setTimeout(() => console.log('Macro 1'), 0);

Promise.resolve()
  .then(() => console.log('Micro 1'))
  .then(() => console.log('Micro 2'));

setTimeout(() => console.log('Macro 2'), 0);

queueMicrotask(() => console.log('Micro 3'));

/*
Output:
Micro 1
Micro 2
Micro 3
Macro 1
Macro 2

Microtasks ALWAYS run before next macro task
*/
```

### Nested Microtasks

```javascript
/**
 * Microtasks can create more microtasks
 */

Promise.resolve().then(() => {
  console.log('Promise 1');

  Promise.resolve().then(() => {
    console.log('Promise 2');

    Promise.resolve().then(() => {
      console.log('Promise 3');
    });
  });
});

setTimeout(() => console.log('Timeout'), 0);

/*
Output:
Promise 1
Promise 2
Promise 3
Timeout

All nested microtasks complete before any macro task
*/
```

---

## SetTimeout(0) Behavior

setTimeout(0) doesn't execute immediately.

### Minimum Delay

```javascript
/**
 * setTimeout(0) is NOT instant
 */

console.log('Start');

setTimeout(() => console.log('Timeout 0'), 0);

console.log('End');

/*
Output:
Start
End
Timeout 0

setTimeout(0) actually means:
"Add to task queue after synchronous code completes"

Minimum delay is typically 4ms in browsers (HTML5 spec)
*/
```

### Use Cases for setTimeout(0)

```javascript
/**
 * Why use setTimeout(0)?
 */

// 1. Break up long-running tasks
function processLargeArray(array) {
  const chunkSize = 100;
  let index = 0;

  function processChunk() {
    const end = Math.min(index + chunkSize, array.length);

    for (let i = index; i < end; i++) {
      // Process item
      array[i] = array[i] * 2;
    }

    index = end;

    if (index < array.length) {
      setTimeout(processChunk, 0);  // Let other code run
    }
  }

  processChunk();
}

// 2. Defer execution until after current call stack
function deferExecution() {
  console.log('1');

  setTimeout(() => console.log('3'), 0);

  console.log('2');
}

// 3. Ensure DOM updates before running code
if (typeof document !== 'undefined') {
  document.getElementById('btn').click();  // Triggers event

  setTimeout(() => {
    // This runs after event handlers
    console.log('After event handlers');
  }, 0);
}
```

---

## Execution Timeline Examples

Visual timelines help understand complex scenarios.

### Example 1: Mixed Async Operations

```javascript
/**
 * Complex execution order
 */

console.log('A');

setTimeout(() => {
  console.log('B');
  Promise.resolve().then(() => console.log('C'));
}, 0);

Promise.resolve()
  .then(() => {
    console.log('D');
    setTimeout(() => console.log('E'), 0);
  })
  .then(() => console.log('F'));

console.log('G');

/*
Timeline:

Time 0ms: SYNC
  Output: A
  Queue setTimeout B
  Queue Promise D
  Output: G
  Stack empty

Time 0ms: MICROTASKS
  Execute D (output: D)
    Queue setTimeout E
  Execute F (output: F)
  Microtask queue empty

Time 0ms: TASKS
  Execute B (output: B)
    Queue Promise C
  
Time 0ms: MICROTASKS (after task B)
  Execute C (output: C)

Time 0ms: TASKS
  Execute E (output: E)

Final Output:
A
G
D
F
B
C
E
*/
```

### Example 2: Async/Await Timeline

```javascript
/**
 * Async/await execution order
 */

async function async1() {
  console.log('async1 start');
  await async2();
  console.log('async1 end');
}

async function async2() {
  console.log('async2');
}

console.log('script start');

setTimeout(() => console.log('setTimeout'), 0);

async1();

new Promise(resolve => {
  console.log('promise1');
  resolve();
}).then(() => console.log('promise2'));

console.log('script end');

/*
Output:
script start
async1 start
async2
promise1
script end
async1 end  ← await creates microtask
promise2
setTimeout

Note: await creates a microtask for the code after it
*/
```

---

## Worked Examples

### Example 1: Event Loop Simulator

```javascript
/**
 * Worked Example 1: Build a simple event loop simulator
 */

class EventLoopSimulator {
  constructor() {
    this.callStack = [];
    this.macroQueue = [];
    this.microQueue = [];
    this.output = [];
  }

  log(message) {
    this.output.push(`[${this.callStack.length}] ${message}`);
  }

  executeSync(fn, name) {
    this.callStack.push(name);
    this.log(`Enter: ${name}`);
    fn();
    this.log(`Exit: ${name}`);
    this.callStack.pop();
  }

  setTimeout(fn, delay, name) {
    this.log(`Queue macro: ${name}`);
    this.macroQueue.push({ fn, name });
  }

  promise(fn, name) {
    this.log(`Queue micro: ${name}`);
    this.microQueue.push({ fn, name });
  }

  run() {
    // Process all microtasks
    while (this.microQueue.length > 0) {
      const { fn, name } = this.microQueue.shift();
      this.executeSync(fn, name);
    }

    // Process one macro task
    if (this.macroQueue.length > 0) {
      const { fn, name } = this.macroQueue.shift();
      this.executeSync(fn, name);
      this.run();  // Recursively process next round
    }
  }

  getOutput() {
    return this.output.join('\n');
  }
}

// Test
const sim = new EventLoopSimulator();

sim.executeSync(() => {
  sim.log('Synchronous 1');
  sim.setTimeout(() => sim.log('Timeout 1'), 0, 'timeout1');
  sim.promise(() => sim.log('Promise 1'), 'promise1');
  sim.log('Synchronous 2');
}, 'main');

sim.run();
console.log(sim.getOutput());
```

### Example 2: Render Loop

```javascript
/**
 * Worked Example 2: Animation with event loop awareness
 */

class RenderLoop {
  constructor() {
    this.tasks = [];
    this.rendering = false;
  }

  scheduleRender(callback) {
    this.tasks.push(callback);

    if (!this.rendering) {
      this.rendering = true;
      requestAnimationFrame(() => this.render());
    }
  }

  render() {
    // Process all scheduled tasks
    const currentTasks = [...this.tasks];
    this.tasks = [];

    currentTasks.forEach(task => {
      try {
        task();
      } catch (error) {
        console.error('Render error:', error);
      }
    });

    // Check if more tasks were added
    if (this.tasks.length > 0) {
      requestAnimationFrame(() => this.render());
    } else {
      this.rendering = false;
    }
  }
}

const renderLoop = new RenderLoop();

// Usage
renderLoop.scheduleRender(() => {
  console.log('Rendering frame 1');
});

renderLoop.scheduleRender(() => {
  console.log('Rendering frame 2');
});
```

---

## Exercises

### Exercise 1: Predict Output (Easy)

```javascript
console.log('1');

setTimeout(() => console.log('2'), 10);
setTimeout(() => console.log('3'), 0);

Promise.resolve().then(() => console.log('4'));

console.log('5');

// What is the output order?
```

**Solution:** See `solutions/exercise1_event_loop.js`

### Exercise 2: Complex Execution (Medium)

```javascript
async function foo() {
  console.log('A');
  await Promise.resolve();
  console.log('B');
}

setTimeout(() => console.log('C'), 0);
foo();
Promise.resolve().then(() => console.log('D'));
console.log('E');

// What is the output order?
```

**Solution:** See `solutions/exercise2_event_loop.js`

### Exercise 3: Build Task Queue (Medium)

Implement a simple task queue processor.

**Solution:** See `solutions/exercise3_event_loop.js`

### Exercise 4: Microtask Priority (Hard)

Implement process.nextTick behavior.

**Solution:** See `solutions/exercise4_event_loop.js`

---

## Testing & Verification

```javascript
import { describe, it, expect } from 'vitest';

describe('Event loop behavior', () => {
  it('should execute microtasks before tasks', done => {
    const order = [];

    setTimeout(() => {
      order.push('task');
      expect(order).toEqual(['micro', 'task']);
      done();
    }, 0);

    Promise.resolve().then(() => {
      order.push('micro');
    });
  });
});
```

---

## Best Practices

1. **Understand execution order**
2. **Don't block the event loop**
3. **Use microtasks for high-priority work**
4. **Break up long-running tasks**
5. **Monitor event loop lag in production**

---

## Common Pitfalls

1. **Blocking the event loop with synchronous code**
2. **Assuming setTimeout(0) is instant**
3. **Infinite microtask loops**
4. **Not understanding priority**
5. **Mixing sync and async patterns**

---

## Performance Implications

- Event loop lag causes UI freezing
- Long tasks block all async operations
- Microtask saturation can starve tasks
- Monitor with performance tools

---

## Summary & Next Steps

### Key Takeaways

- Event loop coordinates async execution
- Microtasks have higher priority than tasks
- Call stack must be empty before queue processing
- Understanding execution order aids debugging

### Related Topics

- [Working with APIs](./26.Working_With_APIs.md)
- [Async Patterns](./27.Async_Patterns_And_Best_Practices.md)

### Further Reading

- [Jake Archibald: Event Loop](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/)
- [Node.js Event Loop](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/)

---

**Next Lesson:** [Working with APIs](./26.Working_With_APIs.md)
