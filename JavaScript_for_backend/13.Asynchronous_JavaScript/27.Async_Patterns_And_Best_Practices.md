# Async Patterns and Best Practices in JavaScript

**Difficulty:** Advanced
**Estimated Time:** 80-100 minutes
**Prerequisites:** Promises, async/await, event loop, API integration
**Target:** Node.js 18+ LTS, Modern Browsers (ES2021+)

---

## Learning Objectives

By the end of this lesson, you will be able to:

1. Implement parallel and sequential execution patterns optimally
2. Identify and prevent race conditions in async code
3. Create debounced and throttled async functions
4. Use async iteration with for-await-of loops
5. Build and use async generators for data streaming
6. Implement promise pools for controlled concurrency
7. Design error boundaries for async operations
8. Write comprehensive tests for async code
9. Apply production-ready async patterns
10. Optimize async code for performance and reliability

---

## Table of Contents

1. [Introduction](#introduction)
2. [Parallel Execution Patterns](#parallel-execution-patterns)
3. [Sequential Execution Patterns](#sequential-execution-patterns)
4. [Race Conditions](#race-conditions)
5. [Debouncing and Throttling](#debouncing-and-throttling)
6. [Async Iteration](#async-iteration)
7. [Async Generators](#async-generators)
8. [Promise Pools](#promise-pools)
9. [Error Boundaries](#error-boundaries)
10. [Testing Async Code](#testing-async-code)
11. [Production Patterns](#production-patterns)
12. [Worked Examples](#worked-examples)
13. [Exercises](#exercises)
14. [Best Practices](#best-practices)
15. [Common Pitfalls](#common-pitfalls)
16. [Performance Optimization](#performance-optimization)
17. [Summary & Next Steps](#summary--next-steps)
18. [References](#references)

---

## Introduction

Mastering async patterns is essential for writing scalable, maintainable JavaScript applications. This lesson covers advanced patterns used in production code.

**Why Async Patterns Matter:**

- **Performance:** Maximize throughput and minimize latency
- **Reliability:** Handle errors gracefully
- **Scalability:** Process many operations efficiently
- **Maintainability:** Clean, understandable code
- **User Experience:** Responsive, non-blocking applications

**Real-World Impact:**

- High-performance APIs
- Responsive user interfaces
- Efficient data processing pipelines
- Robust error recovery
- Production-ready applications

---

## Parallel Execution Patterns

### Promise.all() for Independent Operations

```javascript
/**
 * Execute independent operations in parallel
 */

async function loadUserDashboard(userId) {
  // Start all operations simultaneously
  const [user, posts, comments, stats] = await Promise.all([
    fetchUser(userId),
    fetchUserPosts(userId),
    fetchUserComments(userId),
    fetchUserStats(userId)
  ]);

  return { user, posts, comments, stats };
}

// If one fails, all fail
try {
  const dashboard = await loadUserDashboard(123);
} catch (error) {
  console.error('Dashboard load failed:', error);
}
```

### Promise.allSettled() for Partial Success

```javascript
/**
 * Continue even if some operations fail
 */

async function loadUserData(userId) {
  const results = await Promise.allSettled([
    fetchUser(userId),
    fetchUserPosts(userId),
    fetchUserComments(userId),
    fetchUserStats(userId)
  ]);

  const data = {};

  results.forEach((result, index) => {
    const keys = ['user', 'posts', 'comments', 'stats'];

    if (result.status === 'fulfilled') {
      data[keys[index]] = result.value;
    } else {
      data[keys[index]] = null;
      console.error(`Failed to load ${keys[index]}:`, result.reason);
    }
  });

  return data;
}
```

### Parallel Map Pattern

```javascript
/**
 * Process array items in parallel
 */

async function processUsers(userIds) {
  // All users processed simultaneously
  const users = await Promise.all(
    userIds.map(id => fetchAndProcessUser(id))
  );

  return users;
}

async function fetchAndProcessUser(userId) {
  const user = await fetchUser(userId);
  const processed = await processUserData(user);
  return processed;
}

// Usage
const userIds = [1, 2, 3, 4, 5];
const processed = await processUsers(userIds);
```

### Controlled Concurrency

```javascript
/**
 * Limit number of concurrent operations
 */

async function processWithLimit(items, limit, processor) {
  const results = [];
  const executing = [];

  for (const [index, item] of items.entries()) {
    const promise = Promise.resolve().then(() => processor(item));

    results.push(promise);

    if (limit <= items.length) {
      const executed = promise.then(() => {
        executing.splice(executing.indexOf(executed), 1);
      });

      executing.push(executed);

      if (executing.length >= limit) {
        await Promise.race(executing);
      }
    }
  }

  return Promise.all(results);
}

// Process max 3 items at a time
const items = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const results = await processWithLimit(items, 3, async item => {
  await delay(1000);
  return item * 2;
});
```

---

## Sequential Execution Patterns

### Reduce Pattern

```javascript
/**
 * Execute operations in strict sequence
 */

async function executeSequentially(tasks) {
  return tasks.reduce(async (previousPromise, currentTask) => {
    const results = await previousPromise;
    const currentResult = await currentTask();
    return [...results, currentResult];
  }, Promise.resolve([]));
}

// Usage
const tasks = [
  () => fetchData(1),
  () => fetchData(2),
  () => fetchData(3)
];

const results = await executeSequentially(tasks);
```

### For-Of Loop Pattern

```javascript
/**
 * Simple sequential processing with for-of
 */

async function processSequentially(items) {
  const results = [];

  for (const item of items) {
    const result = await processItem(item);
    results.push(result);
  }

  return results;
}

// When you need the result of one operation before starting the next
async function buildPipeline(data) {
  let result = data;

  for (const transformer of transformers) {
    result = await transformer(result);
  }

  return result;
}
```

### Waterfall Pattern

```javascript
/**
 * Each operation depends on the previous result
 */

async function waterfall(initialValue, operations) {
  let result = initialValue;

  for (const operation of operations) {
    result = await operation(result);
  }

  return result;
}

// Usage
const operations = [
  async value => value * 2,
  async value => value + 10,
  async value => value / 2
];

const result = await waterfall(5, operations);
console.log(result);  // (5 * 2 + 10) / 2 = 10
```

---

## Race Conditions

### Understanding Race Conditions

```javascript
/**
 * PROBLEM: Race condition
 */

let counter = 0;

async function incrementCounter() {
  const current = counter;
  await delay(10);  // Simulate async operation
  counter = current + 1;
}

// Race condition occurs
await Promise.all([
  incrementCounter(),
  incrementCounter(),
  incrementCounter()
]);

console.log(counter);  // Expected: 3, Actual: 1 (race condition!)
```

### Solution: Mutual Exclusion

```javascript
/**
 * SOLUTION: Use mutex for atomic operations
 */

class Mutex {
  constructor() {
    this.locked = false;
    this.queue = [];
  }

  async acquire() {
    if (!this.locked) {
      this.locked = true;
      return Promise.resolve();
    }

    return new Promise(resolve => {
      this.queue.push(resolve);
    });
  }

  release() {
    if (this.queue.length > 0) {
      const resolve = this.queue.shift();
      resolve();
    } else {
      this.locked = false;
    }
  }

  async runExclusive(callback) {
    await this.acquire();
    try {
      return await callback();
    } finally {
      this.release();
    }
  }
}

// Usage
const mutex = new Mutex();
let counter = 0;

async function incrementCounterSafe() {
  await mutex.runExclusive(async () => {
    const current = counter;
    await delay(10);
    counter = current + 1;
  });
}

await Promise.all([
  incrementCounterSafe(),
  incrementCounterSafe(),
  incrementCounterSafe()
]);

console.log(counter);  // 3 (correct!)
```

### Latest-Wins Pattern

```javascript
/**
 * Cancel previous operations, use latest
 */

class LatestPromise {
  constructor() {
    this.latestId = 0;
  }

  async run(promiseFn) {
    const id = ++this.latestId;
    const result = await promiseFn();

    if (id === this.latestId) {
      return result;
    }

    throw new Error('Superseded by newer operation');
  }
}

// Usage: Search autocomplete
const latest = new LatestPromise();

async function searchHandler(query) {
  try {
    const results = await latest.run(() => fetchSearchResults(query));
    displayResults(results);
  } catch (error) {
    if (error.message !== 'Superseded by newer operation') {
      console.error(error);
    }
  }
}

// Only last search is processed
searchHandler('a');
searchHandler('ab');
searchHandler('abc');  // Only this completes
```

---

## Debouncing and Throttling

### Debounce (Wait for Pause)

```javascript
/**
 * Debounce: Execute after quiet period
 */

function debounce(func, delay) {
  let timeoutId = null;

  return function debounced(...args) {
    clearTimeout(timeoutId);

    timeoutId = setTimeout(() => {
      func.apply(this, args);
    }, delay);
  };
}

// Usage: Search input
const handleSearch = debounce(query => {
  console.log('Searching for:', query);
  // Perform search
}, 500);

// Typing quickly...
handleSearch('a');
handleSearch('ab');
handleSearch('abc');
handleSearch('abcd');
// Only searches once, 500ms after last keystroke
```

### Async Debounce

```javascript
/**
 * Debounce for async functions
 */

function debounceAsync(func, delay) {
  let timeoutId = null;
  let pendingPromise = null;

  return function debounced(...args) {
    clearTimeout(timeoutId);

    return new Promise((resolve, reject) => {
      timeoutId = setTimeout(async () => {
        try {
          const result = await func.apply(this, args);
          resolve(result);
        } catch (error) {
          reject(error);
        }
      }, delay);
    });
  };
}

// Usage
const searchAPI = debounceAsync(async query => {
  const response = await fetch(`/api/search?q=${query}`);
  return await response.json();
}, 300);

const results = await searchAPI('javascript');
```

### Throttle (Rate Limiting)

```javascript
/**
 * Throttle: Execute at most once per interval
 */

function throttle(func, interval) {
  let lastCallTime = 0;

  return function throttled(...args) {
    const now = Date.now();

    if (now - lastCallTime >= interval) {
      lastCallTime = now;
      return func.apply(this, args);
    }
  };
}

// Usage: Scroll handler
const handleScroll = throttle(() => {
  console.log('Scroll position:', window.scrollY);
  // Heavy computation
}, 100);

window.addEventListener('scroll', handleScroll);
// Executes max once per 100ms, no matter how fast scrolling
```

### Throttle with Leading/Trailing Edge

```javascript
/**
 * Advanced throttle with options
 */

function throttle(func, interval, options = {}) {
  let timeoutId = null;
  let lastCallTime = 0;
  let lastArgs = null;

  const { leading = true, trailing = true } = options;

  function invoke() {
    if (lastArgs) {
      func.apply(this, lastArgs);
      lastArgs = null;
      lastCallTime = Date.now();
    }
  }

  return function throttled(...args) {
    const now = Date.now();
    const timeSinceLastCall = now - lastCallTime;

    lastArgs = args;

    if (leading && timeSinceLastCall >= interval) {
      invoke.call(this);
    } else if (trailing) {
      clearTimeout(timeoutId);

      timeoutId = setTimeout(() => {
        invoke.call(this);
      }, interval - timeSinceLastCall);
    }
  };
}
```

---

## Async Iteration

### For-Await-Of Loop

```javascript
/**
 * Iterate over async iterables
 */

async function* asyncGenerator() {
  yield await Promise.resolve(1);
  yield await Promise.resolve(2);
  yield await Promise.resolve(3);
}

async function consumeAsync() {
  for await (const value of asyncGenerator()) {
    console.log(value);  // 1, 2, 3
  }
}

// With async iterables
const asyncIterable = {
  async *[Symbol.asyncIterator]() {
    for (let i = 1; i <= 3; i++) {
      await delay(100);
      yield i;
    }
  }
};

for await (const value of asyncIterable) {
  console.log(value);
}
```

### Processing Streams

```javascript
/**
 * Process data streams with async iteration
 */

async function processStream(stream) {
  const reader = stream.getReader();

  try {
    while (true) {
      const { done, value } = await reader.read();

      if (done) break;

      console.log('Received chunk:', value);
      // Process chunk
    }
  } finally {
    reader.releaseLock();
  }
}

// With ReadableStream
const response = await fetch('https://example.com/large-file');
await processStream(response.body);
```

### Async Iterator Implementation

```javascript
/**
 * Custom async iterator
 */

class PaginatedAPI {
  constructor(baseUrl, pageSize = 10) {
    this.baseUrl = baseUrl;
    this.pageSize = pageSize;
  }

  async *[Symbol.asyncIterator]() {
    let page = 1;
    let hasMore = true;

    while (hasMore) {
      const response = await fetch(
        `${this.baseUrl}?page=${page}&size=${this.pageSize}`
      );

      const data = await response.json();

      yield* data.items;

      hasMore = data.hasMore;
      page++;
    }
  }
}

// Usage
const api = new PaginatedAPI('https://api.example.com/items');

for await (const item of api) {
  console.log('Item:', item);
  // Automatically fetches next page when needed
}
```

---

## Async Generators

### Basic Async Generator

```javascript
/**
 * Async generator function
 */

async function* numberGenerator(count) {
  for (let i = 0; i < count; i++) {
    await delay(100);
    yield i;
  }
}

// Consume
for await (const num of numberGenerator(5)) {
  console.log(num);  // 0, 1, 2, 3, 4 (with delays)
}
```

### Data Streaming with Generators

```javascript
/**
 * Stream data in chunks
 */

async function* fetchUsersPaginated(pageSize = 10) {
  let page = 1;
  let hasMore = true;

  while (hasMore) {
    const response = await fetch(
      `https://api.example.com/users?page=${page}&size=${pageSize}`
    );

    const data = await response.json();

    yield data.users;

    hasMore = data.page < data.totalPages;
    page++;

    // Rate limiting
    await delay(100);
  }
}

// Process all pages
for await (const userBatch of fetchUsersPaginated(50)) {
  console.log(`Processing ${userBatch.length} users`);
  await processBatch(userBatch);
}
```

### Transform Streams

```javascript
/**
 * Transform data with async generators
 */

async function* map(iterable, transform) {
  for await (const item of iterable) {
    yield await transform(item);
  }
}

async function* filter(iterable, predicate) {
  for await (const item of iterable) {
    if (await predicate(item)) {
      yield item;
    }
  }
}

async function* take(iterable, count) {
  let taken = 0;

  for await (const item of iterable) {
    if (taken >= count) break;
    yield item;
    taken++;
  }
}

// Usage: Pipeline
const numbers = async function*() {
  for (let i = 1; i <= 100; i++) {
    yield i;
  }
}();

const doubled = map(numbers, async n => n * 2);
const evens = filter(doubled, async n => n % 4 === 0);
const first10 = take(evens, 10);

for await (const num of first10) {
  console.log(num);
}
```

---

## Promise Pools

### Concurrency Pool Implementation

```javascript
/**
 * Execute promises with limited concurrency
 */

class PromisePool {
  constructor(concurrency = 5) {
    this.concurrency = concurrency;
    this.running = 0;
    this.queue = [];
  }

  async execute(promiseFn) {
    while (this.running >= this.concurrency) {
      await new Promise(resolve => this.queue.push(resolve));
    }

    this.running++;

    try {
      return await promiseFn();
    } finally {
      this.running--;

      const resolve = this.queue.shift();
      if (resolve) resolve();
    }
  }

  async executeAll(promiseFns) {
    return Promise.all(
      promiseFns.map(fn => this.execute(fn))
    );
  }
}

// Usage
const pool = new PromisePool(3);

const tasks = Array.from({ length: 20 }, (_, i) => {
  return () => fetchUser(i + 1);
});

const results = await pool.executeAll(tasks);
console.log(`Processed ${results.length} users`);
```

### Advanced Pool with Priority

```javascript
/**
 * Promise pool with priority queue
 */

class PriorityPromisePool {
  constructor(concurrency = 5) {
    this.concurrency = concurrency;
    this.running = 0;
    this.queue = [];
  }

  async execute(promiseFn, priority = 0) {
    return new Promise((resolve, reject) => {
      this.queue.push({ promiseFn, priority, resolve, reject });
      this.queue.sort((a, b) => b.priority - a.priority);
      this.process();
    });
  }

  async process() {
    if (this.running >= this.concurrency || this.queue.length === 0) {
      return;
    }

    this.running++;
    const { promiseFn, resolve, reject } = this.queue.shift();

    try {
      const result = await promiseFn();
      resolve(result);
    } catch (error) {
      reject(error);
    } finally {
      this.running--;
      this.process();
    }
  }
}

// Usage
const pool = new PriorityPromisePool(2);

pool.execute(() => fetchUser(1), 1);  // Low priority
pool.execute(() => fetchUser(2), 10); // High priority (runs first)
```

---

## Error Boundaries

### Async Error Boundary

```javascript
/**
 * Wrap async operations with error boundaries
 */

class AsyncErrorBoundary {
  constructor(errorHandler) {
    this.errorHandler = errorHandler;
  }

  async execute(asyncFn) {
    try {
      return await asyncFn();
    } catch (error) {
      return this.errorHandler(error);
    }
  }

  wrap(asyncFn) {
    return async (...args) => {
      try {
        return await asyncFn(...args);
      } catch (error) {
        return this.errorHandler(error);
      }
    };
  }
}

// Usage
const errorBoundary = new AsyncErrorBoundary(error => {
  console.error('Caught error:', error);
  // Log to monitoring service
  // Return fallback value
  return { error: true, message: error.message };
});

const safeFunction = errorBoundary.wrap(async () => {
  throw new Error('Something went wrong');
});

const result = await safeFunction();
console.log(result);  // { error: true, message: '...' }
```

### Circuit Breaker Pattern

```javascript
/**
 * Circuit breaker for failing services
 */

class CircuitBreaker {
  constructor(threshold = 5, timeout = 60000) {
    this.threshold = threshold;
    this.timeout = timeout;
    this.failures = 0;
    this.state = 'CLOSED';  // CLOSED, OPEN, HALF_OPEN
    this.nextAttempt = Date.now();
  }

  async execute(asyncFn) {
    if (this.state === 'OPEN') {
      if (Date.now() < this.nextAttempt) {
        throw new Error('Circuit breaker is OPEN');
      }

      this.state = 'HALF_OPEN';
    }

    try {
      const result = await asyncFn();

      if (this.state === 'HALF_OPEN') {
        this.state = 'CLOSED';
        this.failures = 0;
      }

      return result;
    } catch (error) {
      this.failures++;

      if (this.failures >= this.threshold) {
        this.state = 'OPEN';
        this.nextAttempt = Date.now() + this.timeout;
      }

      throw error;
    }
  }
}

// Usage
const breaker = new CircuitBreaker(3, 5000);

async function callAPI() {
  try {
    return await breaker.execute(() => fetch('/api/data'));
  } catch (error) {
    console.error('API call failed:', error.message);
  }
}
```

---

## Testing Async Code

### Testing with Vitest

```javascript
/**
 * Testing async functions
 */

import { describe, it, expect, vi } from 'vitest';

describe('Async operations', () => {
  it('should resolve with data', async () => {
    const result = await fetchUser(1);
    expect(result).toHaveProperty('id', 1);
  });

  it('should reject with error', async () => {
    await expect(fetchUser(-1)).rejects.toThrow('Invalid ID');
  });

  it('should handle timeout', async () => {
    const promise = fetchWithTimeout('/slow', 100);
    await expect(promise).rejects.toThrow('Timeout');
  }, 1000);

  it('should call API with correct params', async () => {
    const spy = vi.spyOn(global, 'fetch');

    await fetchUser(123);

    expect(spy).toHaveBeenCalledWith(
      expect.stringContaining('/users/123')
    );

    spy.mockRestore();
  });
});
```

### Mocking Async Functions

```javascript
/**
 * Mock async dependencies
 */

import { vi } from 'vitest';

// Mock fetch
global.fetch = vi.fn();

describe('API client', () => {
  it('should fetch and parse user', async () => {
    fetch.mockResolvedValueOnce({
      ok: true,
      json: async () => ({ id: 1, name: 'Alice' })
    });

    const user = await fetchUser(1);

    expect(user.name).toBe('Alice');
    expect(fetch).toHaveBeenCalledTimes(1);
  });

  it('should handle fetch error', async () => {
    fetch.mockRejectedValueOnce(new Error('Network error'));

    await expect(fetchUser(1)).rejects.toThrow('Network error');
  });
});
```

### Testing Race Conditions

```javascript
/**
 * Test concurrent operations
 */

import { describe, it, expect } from 'vitest';

describe('Concurrent operations', () => {
  it('should handle concurrent updates correctly', async () => {
    const counter = new SafeCounter();

    await Promise.all([
      counter.increment(),
      counter.increment(),
      counter.increment()
    ]);

    expect(counter.value).toBe(3);
  });

  it('should prevent race conditions', async () => {
    const resource = new MutexProtectedResource();

    const results = await Promise.all([
      resource.update(1),
      resource.update(2),
      resource.update(3)
    ]);

    expect(results).toHaveLength(3);
    expect(new Set(results).size).toBe(3);
  });
});
```

---

## Production Patterns

### Graceful Degradation

```javascript
/**
 * Fallback chain for failing operations
 */

async function fetchWithFallback(...urls) {
  for (const url of urls) {
    try {
      const response = await fetch(url);

      if (response.ok) {
        return await response.json();
      }
    } catch (error) {
      console.warn(`Failed to fetch from ${url}:`, error);
    }
  }

  throw new Error('All endpoints failed');
}

// Usage
const data = await fetchWithFallback(
  'https://primary-api.com/data',
  'https://backup-api.com/data',
  'https://cache-server.com/data'
);
```

### Health Checks

```javascript
/**
 * Monitor service health
 */

class HealthChecker {
  constructor(services) {
    this.services = services;
  }

  async checkAll() {
    const results = await Promise.allSettled(
      Object.entries(this.services).map(async ([name, check]) => {
        const start = Date.now();

        try {
          await check();

          return {
            name,
            status: 'healthy',
            responseTime: Date.now() - start
          };
        } catch (error) {
          return {
            name,
            status: 'unhealthy',
            error: error.message,
            responseTime: Date.now() - start
          };
        }
      })
    );

    return results.map(r => r.value);
  }
}

// Usage
const healthChecker = new HealthChecker({
  database: async () => {
    await db.ping();
  },
  api: async () => {
    const response = await fetch('https://api.example.com/health');
    if (!response.ok) throw new Error('API unhealthy');
  },
  cache: async () => {
    await redis.ping();
  }
});

const health = await healthChecker.checkAll();
console.log(health);
```

---

## Worked Examples

### Example 1: Data Pipeline

```javascript
/**
 * Complete async data pipeline
 */

class DataPipeline {
  constructor(stages) {
    this.stages = stages;
  }

  async process(data) {
    let result = data;

    for (const [index, stage] of this.stages.entries()) {
      console.log(`Stage ${index + 1}/${this.stages.length}`);

      try {
        result = await stage(result);
      } catch (error) {
        console.error(`Stage ${index + 1} failed:`, error);
        throw error;
      }
    }

    return result;
  }

  async processBatch(items) {
    return Promise.all(
      items.map(item => this.process(item))
    );
  }
}

// Usage
const pipeline = new DataPipeline([
  async data => {
    // Stage 1: Validate
    if (!data.id) throw new Error('Missing ID');
    return data;
  },
  async data => {
    // Stage 2: Enrich
    const extra = await fetchExtraData(data.id);
    return { ...data, ...extra };
  },
  async data => {
    // Stage 3: Transform
    return {
      ...data,
      processedAt: new Date().toISOString()
    };
  }
]);

const result = await pipeline.process({ id: 123, value: 'test' });
```

---

## Exercises

### Exercise 1: Promise Pool (Medium)

Implement a promise pool with concurrency limit.

**Solution:** See `solutions/exercise1_patterns.js`

### Exercise 2: Debounce Async (Medium)

Create an async debounce function.

**Solution:** See `solutions/exercise2_patterns.js`

### Exercise 3: Circuit Breaker (Hard)

Implement a circuit breaker pattern.

**Solution:** See `solutions/exercise3_patterns.js`

### Exercise 4: Retry with Backoff (Medium)

Implement retry with exponential backoff.

**Solution:** See `solutions/exercise4_patterns.js`

### Exercise 5: Async Iterator (Hard)

Create a paginated async iterator.

**Solution:** See `solutions/exercise5_patterns.js`

---

## Best Practices

1. **Prefer Promise.all() for independent operations**
2. **Use Promise.allSettled() for partial failures**
3. **Implement timeouts for all network requests**
4. **Add retry logic with backoff for transient failures**
5. **Use circuit breakers for external dependencies**
6. **Limit concurrency to prevent resource exhaustion**
7. **Test async code thoroughly with mocks**
8. **Monitor async operations in production**
9. **Implement graceful degradation**
10. **Use async generators for data streams**

---

## Common Pitfalls

1. **Forgetting to await promises**
2. **Using forEach with async/await**
3. **Not handling promise rejections**
4. **Creating memory leaks with listeners**
5. **Blocking event loop with sync operations**
6. **Not limiting concurrency**
7. **Improper error handling in parallel operations**

---

## Performance Optimization

- Minimize sequential operations
- Use Promise.all() for parallelism
- Implement caching strategically
- Monitor and optimize slow operations
- Use request pooling and reuse connections
- Implement proper timeouts
- Profile and measure performance

---

## Summary & Next Steps

You now have comprehensive knowledge of async patterns in JavaScript.

### Key Takeaways

- Choose the right execution pattern (parallel vs sequential)
- Prevent race conditions with proper synchronization
- Use debouncing and throttling for optimization
- Implement async iteration for data streams
- Apply production patterns for reliability
- Test async code thoroughly

### Next Steps

- Practice building production-ready async applications
- Explore reactive programming (RxJS)
- Learn about Web Workers for parallelism
- Study distributed systems patterns

---

**Congratulations!** You've completed the Asynchronous JavaScript curriculum.

