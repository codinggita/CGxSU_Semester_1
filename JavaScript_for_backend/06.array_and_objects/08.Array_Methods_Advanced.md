# Array Methods: Advanced Functional Programming

**Difficulty:** Intermediate to Advanced
**Estimated Time:** 60-75 minutes
**Prerequisites:** Array fundamentals, functions, callbacks
**Target:** Node.js 18+ LTS, Modern Browsers (ES2021+)

---

## Learning Objectives

By the end of this lesson, you will be able to:

1. Master transformation methods: map(), flatMap()
2. Implement filtering logic with filter(), find(), findIndex()
3. Perform aggregations and reductions using reduce()
4. Apply validation methods: some(), every(), includes()
5. Sort and reverse arrays with custom comparators
6. Flatten nested arrays with flat() and flatMap()
7. Chain array methods for complex data transformations
8. Understand performance implications of different methods
9. Choose the right method for specific use cases
10. Debug and test functional array operations

---

## Table of Contents

1. [Introduction](#introduction)
2. [map() - Transformation](#map---transformation)
3. [filter() - Filtering](#filter---filtering)
4. [reduce() - Accumulation](#reduce---accumulation)
5. [find() and findIndex()](#find-and-findindex)
6. [some() and every()](#some-and-every)
7. [sort() and reverse()](#sort-and-reverse)
8. [includes() and indexOf()](#includes-and-indexof)
9. [flat() and flatMap()](#flat-and-flatmap)
10. [Method Chaining Patterns](#method-chaining-patterns)
11. [Performance Considerations](#performance-considerations)
12. [Worked Examples](#worked-examples)
13. [Exercises](#exercises)
14. [Testing & Debugging](#testing--debugging)
15. [Best Practices](#best-practices)
16. [Common Pitfalls](#common-pitfalls)
17. [When to Use Which Method](#when-to-use-which-method)
18. [Summary & Next Steps](#summary--next-steps)
19. [References](#references)

---

## Introduction

JavaScript's array methods enable **functional programming** patterns that are:
- **Declarative**: Focus on what to do, not how
- **Immutable**: Don't modify original data (mostly)
- **Composable**: Chain operations together
- **Readable**: Self-documenting code

These methods are essential for modern JavaScript development, especially in:
- Data processing and ETL pipelines
- API response transformation
- Database query result manipulation
- State management in frameworks (React, Vue)
- Functional programming paradigms

**Key Concepts:**
- **Pure functions**: No side effects, predictable output
- **Higher-order functions**: Functions that take/return functions
- **Immutability**: Prefer creating new arrays over mutating
- **Lazy evaluation**: Some methods short-circuit for efficiency

---

## map() - Transformation

The `map()` method creates a **new array** by applying a function to each element.

### Syntax

```javascript
const newArray = array.map((element, index, array) => {
  // Transform element
  return transformedValue;
});
```

### Basic Usage

```javascript
const numbers = [1, 2, 3, 4, 5];

// Double each number
const doubled = numbers.map(num => num * 2);
console.log(doubled); // [2, 4, 6, 8, 10]
console.log(numbers); // [1, 2, 3, 4, 5] - unchanged

// Square each number
const squared = numbers.map(num => num ** 2);
console.log(squared); // [1, 4, 9, 16, 25]
```

### Transform Objects

```javascript
const users = [
  { firstName: 'Alice', lastName: 'Smith', age: 25 },
  { firstName: 'Bob', lastName: 'Jones', age: 30 },
  { firstName: 'Charlie', lastName: 'Brown', age: 35 }
];

// Extract full names
const fullNames = users.map(user => `${user.firstName} ${user.lastName}`);
console.log(fullNames); // ['Alice Smith', 'Bob Jones', 'Charlie Brown']

// Create new objects with computed properties
const userSummaries = users.map(user => ({
  name: `${user.firstName} ${user.lastName}`,
  isAdult: user.age >= 18,
  birthYear: new Date().getFullYear() - user.age
}));
```

### Using Index and Array Parameters

```javascript
const letters = ['a', 'b', 'c'];

// Add index to each element
const indexed = letters.map((letter, index) => `${index}: ${letter}`);
console.log(indexed); // ['0: a', '1: b', '2: c']

// Reference original array
const withContext = letters.map((letter, index, arr) => ({
  letter,
  position: index + 1,
  total: arr.length
}));
```

### Practical Example: API Response Transformation

```javascript
// Raw API response
const apiResponse = [
  { id: 1, user_name: 'alice_smith', created_at: '2024-01-15T10:30:00Z' },
  { id: 2, user_name: 'bob_jones', created_at: '2024-01-16T14:20:00Z' }
];

// Transform to camelCase and parse dates
const cleanedData = apiResponse.map(item => ({
  id: item.id,
  userName: item.user_name,
  createdAt: new Date(item.created_at)
}));
```

### When to Use map()

- ✅ Transform each element to a new value
- ✅ Extract specific properties from objects
- ✅ Convert data formats
- ✅ Need same number of output elements as input
- ❌ Don't use if you don't need the returned array (use forEach instead)
- ❌ Don't use for filtering (use filter instead)

---

## filter() - Filtering

The `filter()` method creates a **new array** with elements that pass a test.

### Syntax

```javascript
const filtered = array.filter((element, index, array) => {
  // Return true to keep, false to exclude
  return boolean;
});
```

### Basic Usage

```javascript
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// Get even numbers
const evens = numbers.filter(num => num % 2 === 0);
console.log(evens); // [2, 4, 6, 8, 10]

// Get numbers > 5
const greaterThan5 = numbers.filter(num => num > 5);
console.log(greaterThan5); // [6, 7, 8, 9, 10]

// Get numbers between 3 and 7
const between = numbers.filter(num => num >= 3 && num <= 7);
console.log(between); // [3, 4, 5, 6, 7]
```

### Filter Objects

```javascript
const products = [
  { name: 'Laptop', price: 999, inStock: true },
  { name: 'Mouse', price: 25, inStock: true },
  { name: 'Keyboard', price: 75, inStock: false },
  { name: 'Monitor', price: 300, inStock: true }
];

// Get available products
const available = products.filter(product => product.inStock);

// Get products under $100
const affordable = products.filter(product => product.price < 100);

// Complex condition
const availableAndAffordable = products.filter(
  product => product.inStock && product.price < 500
);
```

### Using Index

```javascript
const numbers = [5, 10, 15, 20, 25];

// Get elements at even indices
const evenIndices = numbers.filter((num, index) => index % 2 === 0);
console.log(evenIndices); // [5, 15, 25]

// Get first 3 elements (inefficient, use slice instead)
const firstThree = numbers.filter((num, index) => index < 3);
```

### Remove Falsy Values

```javascript
const mixed = [0, 1, false, 2, '', 3, null, 4, undefined, 5, NaN];

// Remove all falsy values
const truthyOnly = mixed.filter(Boolean);
console.log(truthyOnly); // [1, 2, 3, 4, 5]

// Remove null/undefined only
const defined = mixed.filter(x => x != null);
console.log(defined); // [0, 1, false, 2, '', 3, 4, 5, NaN]
```

### Remove Duplicates (with filter)

```javascript
const numbers = [1, 2, 3, 2, 4, 3, 5, 1];

// Keep first occurrence of each value
const unique = numbers.filter((num, index, arr) => arr.indexOf(num) === index);
console.log(unique); // [1, 2, 3, 4, 5]

// Better: use Set
const uniqueSet = [...new Set(numbers)];
```

---

## reduce() - Accumulation

The `reduce()` method executes a reducer function on each element, resulting in a **single output value**.

### Syntax

```javascript
const result = array.reduce((accumulator, currentValue, index, array) => {
  // Return updated accumulator
  return newAccumulatorValue;
}, initialValue);
```

### Sum and Product

```javascript
const numbers = [1, 2, 3, 4, 5];

// Sum all numbers
const sum = numbers.reduce((total, num) => total + num, 0);
console.log(sum); // 15

// Product of all numbers
const product = numbers.reduce((prod, num) => prod * num, 1);
console.log(product); // 120

// Without initial value (uses first element)
const sumNoInit = numbers.reduce((total, num) => total + num);
console.log(sumNoInit); // 15
```

### Find Maximum/Minimum

```javascript
const numbers = [5, 2, 9, 1, 7, 3];

const max = numbers.reduce((maximum, num) => num > maximum ? num : maximum);
console.log(max); // 9

const min = numbers.reduce((minimum, num) => num < minimum ? num : minimum);
console.log(min); // 1

// Better: use Math.max/min
const maxBetter = Math.max(...numbers); // 9
```

### Count Occurrences

```javascript
const fruits = ['apple', 'banana', 'apple', 'cherry', 'banana', 'apple'];

const counts = fruits.reduce((acc, fruit) => {
  acc[fruit] = (acc[fruit] || 0) + 1;
  return acc;
}, {});

console.log(counts);
// { apple: 3, banana: 2, cherry: 1 }
```

### Group By Property

```javascript
const people = [
  { name: 'Alice', age: 25, city: 'NYC' },
  { name: 'Bob', age: 30, city: 'LA' },
  { name: 'Charlie', age: 25, city: 'NYC' },
  { name: 'David', age: 30, city: 'NYC' }
];

// Group by city
const byCity = people.reduce((acc, person) => {
  const city = person.city;
  if (!acc[city]) acc[city] = [];
  acc[city].push(person);
  return acc;
}, {});

console.log(byCity);
// {
//   NYC: [{name: 'Alice', ...}, {name: 'Charlie', ...}, {name: 'David', ...}],
//   LA: [{name: 'Bob', ...}]
// }
```

### Flatten Array

```javascript
const nested = [[1, 2], [3, 4], [5, 6]];

const flat = nested.reduce((acc, arr) => acc.concat(arr), []);
console.log(flat); // [1, 2, 3, 4, 5, 6]

// Better: use flat()
const flatBetter = nested.flat(); // [1, 2, 3, 4, 5, 6]
```

### Transform Array to Object

```javascript
const users = [
  { id: 1, name: 'Alice' },
  { id: 2, name: 'Bob' },
  { id: 3, name: 'Charlie' }
];

// Create lookup object by id
const userLookup = users.reduce((acc, user) => {
  acc[user.id] = user;
  return acc;
}, {});

console.log(userLookup);
// { 1: {id: 1, name: 'Alice'}, 2: {...}, 3: {...} }
```

### Pipeline with reduce

```javascript
const numbers = [1, 2, 3, 4, 5];

// Apply multiple operations
const result = numbers.reduce((acc, num) => {
  // Filter: only evens
  if (num % 2 !== 0) return acc;
  // Map: square
  const squared = num ** 2;
  // Accumulate
  return acc + squared;
}, 0);

console.log(result); // 4 + 16 = 20

// Better: use separate methods
const betterResult = numbers
  .filter(num => num % 2 === 0)
  .map(num => num ** 2)
  .reduce((sum, num) => sum + num, 0);
```

### reduceRight()

Processes array from right to left:

```javascript
const letters = ['a', 'b', 'c', 'd'];

const reversed = letters.reduceRight((acc, letter) => acc + letter, '');
console.log(reversed); // 'dcba'

// Better: use reverse()
const betterReversed = letters.reverse().join('');
```

---

## find() and findIndex()

### find() - First Match

Returns the **first element** that satisfies the condition.

```javascript
const numbers = [5, 12, 8, 130, 44];

// Find first number > 10
const found = numbers.find(num => num > 10);
console.log(found); // 12

// Find first even number
const firstEven = numbers.find(num => num % 2 === 0);
console.log(firstEven); // 12

// Not found returns undefined
const notFound = numbers.find(num => num > 200);
console.log(notFound); // undefined
```

### find() with Objects

```javascript
const users = [
  { id: 1, name: 'Alice', active: true },
  { id: 2, name: 'Bob', active: false },
  { id: 3, name: 'Charlie', active: true }
];

// Find user by id
const user = users.find(u => u.id === 2);
console.log(user); // { id: 2, name: 'Bob', active: false }

// Find first active user
const activeUser = users.find(u => u.active);
console.log(activeUser); // { id: 1, name: 'Alice', active: true }
```

### findIndex() - Index of First Match

Returns the **index** of the first element that satisfies the condition.

```javascript
const numbers = [5, 12, 8, 130, 44];

const index = numbers.findIndex(num => num > 10);
console.log(index); // 1 (position of 12)

// Not found returns -1
const notFoundIndex = numbers.findIndex(num => num > 200);
console.log(notFoundIndex); // -1
```

### findLast() and findLastIndex() (ES2023)

```javascript
const numbers = [5, 12, 8, 130, 44];

// Find last number > 10
const lastFound = numbers.findLast(num => num > 10);
console.log(lastFound); // 44

const lastIndex = numbers.findLastIndex(num => num > 10);
console.log(lastIndex); // 4
```

### find() vs filter()

```javascript
const numbers = [1, 2, 3, 4, 5];

// find() - returns first match (element)
const found = numbers.find(n => n > 2); // 3

// filter() - returns all matches (array)
const filtered = numbers.filter(n => n > 2); // [3, 4, 5]

// Performance: find() is faster (stops at first match)
```

---

## some() and every()

### some() - At Least One

Returns `true` if **at least one** element passes the test.

```javascript
const numbers = [1, 2, 3, 4, 5];

// Is there any even number?
const hasEven = numbers.some(num => num % 2 === 0);
console.log(hasEven); // true

// Is there any number > 10?
const hasLarge = numbers.some(num => num > 10);
console.log(hasLarge); // false

// Empty array always returns false
[].some(x => true); // false
```

### some() with Objects

```javascript
const users = [
  { name: 'Alice', age: 25, admin: false },
  { name: 'Bob', age: 30, admin: true },
  { name: 'Charlie', age: 35, admin: false }
];

// Is there any admin?
const hasAdmin = users.some(user => user.admin);
console.log(hasAdmin); // true

// Is anyone under 18?
const hasMinor = users.some(user => user.age < 18);
console.log(hasMinor); // false
```

### every() - All Elements

Returns `true` if **all** elements pass the test.

```javascript
const numbers = [2, 4, 6, 8, 10];

// Are all numbers even?
const allEven = numbers.every(num => num % 2 === 0);
console.log(allEven); // true

// Are all numbers > 5?
const allLarge = numbers.every(num => num > 5);
console.log(allLarge); // false

// Empty array always returns true
[].every(x => false); // true
```

### every() for Validation

```javascript
const formData = {
  username: 'alice',
  email: 'alice@example.com',
  age: 25
};

const rules = [
  () => formData.username.length >= 3,
  () => formData.email.includes('@'),
  () => formData.age >= 18
];

const isValid = rules.every(rule => rule());
console.log(isValid); // true
```

### Short-Circuit Evaluation

```javascript
// some() stops at first true
[1, 2, 3, 4].some(num => {
  console.log(num);
  return num > 2;
});
// Logs: 1, 2, 3 (stops at 3)

// every() stops at first false
[1, 2, 3, 4].every(num => {
  console.log(num);
  return num < 3;
});
// Logs: 1, 2, 3 (stops at 3)
```

---

## sort() and reverse()

### sort() - Sorting

**⚠️ Warning:** `sort()` mutates the original array!

```javascript
const numbers = [3, 1, 4, 1, 5, 9, 2, 6];

// ❌ Default sort (converts to strings!)
numbers.sort();
console.log(numbers); // [1, 1, 2, 3, 4, 5, 6, 9] - lucky!

const nums = [10, 2, 30, 4];
nums.sort();
console.log(nums); // [10, 2, 30, 4] - WRONG! (string sort)
```

### Numeric Sort

```javascript
const numbers = [10, 2, 30, 4, 1];

// ✅ Ascending
numbers.sort((a, b) => a - b);
console.log(numbers); // [1, 2, 4, 10, 30]

// ✅ Descending
numbers.sort((a, b) => b - a);
console.log(numbers); // [30, 10, 4, 2, 1]

// How it works:
// - If return < 0: a comes before b
// - If return > 0: b comes before a
// - If return === 0: order unchanged
```

### String Sort

```javascript
const words = ['banana', 'apple', 'cherry', 'date'];

// Case-sensitive (default)
words.sort();
console.log(words); // ['apple', 'banana', 'cherry', 'date']

// Case-insensitive
const mixed = ['Banana', 'apple', 'Cherry'];
mixed.sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
console.log(mixed); // ['apple', 'Banana', 'Cherry']

// Better: use localeCompare
mixed.sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));
```

### Sort Objects

```javascript
const users = [
  { name: 'Charlie', age: 35 },
  { name: 'Alice', age: 25 },
  { name: 'Bob', age: 30 }
];

// Sort by age (ascending)
users.sort((a, b) => a.age - b.age);

// Sort by name (alphabetically)
users.sort((a, b) => a.name.localeCompare(b.name));

// Multi-level sort (by age, then name)
users.sort((a, b) => {
  if (a.age !== b.age) return a.age - b.age;
  return a.name.localeCompare(b.name);
});
```

### Immutable Sort

```javascript
const numbers = [3, 1, 4, 1, 5];

// ✅ Create sorted copy
const sorted = [...numbers].sort((a, b) => a - b);
console.log(numbers); // [3, 1, 4, 1, 5] - unchanged
console.log(sorted);  // [1, 1, 3, 4, 5]

// Alternative
const sorted2 = numbers.slice().sort((a, b) => a - b);

// Modern: toSorted() (ES2023)
const sorted3 = numbers.toSorted((a, b) => a - b);
```

### reverse()

**⚠️ Warning:** `reverse()` mutates the original array!

```javascript
const numbers = [1, 2, 3, 4, 5];

numbers.reverse();
console.log(numbers); // [5, 4, 3, 2, 1]

// Immutable reverse
const reversed = [...numbers].reverse();

// Modern: toReversed() (ES2023)
const reversed2 = numbers.toReversed();
```

---

## includes() and indexOf()

### includes() - Check Existence

Returns `true` if array contains the value.

```javascript
const fruits = ['apple', 'banana', 'cherry'];

console.log(fruits.includes('banana')); // true
console.log(fruits.includes('grape'));  // false

// Case-sensitive
console.log(fruits.includes('Apple')); // false

// From index
const numbers = [1, 2, 3, 4, 5, 3];
console.log(numbers.includes(3, 3)); // true (starts from index 3)
```

### includes() with NaN

```javascript
const arr = [1, 2, NaN, 4];

// ✅ includes can find NaN
console.log(arr.includes(NaN)); // true

// ❌ indexOf cannot find NaN
console.log(arr.indexOf(NaN)); // -1
```

### indexOf() - Find Index

Returns the **first index** of the value, or -1 if not found.

```javascript
const numbers = [10, 20, 30, 20, 40];

console.log(numbers.indexOf(20));    // 1 (first occurrence)
console.log(numbers.indexOf(50));    // -1 (not found)
console.log(numbers.indexOf(20, 2)); // 3 (from index 2)
```

### lastIndexOf() - Find Last Index

```javascript
const numbers = [10, 20, 30, 20, 40];

console.log(numbers.lastIndexOf(20)); // 3 (last occurrence)
console.log(numbers.lastIndexOf(50)); // -1 (not found)
```

### includes() vs indexOf()

```javascript
// Check existence
if (arr.includes('value')) { } // ✅ Clear intent
if (arr.indexOf('value') !== -1) { } // ❌ Less clear

// Need index
const index = arr.indexOf('value'); // ✅ Use indexOf
if (index !== -1) {
  // Use index...
}
```

---

## flat() and flatMap()

### flat() - Flatten Nested Arrays

```javascript
const nested = [1, [2, 3], [4, [5, 6]]];

// Flatten one level
const flat1 = nested.flat();
console.log(flat1); // [1, 2, 3, 4, [5, 6]]

// Flatten two levels
const flat2 = nested.flat(2);
console.log(flat2); // [1, 2, 3, 4, 5, 6]

// Flatten all levels
const flatAll = nested.flat(Infinity);
console.log(flatAll); // [1, 2, 3, 4, 5, 6]

// Remove empty slots
const sparse = [1, , 3, , 5];
const dense = sparse.flat();
console.log(dense); // [1, 3, 5]
```

### flatMap() - Map + Flatten

Equivalent to `map().flat()` but more efficient.

```javascript
const sentences = ['Hello world', 'How are you'];

// Get all words (map + flat)
const words1 = sentences.map(s => s.split(' ')).flat();
console.log(words1); // ['Hello', 'world', 'How', 'are', 'you']

// ✅ Better: flatMap
const words2 = sentences.flatMap(s => s.split(' '));
console.log(words2); // ['Hello', 'world', 'How', 'are', 'you']
```

### Practical flatMap()

```javascript
// Duplicate each number
const numbers = [1, 2, 3];
const doubled = numbers.flatMap(n => [n, n]);
console.log(doubled); // [1, 1, 2, 2, 3, 3]

// Expand ranges
const ranges = [
  { start: 1, end: 3 },
  { start: 5, end: 7 }
];

const expanded = ranges.flatMap(range => {
  const arr = [];
  for (let i = range.start; i <= range.end; i++) {
    arr.push(i);
  }
  return arr;
});
console.log(expanded); // [1, 2, 3, 5, 6, 7]

// Filter + map in one pass
const nums = [1, 2, 3, 4, 5];
const evenDoubled = nums.flatMap(n => n % 2 === 0 ? [n * 2] : []);
console.log(evenDoubled); // [4, 8]
```

---

## Method Chaining Patterns

### Basic Chaining

```javascript
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// Get sum of squares of even numbers
const result = numbers
  .filter(n => n % 2 === 0)     // [2, 4, 6, 8, 10]
  .map(n => n ** 2)              // [4, 16, 36, 64, 100]
  .reduce((sum, n) => sum + n, 0); // 220

console.log(result); // 220
```

### Data Pipeline

```javascript
const users = [
  { name: 'Alice', age: 25, city: 'NYC', active: true },
  { name: 'Bob', age: 30, city: 'LA', active: false },
  { name: 'Charlie', age: 35, city: 'NYC', active: true },
  { name: 'David', age: 28, city: 'NYC', active: true }
];

// Get names of active NYC users, sorted
const result = users
  .filter(u => u.active)
  .filter(u => u.city === 'NYC')
  .map(u => u.name)
  .sort();

console.log(result); // ['Alice', 'Charlie', 'David']
```

### Complex Transformation

```javascript
const orders = [
  { id: 1, items: [{ price: 10, qty: 2 }, { price: 5, qty: 3 }] },
  { id: 2, items: [{ price: 20, qty: 1 }] },
  { id: 3, items: [{ price: 15, qty: 2 }, { price: 10, qty: 1 }] }
];

// Calculate total revenue
const totalRevenue = orders
  .flatMap(order => order.items)
  .map(item => item.price * item.qty)
  .reduce((sum, total) => sum + total, 0);

console.log(totalRevenue); // 105

// With intermediate steps for clarity
const totalRevenueVerbose = orders
  .flatMap(order => order.items)                  // All items
  .map(item => ({ ...item, subtotal: item.price * item.qty })) // Add subtotal
  .reduce((sum, item) => sum + item.subtotal, 0);  // Sum subtotals
```

### Performance Optimization

```javascript
const numbers = Array.from({ length: 1000000 }, (_, i) => i);

// ❌ Slow: Multiple iterations
const result1 = numbers
  .filter(n => n % 2 === 0)
  .map(n => n ** 2)
  .filter(n => n > 100);

// ✅ Faster: Combined filter
const result2 = numbers
  .filter(n => n % 2 === 0 && (n ** 2) > 100)
  .map(n => n ** 2);

// ✅ Or use reduce for single pass
const result3 = numbers.reduce((acc, n) => {
  if (n % 2 === 0) {
    const squared = n ** 2;
    if (squared > 100) {
      acc.push(squared);
    }
  }
  return acc;
}, []);
```

---

## Performance Considerations

### Time Complexity

| Method | Time Complexity | Notes |
|--------|----------------|-------|
| `map()` | O(n) | Iterates once |
| `filter()` | O(n) | Iterates once |
| `reduce()` | O(n) | Iterates once |
| `find()` | O(n) worst case | Stops early |
| `some()/every()` | O(n) worst case | Short-circuits |
| `sort()` | O(n log n) | Comparison-based |
| `includes()` | O(n) | Linear search |
| `indexOf()` | O(n) | Linear search |
| `flat()` | O(n × depth) | Recursively flattens |

### Optimization Strategies

```javascript
// ❌ Inefficient: Creating unnecessary arrays
const result = arr
  .map(x => x * 2)
  .map(x => x + 1)
  .map(x => x ** 2);

// ✅ Efficient: Combine operations
const result = arr.map(x => ((x * 2) + 1) ** 2);

// ❌ Inefficient: filter then map
const result = arr
  .filter(x => x > 10)
  .map(x => x * 2);

// ✅ Efficient: Use reduce or flatMap
const result = arr.reduce((acc, x) => {
  if (x > 10) acc.push(x * 2);
  return acc;
}, []);

// Or flatMap
const result = arr.flatMap(x => x > 10 ? [x * 2] : []);
```

### Memory Considerations

```javascript
// Large dataset
const largeArray = Array.from({ length: 1000000 }, (_, i) => i);

// ❌ Memory-intensive: Creates multiple intermediate arrays
const result1 = largeArray
  .map(x => x * 2)
  .filter(x => x % 3 === 0)
  .map(x => x ** 2);

// ✅ Memory-efficient: Single pass with reduce
const result2 = largeArray.reduce((acc, x) => {
  const doubled = x * 2;
  if (doubled % 3 === 0) {
    acc.push(doubled ** 2);
  }
  return acc;
}, []);

// ✅ Or use generator functions for lazy evaluation
function* process(arr) {
  for (const x of arr) {
    const doubled = x * 2;
    if (doubled % 3 === 0) {
      yield doubled ** 2;
    }
  }
}
```

---

## Worked Examples

### Example 1: E-commerce Product Filter (Intermediate)

```javascript
/**
 * Product Filtering and Sorting System
 * Demonstrates: filter, sort, map, reduce
 */

const products = [
  { id: 1, name: 'Laptop', price: 999, category: 'Electronics', rating: 4.5, stock: 10 },
  { id: 2, name: 'Mouse', price: 25, category: 'Electronics', rating: 4.0, stock: 50 },
  { id: 3, name: 'Desk', price: 299, category: 'Furniture', rating: 4.8, stock: 5 },
  { id: 4, name: 'Chair', price: 199, category: 'Furniture', rating: 4.3, stock: 0 },
  { id: 5, name: 'Monitor', price: 350, category: 'Electronics', rating: 4.7, stock: 15 }
];

// Filter: In-stock electronics under $500, sorted by rating
const searchResults = products
  .filter(p => p.category === 'Electronics')
  .filter(p => p.stock > 0)
  .filter(p => p.price < 500)
  .sort((a, b) => b.rating - a.rating)
  .map(p => ({
    id: p.id,
    name: p.name,
    price: p.price,
    rating: p.rating
  }));

console.log(searchResults);
// [
//   { id: 5, name: 'Monitor', price: 350, rating: 4.7 },
//   { id: 2, name: 'Mouse', price: 25, rating: 4.0 }
// ]

// Calculate average price by category
const avgPriceByCategory = products.reduce((acc, product) => {
  const cat = product.category;
  if (!acc[cat]) {
    acc[cat] = { total: 0, count: 0 };
  }
  acc[cat].total += product.price;
  acc[cat].count += 1;
  return acc;
}, {});

// Convert to averages
const averages = Object.entries(avgPriceByCategory).reduce((acc, [cat, data]) => {
  acc[cat] = data.total / data.count;
  return acc;
}, {});

console.log(averages);
// { Electronics: 458, Furniture: 249 }
```

### Example 2: Data Aggregation Pipeline (Advanced)

```javascript
/**
 * Sales Analytics Dashboard
 * Demonstrates: complex chaining, grouping, aggregation
 */

const sales = [
  { date: '2024-01-15', product: 'Laptop', quantity: 2, price: 999, region: 'North' },
  { date: '2024-01-15', product: 'Mouse', quantity: 5, price: 25, region: 'North' },
  { date: '2024-01-16', product: 'Laptop', quantity: 1, price: 999, region: 'South' },
  { date: '2024-01-16', product: 'Keyboard', quantity: 3, price: 75, region: 'North' },
  { date: '2024-01-17', product: 'Mouse', quantity: 10, price: 25, region: 'South' }
];

// Calculate revenue by region
const revenueByRegion = sales.reduce((acc, sale) => {
  const revenue = sale.quantity * sale.price;
  acc[sale.region] = (acc[sale.region] || 0) + revenue;
  return acc;
}, {});

console.log(revenueByRegion);
// { North: 2348, South: 1249 }

// Top 3 products by revenue
const topProducts = sales
  .reduce((acc, sale) => {
    const revenue = sale.quantity * sale.price;
    acc[sale.product] = (acc[sale.product] || 0) + revenue;
    return acc;
  }, {})
  .entries() // Convert to array of [product, revenue]
  .map(([product, revenue]) => ({ product, revenue }))
  .sort((a, b) => b.revenue - a.revenue)
  .slice(0, 3);

// Better approach using Object.entries
const topProductsBetter = Object.entries(
  sales.reduce((acc, sale) => {
    const revenue = sale.quantity * sale.price;
    acc[sale.product] = (acc[sale.product] || 0) + revenue;
    return acc;
  }, {})
)
  .map(([product, revenue]) => ({ product, revenue }))
  .sort((a, b) => b.revenue - a.revenue)
  .slice(0, 3);

console.log(topProductsBetter);
// [
//   { product: 'Laptop', revenue: 2997 },
//   { product: 'Mouse', revenue: 375 },
//   { product: 'Keyboard', revenue: 225 }
// ]
```

### Example 3: Text Analysis (Complex)

```javascript
/**
 * Word Frequency Analyzer
 * Demonstrates: flatMap, reduce, sort
 */

const text = `
  The quick brown fox jumps over the lazy dog.
  The dog was not amused. The fox was clever.
`;

// Analyze word frequency
const wordFrequency = text
  .toLowerCase()
  .split(/\s+/)                              // Split by whitespace
  .map(word => word.replace(/[^\w]/g, ''))  // Remove punctuation
  .filter(word => word.length > 0)          // Remove empty strings
  .reduce((acc, word) => {
    acc[word] = (acc[word] || 0) + 1;
    return acc;
  }, {});

// Get top 5 words
const topWords = Object.entries(wordFrequency)
  .map(([word, count]) => ({ word, count }))
  .sort((a, b) => b.count - a.count)
  .slice(0, 5);

console.log(topWords);
// [
//   { word: 'the', count: 4 },
//   { word: 'fox', count: 2 },
//   { word: 'dog', count: 2 },
//   ...
// ]

// Character frequency (excluding spaces)
const charFrequency = text
  .toLowerCase()
  .split('')
  .filter(char => /[a-z]/.test(char))
  .reduce((acc, char) => {
    acc[char] = (acc[char] || 0) + 1;
    return acc;
  }, {});

console.log(charFrequency);
```

---

## Exercises

### Exercise 1: Array Transformation (Easy)

**Task:** Write a function `doubleEvens(arr)` that doubles all even numbers and removes odd numbers.

```javascript
// Example
doubleEvens([1, 2, 3, 4, 5, 6]); // [4, 8, 12]
```

**Solution:** See `solutions/08_array_methods_advanced_solutions.js`

---

### Exercise 2: Find and Filter (Easy)

**Task:** Given an array of users, write functions:
- `findUserById(users, id)` - returns user object or undefined
- `getAdultUsers(users)` - returns users aged 18+
- `hasAdmin(users)` - returns true if any user is admin

```javascript
const users = [
  { id: 1, name: 'Alice', age: 25, admin: false },
  { id: 2, name: 'Bob', age: 17, admin: false },
  { id: 3, name: 'Charlie', age: 30, admin: true }
];
```

**Solution:** See solutions file.

---

### Exercise 3: Data Aggregation (Medium)

**Task:** Write a function `calculateGradeStats(students)` that returns:
- Average score across all students
- Highest score
- Lowest score
- Number of students with average >= 80

```javascript
const students = [
  { name: 'Alice', scores: [85, 90, 92] },
  { name: 'Bob', scores: [78, 82, 80] },
  { name: 'Charlie', scores: [92, 95, 90] }
];
```

**Solution:** See solutions file.

---

### Exercise 4: Complex Sorting (Medium)

**Task:** Write a function `sortProducts(products, criteria)` that sorts by:
- `price-asc`: Price ascending
- `price-desc`: Price descending
- `name`: Alphabetically
- `rating`: Highest rating first

```javascript
const products = [
  { name: 'Laptop', price: 999, rating: 4.5 },
  { name: 'Mouse', price: 25, rating: 4.0 },
  { name: 'Monitor', price: 350, rating: 4.7 }
];
```

**Solution:** See solutions file.

---

### Exercise 5: Data Pipeline (Hard)

**Task:** Create a function `processOrders(orders)` that:
1. Filters out cancelled orders
2. Calculates total for each order (sum of item prices × quantities)
3. Groups orders by customer
4. Calculates total spent per customer
5. Returns customers sorted by total spent (descending)

```javascript
const orders = [
  { id: 1, customer: 'Alice', items: [{price: 10, qty: 2}, {price: 5, qty: 1}], status: 'completed' },
  { id: 2, customer: 'Bob', items: [{price: 20, qty: 1}], status: 'completed' },
  { id: 3, customer: 'Alice', items: [{price: 15, qty: 2}], status: 'cancelled' }
];

// Expected output:
// [
//   { customer: 'Alice', total: 25 },
//   { customer: 'Bob', total: 20 }
// ]
```

**Solution:** See solutions file.

---

### Exercise 6: Flatten and Transform (Hard)

**Task:** Write a function `extractEmails(data)` that extracts all unique email addresses from nested user data.

```javascript
const data = [
  {
    department: 'Engineering',
    teams: [
      { name: 'Frontend', members: [{ name: 'Alice', email: 'alice@ex.com' }] },
      { name: 'Backend', members: [{ name: 'Bob', email: 'bob@ex.com' }, { name: 'Alice', email: 'alice@ex.com' }] }
    ]
  },
  {
    department: 'Marketing',
    teams: [
      { name: 'Content', members: [{ name: 'Charlie', email: 'charlie@ex.com' }] }
    ]
  }
];

// Expected: ['alice@ex.com', 'bob@ex.com', 'charlie@ex.com']
```

**Solution:** See solutions file.

---

## Testing & Debugging

### Unit Testing with Vitest

```javascript
// array-methods.test.js
import { describe, it, expect } from 'vitest';

describe('Array Methods', () => {
  describe('map()', () => {
    it('should transform each element', () => {
      const numbers = [1, 2, 3];
      const doubled = numbers.map(n => n * 2);
      expect(doubled).toEqual([2, 4, 6]);
    });

    it('should not mutate original array', () => {
      const original = [1, 2, 3];
      const result = original.map(n => n * 2);
      expect(original).toEqual([1, 2, 3]);
    });
  });

  describe('filter()', () => {
    it('should keep elements that pass test', () => {
      const numbers = [1, 2, 3, 4, 5];
      const evens = numbers.filter(n => n % 2 === 0);
      expect(evens).toEqual([2, 4]);
    });
  });

  describe('reduce()', () => {
    it('should sum all numbers', () => {
      const numbers = [1, 2, 3, 4, 5];
      const sum = numbers.reduce((acc, n) => acc + n, 0);
      expect(sum).toBe(15);
    });

    it('should handle empty array with initial value', () => {
      const sum = [].reduce((acc, n) => acc + n, 0);
      expect(sum).toBe(0);
    });
  });
});
```

### Debugging Tips

```javascript
// Add logging in method chains
const result = numbers
  .filter(n => {
    console.log('Filtering:', n);
    return n % 2 === 0;
  })
  .map(n => {
    console.log('Mapping:', n);
    return n * 2;
  });

// Use intermediate variables
const filtered = numbers.filter(n => n % 2 === 0);
console.log('After filter:', filtered);

const mapped = filtered.map(n => n * 2);
console.log('After map:', mapped);

// Check array before/after
console.log('Before:', arr);
arr.sort((a, b) => a - b);
console.log('After:', arr);
```

---

## Best Practices

### 1. Choose the Right Method

```javascript
// ✅ Use map for transformation
const doubled = numbers.map(n => n * 2);

// ❌ Don't use forEach if you need a result
const doubled = [];
numbers.forEach(n => doubled.push(n * 2));

// ✅ Use filter for filtering
const evens = numbers.filter(n => n % 2 === 0);

// ❌ Don't use reduce for simple filtering
const evens = numbers.reduce((acc, n) => {
  if (n % 2 === 0) acc.push(n);
  return acc;
}, []);
```

### 2. Immutability

```javascript
// ✅ Don't mutate original arrays
const sorted = [...numbers].sort((a, b) => a - b);

// ❌ Avoid mutating
numbers.sort((a, b) => a - b); // Changes original!

// ✅ Modern immutable methods (ES2023)
const sorted = numbers.toSorted((a, b) => a - b);
const reversed = numbers.toReversed();
```

### 3. Early Returns

```javascript
// ✅ Use find() instead of filter()[0]
const user = users.find(u => u.id === 123);

// ❌ Less efficient
const user = users.filter(u => u.id === 123)[0];

// ✅ Use some() for existence check
const hasAdmin = users.some(u => u.admin);

// ❌ Wasteful
const hasAdmin = users.filter(u => u.admin).length > 0;
```

### 4. Readable Chains

```javascript
// ✅ Clear and readable
const result = products
  .filter(p => p.inStock)
  .filter(p => p.price < 100)
  .map(p => p.name)
  .sort();

// ❌ Too condensed
const result = products.filter(p=>p.inStock&&p.price<100).map(p=>p.name).sort();

// ✅ Extract complex logic
const isEligible = product => product.inStock && product.price < 100;
const result = products.filter(isEligible).map(p => p.name).sort();
```

---

## Common Pitfalls

### 1. Forgetting Return in map/filter

```javascript
// ❌ Wrong: no return statement
const doubled = numbers.map(n => { n * 2 }); // [undefined, undefined, ...]

// ✅ Correct: return statement
const doubled = numbers.map(n => { return n * 2 });

// ✅ Or use implicit return
const doubled = numbers.map(n => n * 2);
```

### 2. Sort Without Comparator

```javascript
// ❌ Wrong: string sort on numbers
[10, 2, 30].sort(); // [10, 2, 30]

// ✅ Correct: numeric comparator
[10, 2, 30].sort((a, b) => a - b); // [2, 10, 30]
```

### 3. Reduce Without Initial Value

```javascript
// ❌ Dangerous with empty arrays
[].reduce((acc, n) => acc + n); // TypeError!

// ✅ Safe: provide initial value
[].reduce((acc, n) => acc + n, 0); // 0
```

### 4. Mutating in forEach/map

```javascript
// ❌ Side effects in map
numbers.map(n => {
  externalArray.push(n); // Side effect!
  return n * 2;
});

// ✅ Pure function
const doubled = numbers.map(n => n * 2);
```

---

## When to Use Which Method

| Need to... | Use... | Returns... |
|------------|--------|------------|
| Transform each element | `map()` | New array (same length) |
| Keep some elements | `filter()` | New array (≤ length) |
| Get single value | `reduce()` | Any type |
| Find first match | `find()` | Element or undefined |
| Find first index | `findIndex()` | Index or -1 |
| Check if any match | `some()` | Boolean |
| Check if all match | `every()` | Boolean |
| Check existence | `includes()` | Boolean |
| Sort elements | `sort()` | Mutated array |
| Flatten one level | `flat()` | New array |
| Map and flatten | `flatMap()` | New array |

---

## Summary & Next Steps

### Key Takeaways

- **map()**: Transform each element, same length output
- **filter()**: Keep elements that pass test, ≤ length output
- **reduce()**: Aggregate to single value, most flexible
- **find()/some()/every()**: Short-circuit for efficiency
- **sort()**: Mutates array, needs comparator for numbers
- **Method chaining**: Compose operations declaratively
- **Performance**: Consider single-pass alternatives for large data

### Related Topics

- [Arrays Fundamentals](./07.Arrays_Fundamentals.md)
- [Objects Fundamentals](./09.Objects_Fundamentals.md)
- [Functional Programming Patterns](../advanced/functional-programming.md)

### Further Reading

- [MDN: Array Methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)
- [JavaScript.info: Array Methods](https://javascript.info/array-methods)
- [Functional Programming in JavaScript](https://mostly-adequate.gitbook.io/mostly-adequate-guide/)

---

## References

1. **MDN Web Docs**: [Array Methods Reference](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)
2. **ECMAScript Specification**: [Array.prototype Methods](https://tc39.es/ecma262/#sec-properties-of-the-array-prototype-object)
3. **JavaScript.info**: [Array Methods Tutorial](https://javascript.info/array-methods)
4. **V8 Blog**: [Fast Properties in V8](https://v8.dev/blog/fast-properties)

---

**Last Updated:** 2025-11-22
**Version:** 1.0.0
**Curriculum:** JavaScript for Backend Development
