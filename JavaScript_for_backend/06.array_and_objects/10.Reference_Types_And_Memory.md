# Reference Types and Memory Management

**Difficulty:** Intermediate to Advanced
**Estimated Time:** 60-75 minutes
**Prerequisites:** Arrays, objects, functions
**Target:** Node.js 18+ LTS, Modern Browsers (ES2021+)

---

## Learning Objectives

By the end of this lesson, you will be able to:

1. Distinguish between primitive and reference types in JavaScript
2. Understand pass-by-value vs pass-by-reference semantics
3. Recognize how object and array references behave in assignments and functions
4. Implement shallow and deep copy techniques correctly
5. Manage memory effectively and avoid memory leaks
6. Apply equality comparison operators appropriately (==, ===, Object.is)
7. Implement immutability patterns for safer code
8. Use Object.freeze(), Object.seal(), and Object.preventExtensions()
9. Understand WeakMap and WeakSet for memory-efficient caching
10. Optimize code for better memory and performance

---

## Table of Contents

1. [Introduction](#introduction)
2. [Primitive vs Reference Types](#primitive-vs-reference-types)
3. [Pass by Value vs Pass by Reference](#pass-by-value-vs-pass-by-reference)
4. [Object and Array References](#object-and-array-references)
5. [Shallow Copy vs Deep Copy](#shallow-copy-vs-deep-copy)
6. [Memory Management Basics](#memory-management-basics)
7. [Equality Comparisons](#equality-comparisons)
8. [Immutability Patterns](#immutability-patterns)
9. [Freezing and Sealing Objects](#freezing-and-sealing-objects)
10. [WeakMap and WeakSet](#weakmap-and-weakset)
11. [Performance Implications](#performance-implications)
12. [Worked Examples](#worked-examples)
13. [Exercises](#exercises)
14. [Testing & Debugging](#testing--debugging)
15. [Best Practices](#best-practices)
16. [Common Pitfalls](#common-pitfalls)
17. [Summary & Next Steps](#summary--next-steps)
18. [References](#references)

---

## Introduction

Understanding how JavaScript handles memory and references is crucial for writing efficient, bug-free code. Unlike languages with explicit memory management (C, C++), JavaScript uses automatic garbage collection, but developers still need to understand how values are stored and passed.

**Why This Matters:**

- **Bug Prevention:** Avoid unintended mutations and side effects
- **Performance:** Write memory-efficient code
- **Predictability:** Understand when values are shared vs copied
- **Debugging:** Quickly identify reference-related issues
- **Design Patterns:** Implement immutable data structures

In backend development (Node.js), proper memory management is critical for:
- Preventing memory leaks in long-running servers
- Handling large datasets efficiently
- Caching data without memory bloat
- Managing database connections and resources

---

## Primitive vs Reference Types

JavaScript has two categories of types: **primitives** and **reference types**.

### Primitive Types

Primitives are **immutable** values stored directly in the variable:

```javascript
// 7 primitive types
const str = 'hello';           // string
const num = 42;                // number
const bool = true;             // boolean
const undef = undefined;       // undefined
const nul = null;              // null
const sym = Symbol('id');      // symbol (ES6)
const bigInt = 9007199254740991n; // bigint (ES2020)

// Primitives are immutable
let text = 'hello';
text[0] = 'H';  // No effect
console.log(text); // 'hello' (unchanged)

// Primitives are copied by value
let a = 10;
let b = a;  // Copy the value
b = 20;
console.log(a); // 10 (unchanged)
console.log(b); // 20
```

### Reference Types

Reference types store a **reference (pointer)** to the actual data:

```javascript
// Reference types
const obj = {};              // object
const arr = [];              // array
const fn = function() {};    // function
const date = new Date();     // Date object
const regex = /pattern/;     // RegExp object
const map = new Map();       // Map
const set = new Set();       // Set

// References are copied, not the actual data
const obj1 = { name: 'Alice' };
const obj2 = obj1;  // Copy the reference
obj2.name = 'Bob';
console.log(obj1.name); // 'Bob' (both point to same object!)
console.log(obj2.name); // 'Bob'
```

### Comparison Table

| Feature | Primitive | Reference |
|---------|-----------|-----------|
| Storage | Value directly | Reference (pointer) |
| Mutability | Immutable | Mutable |
| Assignment | Copy value | Copy reference |
| Comparison | By value | By reference |
| Memory | Stack | Heap (reference on stack) |
| Examples | `42`, `'text'`, `true` | `{}`, `[]`, `function() {}` |

### Visual Representation

```javascript
// Primitives: Each variable has its own value
let x = 10;
let y = x;
// Memory: [x: 10] [y: 10] (separate values)

// References: Variables point to same object
let obj1 = { value: 10 };
let obj2 = obj1;
// Memory: [obj1: ref ‚Üí {value: 10}] [obj2: ref ‚Üí same object]
```

---

## Pass by Value vs Pass by Reference

### Pass by Value (Primitives)

Primitives are passed **by value** - a copy is created:

```javascript
function increment(num) {
  num = num + 1;
  console.log('Inside:', num); // Inside: 11
  return num;
}

let value = 10;
const result = increment(value);
console.log('Outside:', value);  // Outside: 10 (unchanged)
console.log('Result:', result);  // Result: 11
```

**What happens:**
1. `value` (10) is copied to parameter `num`
2. `num` is incremented (now 11)
3. Original `value` remains 10

### Pass by Reference (Objects/Arrays)

Objects are passed **by reference** - the reference is copied:

```javascript
function addProperty(obj) {
  obj.newProp = 'added';
  console.log('Inside:', obj); // { name: 'Alice', newProp: 'added' }
}

const person = { name: 'Alice' };
addProperty(person);
console.log('Outside:', person); // { name: 'Alice', newProp: 'added' } (modified!)
```

**What happens:**
1. Reference to `person` is copied to parameter `obj`
2. Both `person` and `obj` point to the same object
3. Modifications through `obj` affect the original object

### Reassignment vs Mutation

```javascript
// Mutation: Changes the object
function mutate(arr) {
  arr.push(4);  // Modifies original array
}

const numbers = [1, 2, 3];
mutate(numbers);
console.log(numbers); // [1, 2, 3, 4] (modified!)

// Reassignment: Doesn't affect original
function reassign(arr) {
  arr = [99, 100];  // Creates new array, doesn't affect original
  console.log('Inside:', arr); // Inside: [99, 100]
}

const values = [1, 2, 3];
reassign(values);
console.log('Outside:', values); // Outside: [1, 2, 3] (unchanged!)
```

**Key Insight:** You can modify the object a reference points to, but reassigning the reference doesn't affect the original variable.

### Practical Example: Function Parameters

```javascript
function processUser(user, age) {
  // Mutating object property (affects original)
  user.age = age;

  // Reassigning parameter (doesn't affect original)
  age = age + 1;

  console.log('Inside - user.age:', user.age); // 26
  console.log('Inside - age:', age);            // 27
}

const userData = { name: 'Alice', age: 25 };
let userAge = 25;

processUser(userData, userAge);

console.log('Outside - userData.age:', userData.age); // 26 (modified!)
console.log('Outside - userAge:', userAge);           // 25 (unchanged)
```

---

## Object and Array References

### Object References

```javascript
// Creating references
const original = { name: 'Alice', age: 25 };
const ref1 = original;
const ref2 = original;

// All point to the same object
console.log(ref1 === ref2); // true
console.log(ref1 === original); // true

// Mutation through any reference affects all
ref1.age = 26;
console.log(original.age); // 26
console.log(ref2.age);     // 26

// Creating a new object breaks the reference
ref1 = { name: 'Bob', age: 30 }; // ref1 now points to different object
console.log(original.name); // 'Alice' (unchanged)
```

### Array References

```javascript
const arr1 = [1, 2, 3];
const arr2 = arr1;

// Both reference same array
arr2.push(4);
console.log(arr1); // [1, 2, 3, 4]
console.log(arr2); // [1, 2, 3, 4]

// Array methods that mutate
arr1.sort();
arr1.reverse();
console.log(arr2); // [4, 3, 2, 1] (affected!)

// Array methods that return new arrays (don't mutate)
const arr3 = arr1.slice();  // New array
const arr4 = arr1.map(x => x * 2); // New array
arr3.push(5);
console.log(arr1); // [4, 3, 2, 1] (unchanged)
```

### Nested References

```javascript
const data = {
  user: {
    name: 'Alice',
    scores: [85, 90, 92]
  }
};

// Shallow reference
const userData = data.user;
userData.name = 'Bob';
console.log(data.user.name); // 'Bob' (modified!)

// Nested array reference
const scores = data.user.scores;
scores.push(95);
console.log(data.user.scores); // [85, 90, 92, 95] (modified!)
```

### Functions as References

```javascript
function greet() {
  console.log('Hello!');
}

const greet1 = greet;
const greet2 = greet;

console.log(greet1 === greet2); // true (same reference)

greet1(); // 'Hello!'
greet2(); // 'Hello!'
```

---

## Shallow Copy vs Deep Copy

### Shallow Copy

Copies the top-level properties, but nested objects are still referenced:

#### Method 1: Spread Operator

```javascript
const original = {
  name: 'Alice',
  age: 25,
  address: { city: 'NYC' }
};

const copy = { ...original };

// Top-level properties are independent
copy.name = 'Bob';
console.log(original.name); // 'Alice' (unchanged)

// ‚ö†Ô∏è Nested objects are still referenced!
copy.address.city = 'LA';
console.log(original.address.city); // 'LA' (modified!)
```

#### Method 2: Object.assign()

```javascript
const original = { a: 1, b: { c: 2 } };
const copy = Object.assign({}, original);

copy.a = 99;
console.log(original.a); // 1 (unchanged)

copy.b.c = 99;
console.log(original.b.c); // 99 (modified!)
```

#### Method 3: Array Shallow Copy

```javascript
const original = [1, 2, { value: 3 }];

// Spread
const copy1 = [...original];

// slice
const copy2 = original.slice();

// Array.from
const copy3 = Array.from(original);

// All are shallow copies
copy1[2].value = 99;
console.log(original[2].value); // 99 (all copies affected!)
```

### Deep Copy

Recursively copies all levels, creating completely independent objects:

#### Method 1: JSON.parse(JSON.stringify())

```javascript
const original = {
  name: 'Alice',
  age: 25,
  address: { city: 'NYC', zip: '10001' },
  scores: [85, 90, 92]
};

const deepCopy = JSON.parse(JSON.stringify(original));

deepCopy.address.city = 'LA';
deepCopy.scores.push(95);

console.log(original.address.city); // 'NYC' (unchanged!)
console.log(original.scores);       // [85, 90, 92] (unchanged!)

// ‚ö†Ô∏è Limitations:
// - Loses functions
// - Loses undefined values
// - Converts Date to string
// - Loses Symbol keys
// - Doesn't handle circular references
```

**Limitations Example:**

```javascript
const complex = {
  date: new Date(),
  fn: () => 'test',
  undef: undefined,
  sym: Symbol('test')
};

const copy = JSON.parse(JSON.stringify(complex));

console.log(copy.date instanceof Date); // false (it's a string!)
console.log(copy.fn);                   // undefined (lost!)
console.log('undef' in copy);           // false (lost!)
console.log(copy.sym);                  // undefined (lost!)
```

#### Method 2: Recursive Deep Copy

```javascript
function deepClone(obj) {
  // Handle primitives and null
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }

  // Handle Date
  if (obj instanceof Date) {
    return new Date(obj);
  }

  // Handle Array
  if (Array.isArray(obj)) {
    return obj.map(item => deepClone(item));
  }

  // Handle Object
  const clonedObj = {};
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      clonedObj[key] = deepClone(obj[key]);
    }
  }
  return clonedObj;
}

// Usage
const original = {
  name: 'Alice',
  date: new Date(),
  nested: { value: 42 },
  array: [1, { inner: 2 }]
};

const copy = deepClone(original);
copy.nested.value = 99;
console.log(original.nested.value); // 42 (unchanged!)
```

#### Method 3: structuredClone() (Modern)

Available in Node.js 17+ and modern browsers:

```javascript
const original = {
  name: 'Alice',
  date: new Date(),
  nested: { value: 42 },
  array: [1, 2, 3]
};

const copy = structuredClone(original);

copy.nested.value = 99;
console.log(original.nested.value); // 42 (unchanged!)

// ‚úÖ Handles Date, RegExp, Map, Set, etc.
// ‚ö†Ô∏è Still can't clone functions
// ‚ö†Ô∏è Can handle circular references!
```

#### Method 4: Lodash cloneDeep

```javascript
// npm install lodash
import _ from 'lodash';

const original = {
  name: 'Alice',
  nested: { value: 42 }
};

const copy = _.cloneDeep(original);
copy.nested.value = 99;
console.log(original.nested.value); // 42 (unchanged!)
```

### Comparison Table

| Method | Nested Objects | Functions | Dates | Circular Refs | Performance |
|--------|---------------|-----------|-------|---------------|-------------|
| Spread `{...}` | ‚ùå Referenced | ‚úÖ Copied | ‚ùå Referenced | ‚ùå No | ‚ö° Fast |
| `Object.assign()` | ‚ùå Referenced | ‚úÖ Copied | ‚ùå Referenced | ‚ùå No | ‚ö° Fast |
| `JSON.parse/stringify` | ‚úÖ Cloned | ‚ùå Lost | ‚ùå String | ‚ùå Error | üê¢ Slow |
| Recursive function | ‚úÖ Cloned | ‚úÖ Can handle | ‚úÖ Can handle | ‚ùå Stack overflow | üî∂ Medium |
| `structuredClone()` | ‚úÖ Cloned | ‚ùå Lost | ‚úÖ Cloned | ‚úÖ Yes | ‚ö° Fast |
| `_.cloneDeep()` | ‚úÖ Cloned | ‚úÖ Can handle | ‚úÖ Cloned | ‚úÖ Yes | üî∂ Medium |

---

## Memory Management Basics

### How JavaScript Manages Memory

JavaScript uses **automatic garbage collection** (mark-and-sweep algorithm):

1. **Allocation:** Memory is allocated when values are created
2. **Usage:** Memory is used when reading/writing values
3. **Deallocation:** Garbage collector automatically frees unused memory

### Stack vs Heap

```javascript
// Stack: Primitives and references
let num = 42;         // Value on stack
let str = 'hello';    // Value on stack
let obj = { a: 1 };   // Reference on stack ‚Üí object on heap

// Heap: Objects, arrays, functions
// { a: 1 } stored on heap
```

### Garbage Collection

Objects are garbage collected when they are no longer reachable:

```javascript
// Object is reachable
let user = { name: 'Alice' };

// Object becomes unreachable (eligible for GC)
user = null;

// Multiple references prevent GC
let obj1 = { value: 42 };
let obj2 = obj1;
obj1 = null;  // Object still reachable through obj2
obj2 = null;  // Now eligible for GC
```

### Memory Leaks

Common causes of memory leaks in JavaScript:

#### 1. Accidental Global Variables

```javascript
// ‚ùå Memory leak: accidental global
function leaky() {
  leakyVar = 'I leak!'; // No var/let/const
}

// ‚úÖ Fix: use strict mode and declarations
'use strict';
function safe() {
  const safeVar = 'No leak';
}
```

#### 2. Forgotten Timers/Callbacks

```javascript
// ‚ùå Memory leak: timer not cleared
const data = fetchLargeData();
setInterval(() => {
  console.log(data); // Keeps 'data' alive forever
}, 1000);

// ‚úÖ Fix: clear timer when done
const timerId = setInterval(() => {
  console.log(data);
}, 1000);

// Clear when component unmounts or data no longer needed
clearInterval(timerId);
```

#### 3. Closures Holding References

```javascript
// ‚ùå Memory leak: closure holds large object
function createHandler() {
  const largeData = new Array(1000000).fill('data');

  return function() {
    console.log('Handler called');
    // largeData is in closure scope even if not used!
  };
}

const handler = createHandler(); // largeData can't be GC'd

// ‚úÖ Fix: don't capture unnecessary variables
function createHandlerFixed() {
  const largeData = new Array(1000000).fill('data');
  const summary = largeData.length; // Extract only what you need

  return function() {
    console.log('Handler called', summary);
    // largeData can be GC'd
  };
}
```

#### 4. Detached DOM Nodes

```javascript
// ‚ùå Memory leak: removed DOM nodes still referenced
const elements = [];

function addElement() {
  const div = document.createElement('div');
  document.body.appendChild(div);
  elements.push(div); // Keep reference
}

function removeElement() {
  const div = elements.pop();
  div.remove(); // Removed from DOM but still in array!
}

// ‚úÖ Fix: clear references
function removeElementFixed() {
  const div = elements.pop();
  div.remove();
  // Don't keep reference, or set to null
}
```

### Monitoring Memory Usage (Node.js)

```javascript
// Check memory usage
const used = process.memoryUsage();
console.log({
  heapUsed: `${Math.round(used.heapUsed / 1024 / 1024)} MB`,
  heapTotal: `${Math.round(used.heapTotal / 1024 / 1024)} MB`,
  external: `${Math.round(used.external / 1024 / 1024)} MB`,
  rss: `${Math.round(used.rss / 1024 / 1024)} MB`
});

// Force garbage collection (requires --expose-gc flag)
// node --expose-gc app.js
if (global.gc) {
  global.gc();
  console.log('Garbage collection triggered');
}
```

---

## Equality Comparisons

### == (Loose Equality)

Performs type coercion before comparison:

```javascript
// Type coercion examples
console.log(5 == '5');        // true (string ‚Üí number)
console.log(true == 1);       // true (boolean ‚Üí number)
console.log(false == 0);      // true
console.log(null == undefined); // true
console.log([] == false);     // true

// ‚ùå Avoid == due to unpredictable coercion
```

### === (Strict Equality)

No type coercion - recommended:

```javascript
console.log(5 === '5');       // false (different types)
console.log(true === 1);      // false
console.log(null === undefined); // false

// Objects compared by reference
const obj1 = { a: 1 };
const obj2 = { a: 1 };
const obj3 = obj1;

console.log(obj1 === obj2);   // false (different objects)
console.log(obj1 === obj3);   // true (same reference)

// Arrays compared by reference
console.log([1, 2] === [1, 2]); // false (different arrays)
console.log([] === []);          // false
```

### Object.is()

Similar to ===, but handles edge cases:

```javascript
// Same as === for most cases
console.log(Object.is(5, 5));    // true
console.log(Object.is(5, '5'));  // false

// Differences from ===
console.log(NaN === NaN);         // false
console.log(Object.is(NaN, NaN)); // true ‚úÖ

console.log(+0 === -0);           // true
console.log(Object.is(+0, -0));   // false ‚úÖ
```

### Deep Equality

For comparing object/array contents:

```javascript
// Custom deep equal function
function deepEqual(a, b) {
  // Same reference
  if (a === b) return true;

  // Different types or one is null
  if (typeof a !== 'object' || typeof b !== 'object' || a === null || b === null) {
    return false;
  }

  // Arrays
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) return false;
    return a.every((item, i) => deepEqual(item, b[i]));
  }

  // Objects
  const keysA = Object.keys(a);
  const keysB = Object.keys(b);

  if (keysA.length !== keysB.length) return false;

  return keysA.every(key => deepEqual(a[key], b[key]));
}

// Usage
const obj1 = { a: 1, b: { c: 2 } };
const obj2 = { a: 1, b: { c: 2 } };

console.log(obj1 === obj2);           // false (different references)
console.log(deepEqual(obj1, obj2));   // true (same contents)

// Libraries: lodash _.isEqual(), fast-deep-equal
```

---

## Immutability Patterns

Immutability prevents unintended mutations:

### Why Immutability?

- **Predictability:** No unexpected side effects
- **Debugging:** Easier to track changes
- **Performance:** Enable efficient change detection
- **Concurrency:** Safe for parallel processing
- **Undo/Redo:** Keep history of states

### Immutable Arrays

```javascript
const original = [1, 2, 3];

// ‚ùå Mutating methods
original.push(4);        // Mutates
original.pop();          // Mutates
original.sort();         // Mutates
original.reverse();      // Mutates

// ‚úÖ Non-mutating alternatives
const added = [...original, 4];              // Add to end
const removed = original.slice(0, -1);       // Remove last
const sorted = [...original].sort();         // Sort
const reversed = [...original].reverse();    // Reverse

// Map, filter, reduce (non-mutating)
const doubled = original.map(x => x * 2);
const evens = original.filter(x => x % 2 === 0);
const sum = original.reduce((a, b) => a + b);
```

### Immutable Objects

```javascript
const original = { name: 'Alice', age: 25 };

// ‚ùå Mutation
original.age = 26;
original.city = 'NYC';
delete original.age;

// ‚úÖ Non-mutating updates
const updated = { ...original, age: 26 };
const withCity = { ...original, city: 'NYC' };
const { age, ...withoutAge } = original;

// Nested updates
const user = {
  name: 'Alice',
  address: { city: 'NYC', zip: '10001' }
};

// ‚ùå Mutating nested
user.address.city = 'LA';

// ‚úÖ Immutable nested update
const updatedUser = {
  ...user,
  address: {
    ...user.address,
    city: 'LA'
  }
};
```

### Immutable Update Patterns

```javascript
// Array update by index
const updateArrayIndex = (arr, index, value) => [
  ...arr.slice(0, index),
  value,
  ...arr.slice(index + 1)
];

const numbers = [1, 2, 3, 4, 5];
const updated = updateArrayIndex(numbers, 2, 99);
console.log(updated); // [1, 2, 99, 4, 5]

// Array remove by index
const removeArrayIndex = (arr, index) => [
  ...arr.slice(0, index),
  ...arr.slice(index + 1)
];

// Nested object update
const updateNested = (obj, path, value) => {
  const [first, ...rest] = path;

  return {
    ...obj,
    [first]: rest.length === 0
      ? value
      : updateNested(obj[first], rest, value)
  };
};

const state = {
  user: {
    profile: {
      name: 'Alice'
    }
  }
};

const newState = updateNested(state, ['user', 'profile', 'name'], 'Bob');
```

### Immer Library (Recommended)

```javascript
// npm install immer
import produce from 'immer';

const state = {
  users: [
    { id: 1, name: 'Alice', age: 25 }
  ]
};

// Write code that looks like mutations, but is actually immutable
const newState = produce(state, draft => {
  draft.users[0].age = 26;
  draft.users.push({ id: 2, name: 'Bob', age: 30 });
});

console.log(state.users[0].age);     // 25 (unchanged!)
console.log(newState.users[0].age);  // 26
```

---

## Freezing and Sealing Objects

### Object.freeze()

Prevents all modifications (immutable):

```javascript
const user = Object.freeze({
  name: 'Alice',
  age: 25
});

// ‚ùå All modifications fail silently (or throw in strict mode)
user.age = 26;              // No effect
user.email = 'alice@ex.com'; // No effect
delete user.age;             // No effect

console.log(user); // { name: 'Alice', age: 25 } (unchanged)

// Check if frozen
console.log(Object.isFrozen(user)); // true

// ‚ö†Ô∏è Shallow freeze: nested objects not frozen
const data = Object.freeze({
  user: { name: 'Alice' }
});

data.user.name = 'Bob'; // Works! (nested object not frozen)
```

### Deep Freeze

```javascript
function deepFreeze(obj) {
  // Freeze the object itself
  Object.freeze(obj);

  // Recursively freeze properties
  Object.keys(obj).forEach(key => {
    if (obj[key] !== null && typeof obj[key] === 'object') {
      deepFreeze(obj[key]);
    }
  });

  return obj;
}

const config = deepFreeze({
  app: {
    name: 'MyApp',
    settings: {
      theme: 'dark'
    }
  }
});

// ‚ùå All levels are frozen
config.app.settings.theme = 'light'; // No effect
```

### Object.seal()

Prevents adding/removing properties, but allows modification:

```javascript
const user = Object.seal({
  name: 'Alice',
  age: 25
});

// ‚úÖ Can modify existing properties
user.age = 26;
console.log(user.age); // 26

// ‚ùå Can't add new properties
user.email = 'alice@ex.com';
console.log(user.email); // undefined

// ‚ùå Can't delete properties
delete user.age;
console.log(user.age); // 26 (still exists)

console.log(Object.isSealed(user)); // true
```

### Object.preventExtensions()

Only prevents adding new properties:

```javascript
const user = Object.preventExtensions({
  name: 'Alice',
  age: 25
});

// ‚úÖ Can modify
user.age = 26;

// ‚úÖ Can delete
delete user.age;

// ‚ùå Can't add
user.email = 'alice@ex.com';
console.log(user.email); // undefined

console.log(Object.isExtensible(user)); // false
```

### Comparison Table

| Method | Add Props | Delete Props | Modify Props | Configurable |
|--------|-----------|--------------|--------------|--------------|
| None | ‚úÖ Yes | ‚úÖ Yes | ‚úÖ Yes | ‚úÖ Yes |
| `preventExtensions()` | ‚ùå No | ‚úÖ Yes | ‚úÖ Yes | ‚úÖ Yes |
| `seal()` | ‚ùå No | ‚ùå No | ‚úÖ Yes | ‚ùå No |
| `freeze()` | ‚ùå No | ‚ùå No | ‚ùå No | ‚ùå No |

---

## WeakMap and WeakSet

### WeakMap

Keys must be objects and are weakly referenced (garbage collectable):

```javascript
const cache = new WeakMap();

let user = { id: 1, name: 'Alice' };

// Store data associated with object
cache.set(user, { lastAccess: new Date(), count: 0 });

// Retrieve data
const userData = cache.get(user);
console.log(userData); // { lastAccess: ..., count: 0 }

// When object is no longer referenced, entry is GC'd
user = null; // Cache entry becomes eligible for GC

// ‚ö†Ô∏è No iteration: can't enumerate keys
// cache.keys() - doesn't exist
// cache.forEach() - doesn't exist
```

**Use Cases:**
- Caching computed values
- Storing private data
- Managing DOM node metadata

```javascript
// Example: Caching expensive computations
const expensiveCache = new WeakMap();

function expensiveOperation(obj) {
  if (expensiveCache.has(obj)) {
    console.log('Cache hit!');
    return expensiveCache.get(obj);
  }

  console.log('Cache miss - computing...');
  const result = /* expensive computation */;
  expensiveCache.set(obj, result);
  return result;
}

const data = { values: [1, 2, 3, 4, 5] };
expensiveOperation(data); // Cache miss
expensiveOperation(data); // Cache hit!
```

### WeakSet

Stores objects weakly:

```javascript
const visited = new WeakSet();

let page1 = { url: '/home' };
let page2 = { url: '/about' };

// Mark as visited
visited.add(page1);

// Check if visited
console.log(visited.has(page1)); // true
console.log(visited.has(page2)); // false

// When object is dereferenced, it's removed from WeakSet
page1 = null; // Entry becomes eligible for GC

// ‚ö†Ô∏è No iteration
// visited.forEach() - doesn't exist
```

**Use Cases:**
- Tracking object states
- Preventing circular references
- Managing object metadata

### Map/Set vs WeakMap/WeakSet

| Feature | Map/Set | WeakMap/WeakSet |
|---------|---------|-----------------|
| Key types | Any | Objects only |
| Garbage collection | Keys kept alive | Keys can be GC'd |
| Iteration | ‚úÖ Yes | ‚ùå No |
| Size property | ‚úÖ Yes | ‚ùå No |
| Use case | General purpose | Memory-sensitive caching |

---

## Performance Implications

### Memory Benchmarking

```javascript
// Measure memory before
const memBefore = process.memoryUsage().heapUsed;

// Create large data structure
const largeArray = new Array(1000000).fill({ value: 42 });

// Measure memory after
const memAfter = process.memoryUsage().heapUsed;
const usedMB = (memAfter - memBefore) / 1024 / 1024;
console.log(`Memory used: ${usedMB.toFixed(2)} MB`);
```

### Efficient Data Structures

```javascript
// ‚ùå Memory-intensive: large arrays of objects
const inefficient = Array.from({ length: 100000 }, (_, i) => ({
  id: i,
  value: i * 2,
  timestamp: Date.now()
}));

// ‚úÖ Memory-efficient: typed arrays for numeric data
const efficient = {
  ids: new Uint32Array(100000),
  values: new Float64Array(100000),
  timestamps: new Float64Array(100000)
};

for (let i = 0; i < 100000; i++) {
  efficient.ids[i] = i;
  efficient.values[i] = i * 2;
  efficient.timestamps[i] = Date.now();
}
```

### Optimization Tips

```javascript
// 1. Reuse objects instead of creating new ones
const reusableConfig = { /* ... */ };
function process() {
  return reusableConfig; // Don't create new object each call
}

// 2. Use object pools for frequently created/destroyed objects
class ObjectPool {
  constructor(createFn, resetFn) {
    this.createFn = createFn;
    this.resetFn = resetFn;
    this.pool = [];
  }

  acquire() {
    return this.pool.length > 0 ? this.pool.pop() : this.createFn();
  }

  release(obj) {
    this.resetFn(obj);
    this.pool.push(obj);
  }
}

// 3. Clear large data structures when done
let largeData = fetchLargeData();
// ... use data ...
largeData = null; // Help GC

// 4. Use WeakMap for caching
const cache = new WeakMap(); // Auto-cleanup

// 5. Avoid accidental closures
function createHandlers() {
  const largeData = loadData(); // 10MB

  // ‚ùå All handlers capture largeData
  return {
    onClick: () => console.log('click'),
    onHover: () => console.log('hover')
  };

  // ‚úÖ Extract only what's needed
  const summary = largeData.summary;
  return {
    onClick: () => console.log('click', summary),
    onHover: () => console.log('hover')
  };
}
```

---

## Worked Examples

### Example 1: Reference Issues in Loops (Intermediate)

```javascript
/**
 * Common Reference Problem: Sharing objects in loops
 */

// ‚ùå Problem: All items reference same object
function createUsersWrong(count) {
  const users = [];
  const template = { role: 'user', active: true };

  for (let i = 0; i < count; i++) {
    template.id = i;
    template.name = `User ${i}`;
    users.push(template); // All reference same object!
  }

  return users;
}

const badUsers = createUsersWrong(3);
console.log(badUsers[0]);  // { id: 2, name: 'User 2', ... }
console.log(badUsers[1]);  // { id: 2, name: 'User 2', ... } Same!
console.log(badUsers[2]);  // { id: 2, name: 'User 2', ... } Same!

// ‚úÖ Solution: Create new object each iteration
function createUsersCorrect(count) {
  const users = [];

  for (let i = 0; i < count; i++) {
    users.push({
      id: i,
      name: `User ${i}`,
      role: 'user',
      active: true
    });
  }

  return users;
}

const goodUsers = createUsersCorrect(3);
console.log(goodUsers[0]); // { id: 0, name: 'User 0', ... }
console.log(goodUsers[1]); // { id: 1, name: 'User 1', ... }
console.log(goodUsers[2]); // { id: 2, name: 'User 2', ... }
```

### Example 2: Immutable State Manager (Advanced)

```javascript
/**
 * Immutable State Management
 * Similar to Redux pattern
 */

class StateManager {
  constructor(initialState = {}) {
    this._state = Object.freeze(this._deepFreeze(initialState));
    this._listeners = [];
  }

  getState() {
    return this._state;
  }

  setState(updates) {
    // Create new state (immutable)
    const newState = this._merge(this._state, updates);
    this._state = Object.freeze(this._deepFreeze(newState));

    // Notify listeners
    this._listeners.forEach(listener => listener(this._state));
  }

  subscribe(listener) {
    this._listeners.push(listener);

    // Return unsubscribe function
    return () => {
      const index = this._listeners.indexOf(listener);
      if (index > -1) {
        this._listeners.splice(index, 1);
      }
    };
  }

  _merge(target, source) {
    const result = { ...target };

    for (const key in source) {
      if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
        result[key] = this._merge(target[key] || {}, source[key]);
      } else {
        result[key] = source[key];
      }
    }

    return result;
  }

  _deepFreeze(obj) {
    Object.freeze(obj);

    Object.keys(obj).forEach(key => {
      if (obj[key] !== null && typeof obj[key] === 'object') {
        this._deepFreeze(obj[key]);
      }
    });

    return obj;
  }
}

// Usage
const store = new StateManager({
  user: { name: 'Alice', age: 25 },
  settings: { theme: 'dark' }
});

const unsubscribe = store.subscribe(state => {
  console.log('State changed:', state);
});

store.setState({
  user: { age: 26 }  // Merges with existing user
});

// State is immutable
const state = store.getState();
// state.user.name = 'Bob'; // Error in strict mode

unsubscribe();
```

### Example 3: Memory-Efficient Cache (Complex)

```javascript
/**
 * LRU Cache with WeakMap for automatic cleanup
 */

class LRUCache {
  constructor(maxSize = 100) {
    this.maxSize = maxSize;
    this.cache = new Map();
    this.metadata = new WeakMap();
  }

  get(key) {
    if (!this.cache.has(key)) {
      return undefined;
    }

    // Move to end (most recently used)
    const value = this.cache.get(key);
    this.cache.delete(key);
    this.cache.set(key, value);

    return value;
  }

  set(key, value) {
    // Remove if exists
    if (this.cache.has(key)) {
      this.cache.delete(key);
    }

    // Add to end
    this.cache.set(key, value);

    // Store metadata if value is object
    if (typeof value === 'object' && value !== null) {
      this.metadata.set(value, {
        added: new Date(),
        accessCount: 0
      });
    }

    // Remove oldest if over size
    if (this.cache.size > this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
  }

  has(key) {
    return this.cache.has(key);
  }

  clear() {
    this.cache.clear();
    // metadata automatically cleaned up via WeakMap
  }

  size() {
    return this.cache.size;
  }
}

// Usage
const cache = new LRUCache(3);

cache.set('a', { data: 'A' });
cache.set('b', { data: 'B' });
cache.set('c', { data: 'C' });
cache.set('d', { data: 'D' }); // 'a' removed (LRU)

console.log(cache.has('a')); // false
console.log(cache.has('d')); // true
```

---

## Exercises

### Exercise 1: Reference Basics (Easy)

**Task:** Predict the output and explain why:

```javascript
const obj1 = { value: 10 };
const obj2 = obj1;
const obj3 = { value: 10 };

obj2.value = 20;

console.log(obj1.value); // ?
console.log(obj2.value); // ?
console.log(obj3.value); // ?
console.log(obj1 === obj2); // ?
console.log(obj1 === obj3); // ?
```

**Solution:** See `solutions/10_reference_types_solutions.js`

---

### Exercise 2: Deep Clone Implementation (Medium)

**Task:** Implement `deepClone(obj)` that handles:
- Nested objects and arrays
- Dates
- null and undefined
- Circular references (bonus)

**Solution:** See solutions file.

---

### Exercise 3: Immutable Update (Medium)

**Task:** Write functions for immutable array/object updates:
- `updateArrayItem(arr, index, value)` - update array item
- `removeArrayItem(arr, index)` - remove array item
- `updateNestedProperty(obj, path, value)` - update nested object property

```javascript
// Examples
const arr = [1, 2, 3];
updateArrayItem(arr, 1, 99); // [1, 99, 3]

const obj = { user: { profile: { name: 'Alice' } } };
updateNestedProperty(obj, ['user', 'profile', 'name'], 'Bob');
// { user: { profile: { name: 'Bob' } } }
```

**Solution:** See solutions file.

---

### Exercise 4: Memory Leak Detection (Medium)

**Task:** Identify and fix memory leaks in this code:

```javascript
class DataProcessor {
  constructor() {
    this.data = [];
    this.listeners = [];

    setInterval(() => {
      this.data.push(new Array(1000).fill(Math.random()));
    }, 100);
  }

  subscribe(callback) {
    this.listeners.push(callback);
  }

  process() {
    this.listeners.forEach(listener => listener(this.data));
  }
}
```

**Solution:** See solutions file.

---

### Exercise 5: Equality Comparison (Easy)

**Task:** Implement `shallowEqual(obj1, obj2)` and `deepEqual(obj1, obj2)`.

**Solution:** See solutions file.

---

### Exercise 6: Object Pool (Hard)

**Task:** Implement a generic object pool:
```javascript
const pool = new ObjectPool(
  () => ({ x: 0, y: 0 }),  // createFn
  (obj) => { obj.x = 0; obj.y = 0; }  // resetFn
);

const obj1 = pool.acquire();
obj1.x = 10;
pool.release(obj1);

const obj2 = pool.acquire(); // Reuses obj1
```

**Solution:** See solutions file.

---

### Exercise 7: Immutable Data Structure (Hard)

**Task:** Implement an immutable List class with methods:
- `push(value)` - returns new list
- `pop()` - returns new list
- `get(index)` - returns value
- `set(index, value)` - returns new list
- `map(fn)` - returns new list

All methods must return new instances without mutating the original.

**Solution:** See solutions file.

---

## Testing & Debugging

### Testing Reference Behavior

```javascript
import { describe, it, expect } from 'vitest';

describe('Reference Types', () => {
  it('should pass objects by reference', () => {
    const original = { value: 10 };
    const ref = original;

    ref.value = 20;

    expect(original.value).toBe(20);
    expect(ref).toBe(original);
  });

  it('should create independent copies with spread', () => {
    const original = { value: 10 };
    const copy = { ...original };

    copy.value = 20;

    expect(original.value).toBe(10);
    expect(copy).not.toBe(original);
  });

  it('should handle nested objects correctly', () => {
    const original = { nested: { value: 10 } };
    const copy = { ...original };

    copy.nested.value = 20;

    expect(original.nested.value).toBe(20); // Shallow copy!
  });
});
```

### Debugging Memory Issues

```javascript
// Monitor heap usage
function monitorMemory(label) {
  const used = process.memoryUsage();
  console.log(`[${label}] Heap: ${Math.round(used.heapUsed / 1024 / 1024)} MB`);
}

monitorMemory('Start');
const largeArray = new Array(1000000).fill({ data: 'test' });
monitorMemory('After creation');
largeArray.length = 0;
monitorMemory('After clear');
if (global.gc) global.gc();
monitorMemory('After GC');

// Chrome DevTools (browser)
// 1. Open DevTools ‚Üí Memory tab
// 2. Take heap snapshot
// 3. Compare snapshots to find leaks
```

---

## Best Practices

### 1. Understand Value vs Reference

```javascript
// ‚úÖ Know when you're creating copies
const num = 10;
const numCopy = num; // Copy value

const obj = { a: 1 };
const objRef = obj; // Copy reference!
```

### 2. Prefer Immutability

```javascript
// ‚úÖ Don't mutate
const newArr = [...oldArr, item];
const newObj = { ...oldObj, key: value };

// ‚ùå Avoid mutation
oldArr.push(item);
oldObj.key = value;
```

### 3. Use Appropriate Cloning

```javascript
// ‚úÖ Shallow copy for flat structures
const copy = { ...original };

// ‚úÖ Deep copy for nested structures
const deepCopy = structuredClone(original);
```

### 4. Clean Up References

```javascript
// ‚úÖ Clear references when done
let data = loadLargeData();
// ... use data ...
data = null;

// ‚úÖ Use WeakMap for auto-cleanup
const cache = new WeakMap();
```

### 5. Validate Before Freezing

```javascript
// ‚úÖ Freeze after validation
const config = validateConfig(rawConfig);
Object.freeze(config);
```

---

## Common Pitfalls

### 1. Unexpected Mutations

```javascript
// ‚ùå Function mutates argument
function addItem(arr, item) {
  arr.push(item);
  return arr;
}

// ‚úÖ Return new array
function addItem(arr, item) {
  return [...arr, item];
}
```

### 2. Shallow Copy Traps

```javascript
// ‚ùå Shallow copy doesn't clone nested
const copy = { ...original };
copy.nested.value = 'changed'; // Affects original!

// ‚úÖ Deep copy nested structures
const copy = {
  ...original,
  nested: { ...original.nested }
};
```

### 3. Comparing Objects

```javascript
// ‚ùå Always false for different objects
console.log({ a: 1 } === { a: 1 }); // false

// ‚úÖ Compare properties
function equals(obj1, obj2) {
  return JSON.stringify(obj1) === JSON.stringify(obj2);
}
```

### 4. Closures Capturing References

```javascript
// ‚ùå All functions reference same object
const funcs = [];
for (let i = 0; i < 3; i++) {
  const obj = { value: i };
  funcs.push(() => console.log(obj.value));
}

obj.value = 99; // Affects all closures!

// ‚úÖ Create new object per iteration
```

---

## Summary & Next Steps

### Key Takeaways

- **Primitives vs References:** Understand how values are stored and passed
- **Pass by Reference:** Objects/arrays share references in assignments/functions
- **Shallow vs Deep Copy:** Choose appropriate cloning method
- **Memory Management:** Clean up references, avoid leaks
- **Equality:** Use `===` for references, deep equality for contents
- **Immutability:** Prefer non-mutating operations
- **Freeze/Seal:** Control object mutability
- **WeakMap/WeakSet:** Memory-efficient caching

### Related Topics

- [Arrays Fundamentals](./07.Arrays_Fundamentals.md)
- [Objects Fundamentals](./09.Objects_Fundamentals.md)
- [Advanced Array Methods](./08.Array_Methods_Advanced.md)

### Further Reading

- [MDN: Memory Management](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management)
- [V8 Blog: Garbage Collection](https://v8.dev/blog/trash-talk)
- [Immutable.js Documentation](https://immutable-js.com/)

---

## References

1. **MDN Web Docs**: [JavaScript Memory Management](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management)
2. **V8 Blog**: [Concurrent Marking](https://v8.dev/blog/concurrent-marking)
3. **JavaScript.info**: [Garbage Collection](https://javascript.info/garbage-collection)
4. **Node.js Docs**: [Memory Usage](https://nodejs.org/api/process.html#process_process_memoryusage)

---

**Last Updated:** 2025-11-22
**Version:** 1.0.0
**Curriculum:** JavaScript for Backend Development
