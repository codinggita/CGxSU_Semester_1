# Arrays Fundamentals in JavaScript

**Difficulty:** Introductory to Intermediate
**Estimated Time:** 45-60 minutes
**Prerequisites:** Basic JavaScript knowledge, variables, data types
**Target:** Node.js 18+ LTS, Modern Browsers (ES2021+)

---

## Learning Objectives

By the end of this lesson, you will be able to:

1. Create and initialize arrays using multiple methods
2. Access, update, and manipulate array elements using indexing
3. Apply core array methods (push, pop, shift, unshift, concat, slice, splice)
4. Iterate through arrays using forEach, for...of, and traditional loops
5. Work with multi-dimensional arrays for complex data structures
6. Use modern ES6+ features: destructuring and spread operator
7. Understand shallow vs deep cloning and their implications
8. Implement common array patterns in real-world scenarios
9. Avoid common pitfalls and write efficient array code
10. Test and debug array operations effectively

---

## Table of Contents

1. [Introduction](#introduction)
2. [What Are Arrays?](#what-are-arrays)
3. [Array Creation and Initialization](#array-creation-and-initialization)
4. [Array Indexing and Length](#array-indexing-and-length)
5. [Adding and Removing Elements](#adding-and-removing-elements)
6. [Array Methods: concat, slice, splice](#array-methods-concat-slice-splice)
7. [Array Iteration](#array-iteration)
8. [Multi-dimensional Arrays](#multi-dimensional-arrays)
9. [Array Destructuring](#array-destructuring)
10. [Spread Operator with Arrays](#spread-operator-with-arrays)
11. [Array Cloning (Shallow vs Deep)](#array-cloning-shallow-vs-deep)
12. [Common Array Patterns](#common-array-patterns)
13. [Worked Examples](#worked-examples)
14. [Exercises](#exercises)
15. [Testing & Verification](#testing--verification)
16. [Best Practices](#best-practices)
17. [Common Pitfalls](#common-pitfalls)
18. [Performance Considerations](#performance-considerations)
19. [Summary & Next Steps](#summary--next-steps)
20. [References](#references)

---

## Introduction

Arrays are one of JavaScript's most fundamental and versatile data structures. They provide an ordered way to store collections of values, making them essential for handling lists, queues, stacks, and complex data structures.

**Why Arrays Matter:**

- **Data Organization:** Store related values in a single variable
- **Iteration:** Process multiple values efficiently
- **Dynamic Size:** Automatically grow or shrink as needed
- **Versatility:** Hold any data type (numbers, strings, objects, other arrays)
- **Built-in Methods:** Rich API for manipulation and transformation
- **Backend Development:** Handle API responses, database results, user lists, etc.

In backend JavaScript (Node.js), arrays are used extensively for:
- Processing database query results
- Managing collections of users, products, or records
- Handling API request/response data
- Implementing queues and buffers
- Data transformation and aggregation

---

## What Are Arrays?

An **array** is an ordered, zero-indexed collection of values. Each value in an array is called an **element**, and each element has a numeric **index** representing its position.

### Key Characteristics

```javascript
const fruits = ['apple', 'banana', 'cherry'];

// Zero-indexed: first element is at index 0
console.log(fruits[0]); // 'apple'
console.log(fruits[1]); // 'banana'
console.log(fruits[2]); // 'cherry'

// Arrays have a length property
console.log(fruits.length); // 3

// Arrays can hold mixed types (though not recommended)
const mixed = [42, 'hello', true, null, { name: 'Alice' }];
```

### Arrays vs Objects

| Feature | Array | Object |
|---------|-------|--------|
| Structure | Ordered list | Key-value pairs |
| Indexing | Numeric (0, 1, 2...) | String keys |
| Iteration Order | Guaranteed | Not guaranteed (pre-ES6) |
| Use Case | Lists, sequences | Entities, records |
| Length | Has `.length` | No built-in length |

---

## Array Creation and Initialization

### Method 1: Array Literal (Recommended)

The most common and recommended way to create arrays:

```javascript
// Empty array
const empty = [];

// Array with initial values
const numbers = [1, 2, 3, 4, 5];
const names = ['Alice', 'Bob', 'Charlie'];

// Mixed types (use with caution)
const mixed = [42, 'text', true, null];
```

### Method 2: Array Constructor

```javascript
// Empty array with specified length
const arr1 = new Array(5); // Creates [empty × 5]
console.log(arr1.length); // 5
console.log(arr1[0]); // undefined

// Array with initial values
const arr2 = new Array(1, 2, 3); // [1, 2, 3]

// ⚠️ Pitfall: Single numeric argument creates length, not element
const arr3 = new Array(5); // [empty × 5], NOT [5]
const arr4 = new Array('5'); // ['5'] - string is treated as element
```

**Best Practice:** Prefer array literals `[]` for clarity and consistency.

### Method 3: Array.of() (ES6)

Solves the constructor ambiguity:

```javascript
const arr1 = Array.of(5); // [5]
const arr2 = Array.of(1, 2, 3); // [1, 2, 3]
const arr3 = Array.of(); // []
```

### Method 4: Array.from() (ES6)

Creates arrays from array-like or iterable objects:

```javascript
// From string
const chars = Array.from('hello'); // ['h', 'e', 'l', 'l', 'o']

// From Set
const set = new Set([1, 2, 3, 2, 1]);
const uniqueNums = Array.from(set); // [1, 2, 3]

// With mapping function
const doubled = Array.from([1, 2, 3], x => x * 2); // [2, 4, 6]

// Create range
const range = Array.from({ length: 5 }, (_, i) => i); // [0, 1, 2, 3, 4]
```

---

## Array Indexing and Length

### Zero-Based Indexing

Arrays use zero-based indexing: the first element is at index 0.

```javascript
const colors = ['red', 'green', 'blue'];

// Accessing elements
console.log(colors[0]); // 'red'
console.log(colors[1]); // 'green'
console.log(colors[2]); // 'blue'

// Accessing non-existent index
console.log(colors[10]); // undefined (no error!)

// Negative indices don't work natively (unlike Python)
console.log(colors[-1]); // undefined
```

### Updating Elements

```javascript
const numbers = [10, 20, 30];

// Update existing element
numbers[1] = 25;
console.log(numbers); // [10, 25, 30]

// Add element at specific index
numbers[3] = 40;
console.log(numbers); // [10, 25, 30, 40]

// Creating sparse array (avoid!)
numbers[10] = 100;
console.log(numbers); // [10, 25, 30, 40, empty × 6, 100]
console.log(numbers.length); // 11
```

### The length Property

```javascript
const arr = [1, 2, 3, 4, 5];

// Get length
console.log(arr.length); // 5

// Length is writable (can truncate array)
arr.length = 3;
console.log(arr); // [1, 2, 3] - elements removed!

// Setting length to 0 clears array
arr.length = 0;
console.log(arr); // []

// Access last element
const last = arr[arr.length - 1];

// Common pattern: add to end
arr[arr.length] = newValue; // Less common, prefer push()
```

---

## Adding and Removing Elements

### push() - Add to End

Adds one or more elements to the end and returns the new length.

```javascript
const stack = [1, 2, 3];

stack.push(4);
console.log(stack); // [1, 2, 3, 4]

// Add multiple elements
stack.push(5, 6, 7);
console.log(stack); // [1, 2, 3, 4, 5, 6, 7]

// Returns new length
const newLength = stack.push(8);
console.log(newLength); // 8

// ⚠️ Mutates original array
```

### pop() - Remove from End

Removes and returns the last element.

```javascript
const stack = [1, 2, 3, 4, 5];

const last = stack.pop();
console.log(last); // 5
console.log(stack); // [1, 2, 3, 4]

// Pop from empty array
const empty = [];
console.log(empty.pop()); // undefined (no error)

// ⚠️ Mutates original array
```

### unshift() - Add to Beginning

Adds one or more elements to the beginning.

```javascript
const queue = [2, 3, 4];

queue.unshift(1);
console.log(queue); // [1, 2, 3, 4]

// Add multiple
queue.unshift(-2, -1, 0);
console.log(queue); // [-2, -1, 0, 1, 2, 3, 4]

// Returns new length
const newLength = queue.unshift(-3);

// ⚠️ Performance: O(n) - slower than push() for large arrays
```

### shift() - Remove from Beginning

Removes and returns the first element.

```javascript
const queue = [1, 2, 3, 4];

const first = queue.shift();
console.log(first); // 1
console.log(queue); // [2, 3, 4]

// ⚠️ Performance: O(n) - slower than pop() for large arrays
```

### Summary: Stack vs Queue Operations

```javascript
// STACK (LIFO - Last In, First Out)
const stack = [];
stack.push(1); // Add to end
stack.push(2);
stack.pop(); // Remove from end

// QUEUE (FIFO - First In, First Out)
const queue = [];
queue.push(1); // Add to end
queue.push(2);
queue.shift(); // Remove from beginning
```

---

## Array Methods: concat, slice, splice

### concat() - Combine Arrays

Returns a new array by merging arrays (does not mutate).

```javascript
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];

// Concatenate two arrays
const combined = arr1.concat(arr2);
console.log(combined); // [1, 2, 3, 4, 5, 6]
console.log(arr1); // [1, 2, 3] - unchanged

// Concatenate multiple arrays
const arr3 = [7, 8];
const all = arr1.concat(arr2, arr3);
console.log(all); // [1, 2, 3, 4, 5, 6, 7, 8]

// Add individual values
const extended = arr1.concat(4, 5, [6, 7]);
console.log(extended); // [1, 2, 3, 4, 5, 6, 7]

// Modern alternative: spread operator
const modern = [...arr1, ...arr2];
console.log(modern); // [1, 2, 3, 4, 5, 6]
```

### slice() - Extract Portion

Returns a shallow copy of a portion (does not mutate).

```javascript
const numbers = [0, 1, 2, 3, 4, 5];

// slice(start, end) - end is exclusive
const portion = numbers.slice(1, 4);
console.log(portion); // [1, 2, 3]
console.log(numbers); // [0, 1, 2, 3, 4, 5] - unchanged

// From index to end
const fromTwo = numbers.slice(2);
console.log(fromTwo); // [2, 3, 4, 5]

// Negative indices (count from end)
const lastTwo = numbers.slice(-2);
console.log(lastTwo); // [4, 5]

const exceptLast = numbers.slice(0, -1);
console.log(exceptLast); // [0, 1, 2, 3, 4]

// Clone array (shallow copy)
const clone = numbers.slice();
console.log(clone); // [0, 1, 2, 3, 4, 5]
```

### splice() - Add/Remove Elements

Modifies the array by removing and/or inserting elements (mutates).

```javascript
const arr = [0, 1, 2, 3, 4, 5];

// splice(start, deleteCount, ...items)

// Remove elements
const removed = arr.splice(2, 2); // Remove 2 elements starting at index 2
console.log(removed); // [2, 3]
console.log(arr); // [0, 1, 4, 5]

// Insert elements (deleteCount = 0)
arr.splice(2, 0, 'a', 'b');
console.log(arr); // [0, 1, 'a', 'b', 4, 5]

// Replace elements
arr.splice(2, 2, 2, 3);
console.log(arr); // [0, 1, 2, 3, 4, 5]

// Remove from index to end
const rest = arr.splice(3);
console.log(rest); // [3, 4, 5]
console.log(arr); // [0, 1, 2]

// Negative start index
arr.splice(-1, 1); // Remove last element
console.log(arr); // [0, 1]
```

### slice vs splice Comparison

| Method | Mutates? | Returns | Use Case |
|--------|----------|---------|----------|
| `slice(start, end)` | ❌ No | New array | Extract portion, clone |
| `splice(start, count, ...items)` | ✅ Yes | Removed elements | Modify in place |

---

## Array Iteration

### Traditional for Loop

```javascript
const numbers = [1, 2, 3, 4, 5];

for (let i = 0; i < numbers.length; i++) {
  console.log(numbers[i]);
}

// Reverse iteration
for (let i = numbers.length - 1; i >= 0; i--) {
  console.log(numbers[i]);
}

// Skip elements
for (let i = 0; i < numbers.length; i += 2) {
  console.log(numbers[i]); // 1, 3, 5
}
```

### forEach() Method

Executes a function for each element (cannot break early).

```javascript
const fruits = ['apple', 'banana', 'cherry'];

// Basic usage
fruits.forEach(fruit => {
  console.log(fruit);
});

// With index and array
fruits.forEach((fruit, index, array) => {
  console.log(`${index}: ${fruit} of ${array.length}`);
});

// ⚠️ Cannot break or continue
fruits.forEach(fruit => {
  if (fruit === 'banana') {
    return; // Only skips this iteration, doesn't stop loop
  }
  console.log(fruit);
});
```

### for...of Loop (ES6)

Iterates over values (can break/continue).

```javascript
const colors = ['red', 'green', 'blue'];

for (const color of colors) {
  console.log(color);
}

// Can break
for (const color of colors) {
  if (color === 'green') break;
  console.log(color); // Only 'red'
}

// Can continue
for (const color of colors) {
  if (color === 'green') continue;
  console.log(color); // 'red', 'blue'
}

// With index using entries()
for (const [index, color] of colors.entries()) {
  console.log(`${index}: ${color}`);
}
```

### for...in Loop (Not Recommended for Arrays)

```javascript
const arr = ['a', 'b', 'c'];

// ❌ Don't use for...in for arrays
for (const key in arr) {
  console.log(key); // '0', '1', '2' - strings, not numbers!
}

// ✅ Use for...of instead
for (const value of arr) {
  console.log(value); // 'a', 'b', 'c'
}
```

### Iteration Method Comparison

| Method | Can Break? | Can Continue? | Gets Index? | Best For |
|--------|-----------|---------------|-------------|----------|
| `for` loop | ✅ Yes | ✅ Yes | ✅ Yes | Full control, complex logic |
| `forEach()` | ❌ No | ❌ No | ✅ Yes | Simple iteration, side effects |
| `for...of` | ✅ Yes | ✅ Yes | Via `entries()` | Cleaner syntax, modern code |
| `for...in` | ✅ Yes | ✅ Yes | ✅ Yes | ❌ Avoid for arrays |

---

## Multi-dimensional Arrays

Arrays can contain other arrays, creating matrices and complex structures.

### Two-Dimensional Arrays (Matrices)

```javascript
// 3x3 matrix
const matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];

// Access elements: array[row][column]
console.log(matrix[0][0]); // 1
console.log(matrix[1][2]); // 6
console.log(matrix[2][1]); // 8

// Iterate through matrix
for (let i = 0; i < matrix.length; i++) {
  for (let j = 0; j < matrix[i].length; j++) {
    console.log(`matrix[${i}][${j}] = ${matrix[i][j]}`);
  }
}

// Modern iteration
matrix.forEach((row, i) => {
  row.forEach((value, j) => {
    console.log(`matrix[${i}][${j}] = ${value}`);
  });
});
```

### Practical Example: Student Grades

```javascript
// Students × Subjects
const grades = [
  [85, 90, 78], // Alice: Math, English, Science
  [92, 88, 95], // Bob
  [78, 85, 82]  // Charlie
];

// Calculate average for each student
const averages = grades.map(studentGrades => {
  const sum = studentGrades.reduce((acc, grade) => acc + grade, 0);
  return sum / studentGrades.length;
});

console.log(averages); // [84.33, 91.67, 81.67]

// Get all Math grades (first column)
const mathGrades = grades.map(studentGrades => studentGrades[0]);
console.log(mathGrades); // [85, 92, 78]
```

### Three-Dimensional Arrays

```javascript
// 2 classes × 3 students × 3 subjects
const school = [
  [ // Class A
    [85, 90, 78], // Student 1
    [92, 88, 95], // Student 2
    [78, 85, 82]  // Student 3
  ],
  [ // Class B
    [88, 92, 85],
    [90, 87, 91],
    [82, 80, 88]
  ]
];

// Access: school[class][student][subject]
console.log(school[0][1][2]); // Class A, Student 2, Subject 3: 95
```

---

## Array Destructuring

ES6 destructuring provides elegant syntax to extract array values into variables.

### Basic Destructuring

```javascript
const colors = ['red', 'green', 'blue'];

// Traditional way
const first = colors[0];
const second = colors[1];

// Destructuring
const [first, second, third] = colors;
console.log(first);  // 'red'
console.log(second); // 'green'
console.log(third);  // 'blue'

// Partial destructuring
const [primary] = colors;
console.log(primary); // 'red'

const [, , tertiary] = colors; // Skip elements with commas
console.log(tertiary); // 'blue'
```

### Rest Pattern

```javascript
const numbers = [1, 2, 3, 4, 5];

const [first, second, ...rest] = numbers;
console.log(first);  // 1
console.log(second); // 2
console.log(rest);   // [3, 4, 5]

// Rest must be last
const [a, ...middle, z] = numbers; // ❌ SyntaxError
```

### Default Values

```javascript
const values = [1];

const [a, b = 10, c = 20] = values;
console.log(a); // 1
console.log(b); // 10 (default)
console.log(c); // 20 (default)
```

### Swapping Variables

```javascript
let a = 1;
let b = 2;

// Without destructuring
let temp = a;
a = b;
b = temp;

// With destructuring (elegant!)
[a, b] = [b, a];
console.log(a); // 2
console.log(b); // 1
```

### Function Return Values

```javascript
const getCoordinates = () => [10, 20];

const [x, y] = getCoordinates();
console.log(x); // 10
console.log(y); // 20
```

---

## Spread Operator with Arrays

The spread operator `...` expands array elements.

### Copying Arrays (Shallow)

```javascript
const original = [1, 2, 3];

// Clone using spread
const copy = [...original];
console.log(copy); // [1, 2, 3]

// Modifications don't affect original
copy.push(4);
console.log(original); // [1, 2, 3]
console.log(copy);     // [1, 2, 3, 4]
```

### Concatenating Arrays

```javascript
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];

// Using spread (cleaner than concat)
const combined = [...arr1, ...arr2];
console.log(combined); // [1, 2, 3, 4, 5, 6]

// Add elements while concatenating
const extended = [...arr1, 'a', 'b', ...arr2];
console.log(extended); // [1, 2, 3, 'a', 'b', 4, 5, 6]
```

### Function Arguments

```javascript
const numbers = [1, 2, 3, 4, 5];

// Pass array elements as individual arguments
console.log(Math.max(...numbers)); // 5
console.log(Math.min(...numbers)); // 1

// Traditional approach (less elegant)
console.log(Math.max.apply(null, numbers)); // 5
```

### Converting Iterables to Arrays

```javascript
// String to array
const chars = [...'hello'];
console.log(chars); // ['h', 'e', 'l', 'l', 'o']

// Set to array
const set = new Set([1, 2, 2, 3]);
const unique = [...set];
console.log(unique); // [1, 2, 3]

// NodeList to array
const divs = [...document.querySelectorAll('div')];
```

---

## Array Cloning (Shallow vs Deep)

### Shallow Copy

Copies the array structure but not nested objects/arrays.

```javascript
// Simple values - shallow copy is fine
const numbers = [1, 2, 3];
const copy1 = [...numbers];
const copy2 = numbers.slice();
const copy3 = Array.from(numbers);

// Nested objects - shallow copy has issues
const users = [
  { name: 'Alice', age: 25 },
  { name: 'Bob', age: 30 }
];

const shallowCopy = [...users];

// Objects are still referenced!
shallowCopy[0].age = 26;
console.log(users[0].age); // 26 - original affected!

// Array is new, but objects inside are shared
console.log(shallowCopy === users); // false
console.log(shallowCopy[0] === users[0]); // true (same object reference)
```

### Deep Copy Methods

#### Method 1: JSON (Simple but Limited)

```javascript
const original = [
  { name: 'Alice', scores: [90, 85, 92] },
  { name: 'Bob', scores: [78, 88, 85] }
];

// Deep copy using JSON
const deepCopy = JSON.parse(JSON.stringify(original));

deepCopy[0].scores[0] = 100;
console.log(original[0].scores[0]); // 90 - unaffected!

// ⚠️ Limitations:
// - Loses functions
// - Loses undefined values
// - Loses Dates (becomes string)
// - Loses RegExp, Map, Set, etc.

const complex = [
  { date: new Date(), fn: () => 'test' }
];
const jsonCopy = JSON.parse(JSON.stringify(complex));
console.log(jsonCopy[0].date); // String, not Date!
console.log(jsonCopy[0].fn); // undefined
```

#### Method 2: Recursive Deep Copy (Custom)

```javascript
const deepClone = (arr) => {
  return arr.map(item => {
    if (Array.isArray(item)) {
      return deepClone(item); // Recursively clone arrays
    } else if (item && typeof item === 'object') {
      return { ...item }; // Clone objects (shallow for object itself)
    }
    return item; // Primitives
  });
};

const original = [[1, 2], [3, 4]];
const clone = deepClone(original);

clone[0][0] = 999;
console.log(original[0][0]); // 1 - unaffected
```

#### Method 3: structuredClone() (Modern)

```javascript
// Modern browsers and Node.js 17+
const original = [
  { name: 'Alice', date: new Date(), scores: [90, 85] }
];

const deepCopy = structuredClone(original);

deepCopy[0].scores[0] = 100;
console.log(original[0].scores[0]); // 90 - unaffected!

// ⚠️ Still can't clone functions
```

---

## Common Array Patterns

### Finding Maximum/Minimum

```javascript
const numbers = [5, 2, 9, 1, 7];

// Using Math.max/min with spread
const max = Math.max(...numbers); // 9
const min = Math.min(...numbers); // 1

// Using reduce
const maximum = numbers.reduce((max, num) => num > max ? num : max);
const minimum = numbers.reduce((min, num) => num < min ? num : min);
```

### Removing Duplicates

```javascript
const numbers = [1, 2, 2, 3, 3, 3, 4];

// Using Set (easiest)
const unique = [...new Set(numbers)]; // [1, 2, 3, 4]

// Using filter
const unique2 = numbers.filter((num, index, arr) => arr.indexOf(num) === index);
```

### Flattening Arrays

```javascript
const nested = [1, [2, 3], [4, [5, 6]]];

// Flatten one level
const flat1 = nested.flat(); // [1, 2, 3, 4, [5, 6]]

// Flatten all levels
const flatAll = nested.flat(Infinity); // [1, 2, 3, 4, 5, 6]

// Manual flat (single level)
const manual = [].concat(...nested); // [1, 2, 3, 4, [5, 6]]
```

### Array Range Generation

```javascript
// Create range [0, 1, 2, ..., n-1]
const range = n => Array.from({ length: n }, (_, i) => i);
console.log(range(5)); // [0, 1, 2, 3, 4]

// Create range [start, start+1, ..., end-1]
const rangeFromTo = (start, end) =>
  Array.from({ length: end - start }, (_, i) => start + i);
console.log(rangeFromTo(5, 10)); // [5, 6, 7, 8, 9]
```

### Chunking Arrays

```javascript
const chunk = (arr, size) => {
  const chunks = [];
  for (let i = 0; i < arr.length; i += size) {
    chunks.push(arr.slice(i, i + size));
  }
  return chunks;
};

const numbers = [1, 2, 3, 4, 5, 6, 7, 8];
console.log(chunk(numbers, 3)); // [[1, 2, 3], [4, 5, 6], [7, 8]]
```

---

## Worked Examples

### Example 1: Shopping Cart System (Intermediate)

```javascript
/**
 * Shopping Cart Implementation
 * Demonstrates: array manipulation, object arrays, calculations
 */

class ShoppingCart {
  constructor() {
    this.items = [];
  }

  addItem(product, quantity = 1) {
    const existingItem = this.items.find(item => item.product.id === product.id);

    if (existingItem) {
      existingItem.quantity += quantity;
    } else {
      this.items.push({ product, quantity });
    }
  }

  removeItem(productId) {
    this.items = this.items.filter(item => item.product.id !== productId);
  }

  updateQuantity(productId, quantity) {
    const item = this.items.find(item => item.product.id === productId);
    if (item) {
      item.quantity = quantity;
    }
  }

  getTotal() {
    return this.items.reduce((total, item) => {
      return total + (item.product.price * item.quantity);
    }, 0);
  }

  getItemCount() {
    return this.items.reduce((count, item) => count + item.quantity, 0);
  }

  clear() {
    this.items = [];
  }
}

// Usage
const cart = new ShoppingCart();

cart.addItem({ id: 1, name: 'Laptop', price: 999 }, 1);
cart.addItem({ id: 2, name: 'Mouse', price: 25 }, 2);
cart.addItem({ id: 1, name: 'Laptop', price: 999 }, 1); // Increases quantity

console.log(cart.getTotal()); // 2048
console.log(cart.getItemCount()); // 4
```

### Example 2: Data Processing Pipeline (Advanced)

```javascript
/**
 * Student Grade Processing
 * Demonstrates: chaining, mapping, filtering, reducing
 */

const students = [
  { name: 'Alice', scores: [85, 90, 92, 88] },
  { name: 'Bob', scores: [78, 82, 80, 85] },
  { name: 'Charlie', scores: [92, 95, 90, 93] },
  { name: 'David', scores: [65, 70, 68, 72] },
  { name: 'Eve', scores: [88, 85, 90, 87] }
];

// Calculate average for each student
const studentsWithAverage = students.map(student => ({
  ...student,
  average: student.scores.reduce((sum, score) => sum + score, 0) / student.scores.length
}));

// Filter students with average >= 85
const topStudents = studentsWithAverage.filter(student => student.average >= 85);

// Sort by average (descending)
const rankedStudents = topStudents.sort((a, b) => b.average - a.average);

// Extract names
const topStudentNames = rankedStudents.map(student => student.name);

console.log(topStudentNames); // ['Charlie', 'Alice', 'Eve']

// All in one chain (functional style)
const result = students
  .map(s => ({ ...s, avg: s.scores.reduce((a, b) => a + b) / s.scores.length }))
  .filter(s => s.avg >= 85)
  .sort((a, b) => b.avg - a.avg)
  .map(s => s.name);
```

### Example 3: Matrix Operations (Complex)

```javascript
/**
 * Matrix Utilities
 * Demonstrates: 2D arrays, algorithms
 */

const matrixUtils = {
  // Create zero matrix
  createZeroMatrix(rows, cols) {
    return Array.from({ length: rows }, () => Array(cols).fill(0));
  },

  // Transpose matrix
  transpose(matrix) {
    const rows = matrix.length;
    const cols = matrix[0].length;
    return Array.from({ length: cols }, (_, i) =>
      Array.from({ length: rows }, (_, j) => matrix[j][i])
    );
  },

  // Add two matrices
  add(a, b) {
    return a.map((row, i) =>
      row.map((val, j) => val + b[i][j])
    );
  },

  // Multiply matrix by scalar
  scalarMultiply(matrix, scalar) {
    return matrix.map(row => row.map(val => val * scalar));
  },

  // Print matrix
  print(matrix) {
    matrix.forEach(row => console.log(row.join('\t')));
  }
};

// Usage
const m1 = [
  [1, 2, 3],
  [4, 5, 6]
];

const m2 = [
  [7, 8, 9],
  [10, 11, 12]
];

console.log('Matrix 1:');
matrixUtils.print(m1);

console.log('\nTransposed:');
matrixUtils.print(matrixUtils.transpose(m1));

console.log('\nM1 + M2:');
matrixUtils.print(matrixUtils.add(m1, m2));
```

---

## Exercises

### Exercise 1: Array Basics (Easy)

**Task:** Create a function `arrayStats(arr)` that returns an object with the following properties:
- `length`: number of elements
- `first`: first element
- `last`: last element
- `middle`: middle element (if even length, return the lower middle)

```javascript
// Example
arrayStats([1, 2, 3, 4, 5]); // { length: 5, first: 1, last: 5, middle: 3 }
arrayStats([10, 20]); // { length: 2, first: 10, last: 20, middle: 10 }
```

**Solution:** See `solutions/07_arrays_fundamentals_solutions.js`

---

### Exercise 2: Array Manipulation (Easy)

**Task:** Write a function `rotateArray(arr, positions)` that rotates an array to the right by `positions` places.

```javascript
// Examples
rotateArray([1, 2, 3, 4, 5], 2); // [4, 5, 1, 2, 3]
rotateArray([1, 2, 3], 1); // [3, 1, 2]
```

**Hint:** Use `slice()` and spread operator.

**Solution:** See solutions file.

---

### Exercise 3: Multi-dimensional Arrays (Medium)

**Task:** Create a function `sumMatrix(matrix)` that calculates the sum of all elements in a 2D matrix.

```javascript
// Example
const matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];
sumMatrix(matrix); // 45
```

**Solution:** See solutions file.

---

### Exercise 4: Array Cloning (Medium)

**Task:** Implement a function `deepCloneArray(arr)` that creates a deep copy of an array containing nested arrays and objects. Don't use JSON methods.

```javascript
// Example
const original = [
  { name: 'Alice', hobbies: ['reading', 'gaming'] },
  { name: 'Bob', hobbies: ['sports'] }
];
const clone = deepCloneArray(original);
clone[0].hobbies.push('cooking');
// original should be unaffected
```

**Solution:** See solutions file.

---

### Exercise 5: Array Patterns (Medium)

**Task:** Write a function `mergeSorted(arr1, arr2)` that merges two sorted arrays into one sorted array without using `sort()`.

```javascript
// Example
mergeSorted([1, 3, 5], [2, 4, 6]); // [1, 2, 3, 4, 5, 6]
mergeSorted([1, 5, 9], [2, 3, 7, 8]); // [1, 2, 3, 5, 7, 8, 9]
```

**Solution:** See solutions file.

---

### Exercise 6: Shopping List Manager (Hard)

**Task:** Create a `ShoppingList` class with the following methods:
- `addItem(name, quantity, price)`
- `removeItem(name)`
- `updateQuantity(name, newQuantity)`
- `getTotal()` - returns total cost
- `getMostExpensive()` - returns most expensive item
- `sortByPrice()` - returns items sorted by price
- `clear()`

**Solution:** See solutions file.

---

### Exercise 7: Matrix Rotation (Hard)

**Task:** Write a function `rotateMatrix90(matrix)` that rotates a square matrix 90 degrees clockwise.

```javascript
// Example
const matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];

rotateMatrix90(matrix);
// Result:
// [
//   [7, 4, 1],
//   [8, 5, 2],
//   [9, 6, 3]
// ]
```

**Solution:** See solutions file.

---

## Testing & Verification

### Manual Testing

```javascript
// Test array creation
const testCreate = () => {
  const arr1 = [1, 2, 3];
  const arr2 = new Array(3);
  const arr3 = Array.of(5);
  const arr4 = Array.from('abc');

  console.assert(arr1.length === 3, 'arr1 length should be 3');
  console.assert(arr2.length === 3, 'arr2 length should be 3');
  console.assert(arr3[0] === 5, 'arr3 first element should be 5');
  console.assert(arr4.join('') === 'abc', 'arr4 should be [a,b,c]');

  console.log('✅ Array creation tests passed');
};

testCreate();
```

### Using Vitest (Recommended)

```javascript
// arrays.test.js
import { describe, it, expect } from 'vitest';

describe('Array Operations', () => {
  describe('push() and pop()', () => {
    it('should add and remove elements from end', () => {
      const arr = [1, 2, 3];
      arr.push(4);
      expect(arr).toEqual([1, 2, 3, 4]);

      const last = arr.pop();
      expect(last).toBe(4);
      expect(arr).toEqual([1, 2, 3]);
    });
  });

  describe('slice()', () => {
    it('should extract portion without mutating', () => {
      const arr = [1, 2, 3, 4, 5];
      const portion = arr.slice(1, 4);

      expect(portion).toEqual([2, 3, 4]);
      expect(arr).toEqual([1, 2, 3, 4, 5]); // Unchanged
    });
  });

  describe('spread operator', () => {
    it('should clone array', () => {
      const original = [1, 2, 3];
      const copy = [...original];

      copy.push(4);
      expect(original).toEqual([1, 2, 3]);
      expect(copy).toEqual([1, 2, 3, 4]);
    });
  });
});
```

---

## Best Practices

### 1. Prefer Immutable Operations

```javascript
// ❌ Avoid: Mutating original array
const addElement = (arr, element) => {
  arr.push(element);
  return arr;
};

// ✅ Good: Return new array
const addElement = (arr, element) => [...arr, element];
```

### 2. Use Appropriate Methods

```javascript
// ❌ Avoid: Using splice for extraction
const getFirst3 = arr => {
  return arr.splice(0, 3); // Mutates!
};

// ✅ Good: Use slice
const getFirst3 = arr => arr.slice(0, 3);
```

### 3. Avoid Sparse Arrays

```javascript
// ❌ Avoid
const arr = [];
arr[100] = 'value'; // Creates 100 empty slots

// ✅ Good
const arr = new Array(101).fill(null);
arr[100] = 'value';
```

### 4. Use Modern Iteration

```javascript
// ❌ Okay but verbose
for (let i = 0; i < arr.length; i++) {
  console.log(arr[i]);
}

// ✅ Better
for (const item of arr) {
  console.log(item);
}

// ✅ Best for transformation
const doubled = arr.map(x => x * 2);
```

### 5. Type Consistency

```javascript
// ❌ Avoid: Mixed types
const mixed = [1, 'two', true, null];

// ✅ Good: Consistent types
const numbers = [1, 2, 3, 4];
const strings = ['one', 'two', 'three'];
```

---

## Common Pitfalls

### 1. Array Constructor Ambiguity

```javascript
// ❌ Pitfall
new Array(5); // [empty × 5], NOT [5]

// ✅ Solution
Array.of(5); // [5]
[5]; // [5]
```

### 2. Modifying During Iteration

```javascript
// ❌ Dangerous
const arr = [1, 2, 3, 4, 5];
arr.forEach((num, i) => {
  if (num % 2 === 0) {
    arr.splice(i, 1); // Modifying during iteration!
  }
});

// ✅ Safe
const filtered = arr.filter(num => num % 2 !== 0);
```

### 3. Shallow Copy Issues

```javascript
// ❌ Trap
const users = [{ name: 'Alice' }];
const copy = [...users];
copy[0].name = 'Bob'; // Affects original!

// ✅ Fix
const copy = users.map(user => ({ ...user }));
```

### 4. Length Property Gotchas

```javascript
// ❌ Confusing
const arr = [1, 2, 3];
arr.length = 10; // Extends with empty slots
arr.length = 1; // Truncates!
```

### 5. Incorrect Array Detection

```javascript
// ❌ Wrong
typeof [1, 2, 3]; // 'object'

// ✅ Correct
Array.isArray([1, 2, 3]); // true
```

---

## Performance Considerations

### Operation Complexity

| Operation | Time Complexity | Notes |
|-----------|----------------|-------|
| `arr[i]` (access) | O(1) | Direct index access |
| `push()` | O(1) amortized | Add to end |
| `pop()` | O(1) | Remove from end |
| `unshift()` | O(n) | Shifts all elements |
| `shift()` | O(n) | Shifts all elements |
| `splice()` | O(n) | May shift elements |
| `slice()` | O(n) | Creates new array |
| `concat()` | O(n + m) | Combines arrays |

### Optimization Tips

```javascript
// ❌ Slow: Multiple array mutations
const arr = [];
for (let i = 0; i < 1000; i++) {
  arr.unshift(i); // O(n) each time!
}

// ✅ Fast: Use push and reverse
const arr = [];
for (let i = 0; i < 1000; i++) {
  arr.push(i); // O(1)
}
arr.reverse(); // O(n) once

// ❌ Slow: Array lookup in loop
for (let i = 0; i < users.length; i++) {
  console.log(users[i]);
}

// ✅ Fast: Cache length
const len = users.length;
for (let i = 0; i < len; i++) {
  console.log(users[i]);
}

// ✅ Fastest: for...of (optimized by engine)
for (const user of users) {
  console.log(user);
}
```

---

## Summary & Next Steps

### Key Takeaways

- **Arrays are ordered collections** indexed from 0
- **Multiple creation methods**: literals (best), constructor, `Array.of()`, `Array.from()`
- **Core methods**: push/pop (end), shift/unshift (start), slice/splice/concat
- **Modern features**: destructuring, spread operator, for...of
- **Shallow vs deep copy** matters for nested structures
- **Choose methods wisely**: mutating vs non-mutating
- **Performance**: push/pop are fast, shift/unshift are slow

### Related Topics

- [Array Methods: Advanced](./08.Array_Methods_Advanced.md) - map, filter, reduce, etc.
- [Objects Fundamentals](./09.Objects_Fundamentals.md)
- [Reference Types & Memory](./10.Reference_Types_And_Memory.md)

### Further Reading

- [MDN: Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)
- [JavaScript.info: Arrays](https://javascript.info/array)
- [Node.js Buffer vs Array](https://nodejs.org/api/buffer.html)

---

## References

1. **ECMAScript Specification**: [Array Objects](https://tc39.es/ecma262/#sec-array-objects)
2. **MDN Web Docs**: [Array Reference](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)
3. **JavaScript.info**: [Arrays Tutorial](https://javascript.info/array)
4. **V8 Blog**: [Array Performance](https://v8.dev/blog/elements-kinds)

---

**Last Updated:** 2025-11-22
**Version:** 1.0.0
**Curriculum:** JavaScript for Backend Development
