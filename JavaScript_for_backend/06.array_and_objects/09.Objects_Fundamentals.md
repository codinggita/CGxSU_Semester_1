# Objects Fundamentals in JavaScript

**Difficulty:** Introductory to Intermediate
**Estimated Time:** 50-65 minutes
**Prerequisites:** Basic JavaScript knowledge, variables, functions
**Target:** Node.js 18+ LTS, Modern Browsers (ES2021+)

---

## Learning Objectives

By the end of this lesson, you will be able to:

1. Create objects using literals, constructors, and Object.create()
2. Access and manipulate properties using dot and bracket notation
3. Add, update, and delete object properties dynamically
4. Define and invoke object methods
5. Understand and use the `this` keyword in object contexts
6. Apply ES6+ features: destructuring, spread, shorthand
7. Work with Object.keys(), Object.values(), Object.entries()
8. Clone and merge objects using Object.assign() and spread
9. Use computed properties and property descriptors
10. Implement getters and setters for controlled property access

---

## Table of Contents

1. [Introduction](#introduction)
2. [What Are Objects?](#what-are-objects)
3. [Object Creation Methods](#object-creation-methods)
4. [Property Access (Dot vs Bracket)](#property-access-dot-vs-bracket)
5. [Adding, Updating, and Deleting Properties](#adding-updating-and-deleting-properties)
6. [Object Methods](#object-methods)
7. [The this Keyword](#the-this-keyword)
8. [Object Destructuring](#object-destructuring)
9. [Spread Operator with Objects](#spread-operator-with-objects)
10. [Object Static Methods](#object-static-methods)
11. [Property Shorthand and Computed Properties](#property-shorthand-and-computed-properties)
12. [Getters and Setters](#getters-and-setters)
13. [Worked Examples](#worked-examples)
14. [Exercises](#exercises)
15. [Testing & Verification](#testing--verification)
16. [Best Practices](#best-practices)
17. [Common Pitfalls](#common-pitfalls)
18. [Summary & Next Steps](#summary--next-steps)
19. [References](#references)

---

## Introduction

Objects are the fundamental building blocks of JavaScript. Unlike arrays (ordered collections), objects store **unordered collections of key-value pairs**, making them ideal for representing entities, configurations, and complex data structures.

**Why Objects Matter:**

- **Entity Representation:** Model real-world things (users, products, posts)
- **Data Organization:** Group related properties and methods
- **Flexibility:** Dynamic property addition/removal
- **Inheritance:** Prototype-based inheritance system
- **JSON Compatibility:** Native data exchange format
- **Backend Development:** Request/response objects, configuration, models

In Node.js backend development, objects are essential for:
- Database models and schemas
- HTTP request/response handling
- Configuration management
- API data structures
- Business logic encapsulation

---

## What Are Objects?

An **object** is a collection of **properties**, where each property is a **key-value pair**.

### Anatomy of an Object

```javascript
const user = {
  // Properties (data)
  name: 'Alice',           // key: 'name', value: 'Alice'
  age: 25,                 // key: 'age', value: 25
  email: 'alice@ex.com',   // key: 'email', value: 'alice@ex.com'

  // Methods (functions)
  greet() {
    return `Hello, I'm ${this.name}`;
  }
};

// Access properties
console.log(user.name);        // 'Alice'
console.log(user['age']);      // 25

// Call methods
console.log(user.greet());     // 'Hello, I'm Alice'
```

### Key Characteristics

- **Unordered:** Properties have no guaranteed order (before ES6)
- **Mutable:** Can add/modify/delete properties
- **Dynamic:** Structure can change at runtime
- **Reference Type:** Objects are passed by reference
- **Extensible:** Can be extended with new properties

### Objects vs Arrays

| Feature | Object | Array |
|---------|--------|-------|
| Structure | Key-value pairs | Indexed list |
| Keys | Strings/Symbols | Numeric indices |
| Order | Not guaranteed (pre-ES6) | Guaranteed |
| Length | No built-in length | Has `.length` |
| Use Case | Entities, records | Lists, sequences |
| Iteration | `for...in`, Object.keys() | `for...of`, array methods |

---

## Object Creation Methods

### Method 1: Object Literal (Recommended)

The most common and concise way:

```javascript
// Empty object
const empty = {};

// Object with properties
const person = {
  firstName: 'John',
  lastName: 'Doe',
  age: 30,
  isActive: true
};

// Nested objects
const user = {
  id: 1,
  name: 'Alice',
  address: {
    street: '123 Main St',
    city: 'NYC',
    zip: '10001'
  },
  hobbies: ['reading', 'gaming']
};
```

### Method 2: Object Constructor

```javascript
// Using new Object()
const person = new Object();
person.name = 'Bob';
person.age = 25;

console.log(person); // { name: 'Bob', age: 25 }

// ⚠️ Rarely used; prefer object literals
```

### Method 3: Constructor Function (Pre-ES6)

```javascript
// Constructor function (capitalized by convention)
function Person(name, age) {
  this.name = name;
  this.age = age;
  this.greet = function() {
    return `Hi, I'm ${this.name}`;
  };
}

// Create instances
const alice = new Person('Alice', 25);
const bob = new Person('Bob', 30);

console.log(alice.greet()); // 'Hi, I'm Alice'
console.log(bob.greet());   // 'Hi, I'm Bob'

// ⚠️ Modern alternative: classes (ES6+)
```

### Method 4: Object.create()

Creates object with specified prototype:

```javascript
const personPrototype = {
  greet() {
    return `Hello, I'm ${this.name}`;
  }
};

// Create object with personPrototype as prototype
const alice = Object.create(personPrototype);
alice.name = 'Alice';
alice.age = 25;

console.log(alice.greet()); // 'Hello, I'm Alice'

// Create object with null prototype (no inheritance)
const bareObject = Object.create(null);
bareObject.name = 'Test';
console.log(bareObject.toString); // undefined (no Object.prototype methods)
```

### Method 5: Factory Functions

Functions that return objects:

```javascript
const createUser = (name, email) => ({
  name,
  email,
  createdAt: new Date(),
  greet() {
    return `Hello, ${this.name}`;
  }
});

const user1 = createUser('Alice', 'alice@ex.com');
const user2 = createUser('Bob', 'bob@ex.com');

console.log(user1.greet()); // 'Hello, Alice'
```

---

## Property Access (Dot vs Bracket)

### Dot Notation

Used for valid identifiers (most common):

```javascript
const user = {
  name: 'Alice',
  age: 25,
  email: 'alice@example.com'
};

// Access
console.log(user.name);  // 'Alice'
console.log(user.age);   // 25

// Update
user.age = 26;

// Add new property
user.city = 'NYC';
```

### Bracket Notation

Used for:
- Invalid identifiers (spaces, special chars, numbers)
- Dynamic property names
- Property names from variables

```javascript
const user = {
  name: 'Alice',
  'favorite color': 'blue',  // Space in key
  '2023-data': { views: 100 } // Starts with number
};

// Access properties with spaces/special chars
console.log(user['favorite color']); // 'blue'
console.log(user['2023-data']);      // { views: 100 }

// ❌ Can't use dot notation
// console.log(user.favorite color); // SyntaxError
// console.log(user.2023-data);      // SyntaxError

// Dynamic property access
const propName = 'name';
console.log(user[propName]); // 'Alice'

const field = 'age';
console.log(user[field]); // 25
```

### When to Use Each

```javascript
// ✅ Dot notation: Static, known property names
user.name
user.email

// ✅ Bracket notation: Dynamic property names
const key = 'age';
user[key]

// ✅ Bracket notation: Invalid identifiers
user['first name']
user['user-id']

// ❌ Can't use dot notation
user.first name  // SyntaxError
```

---

## Adding, Updating, and Deleting Properties

### Adding Properties

```javascript
const user = { name: 'Alice' };

// Dot notation
user.age = 25;
user.email = 'alice@ex.com';

// Bracket notation
user['city'] = 'NYC';
user['is-active'] = true;

console.log(user);
// {
//   name: 'Alice',
//   age: 25,
//   email: 'alice@ex.com',
//   city: 'NYC',
//   'is-active': true
// }
```

### Updating Properties

```javascript
const product = {
  name: 'Laptop',
  price: 999,
  inStock: true
};

// Update existing properties
product.price = 899;
product['inStock'] = false;

console.log(product);
// { name: 'Laptop', price: 899, inStock: false }
```

### Deleting Properties

```javascript
const user = {
  name: 'Alice',
  age: 25,
  tempData: 'remove me'
};

// Delete property
delete user.tempData;
console.log(user); // { name: 'Alice', age: 25 }

// Delete returns true if successful
const success = delete user.age;
console.log(success); // true
console.log(user);    // { name: 'Alice' }

// ⚠️ Delete non-existent property (still returns true)
delete user.nonExistent; // true

// ❌ Can't delete non-configurable properties
delete Object.prototype; // false (in strict mode: TypeError)
```

### Checking Property Existence

```javascript
const user = { name: 'Alice', age: 25 };

// Method 1: in operator
console.log('name' in user);  // true
console.log('email' in user); // false

// Method 2: hasOwnProperty
console.log(user.hasOwnProperty('name'));  // true
console.log(user.hasOwnProperty('toString')); // false (inherited)

// Method 3: Direct access (checks for undefined)
console.log(user.name !== undefined);  // true
console.log(user.email !== undefined); // false

// ⚠️ Difference: in checks prototype chain
console.log('toString' in user); // true (inherited from Object.prototype)
```

---

## Object Methods

### Defining Methods

Methods are functions stored as object properties:

```javascript
// Method definition (ES6 shorthand)
const calculator = {
  add(a, b) {
    return a + b;
  },

  subtract(a, b) {
    return a - b;
  },

  multiply(a, b) {
    return a * b;
  }
};

console.log(calculator.add(5, 3));      // 8
console.log(calculator.multiply(4, 2)); // 8

// Traditional method definition
const calc2 = {
  add: function(a, b) {
    return a + b;
  }
};

// Arrow functions (⚠️ no own 'this')
const calc3 = {
  value: 10,
  getValue: () => this.value // ❌ 'this' doesn't refer to calc3
};
```

### Methods with this

```javascript
const user = {
  firstName: 'Alice',
  lastName: 'Smith',

  getFullName() {
    return `${this.firstName} ${this.lastName}`;
  },

  greet(greeting = 'Hello') {
    return `${greeting}, I'm ${this.getFullName()}`;
  }
};

console.log(user.getFullName()); // 'Alice Smith'
console.log(user.greet());       // 'Hello, I'm Alice Smith'
console.log(user.greet('Hi'));   // 'Hi, I'm Alice Smith'
```

### Dynamic Methods

```javascript
const counter = {
  count: 0,

  increment() {
    this.count++;
    return this;
  },

  decrement() {
    this.count--;
    return this;
  },

  reset() {
    this.count = 0;
    return this;
  },

  getValue() {
    return this.count;
  }
};

// Method chaining (returning 'this')
counter.increment().increment().increment().decrement();
console.log(counter.getValue()); // 2
```

---

## The this Keyword

`this` refers to the object that is executing the current function.

### this in Object Methods

```javascript
const person = {
  name: 'Alice',
  age: 25,

  introduce() {
    console.log(`I'm ${this.name}, ${this.age} years old`);
  },

  birthday() {
    this.age++;
    console.log(`Happy birthday! Now ${this.age}`);
  }
};

person.introduce(); // "I'm Alice, 25 years old"
person.birthday();  // "Happy birthday! Now 26"
```

### this Context Loss

```javascript
const user = {
  name: 'Alice',

  greet() {
    console.log(`Hello, ${this.name}`);
  }
};

// Direct call - works
user.greet(); // 'Hello, Alice'

// ❌ Assigned to variable - loses context
const greetFn = user.greet;
greetFn(); // 'Hello, undefined' (this is undefined/window)

// ✅ Solution 1: bind()
const boundGreet = user.greet.bind(user);
boundGreet(); // 'Hello, Alice'

// ✅ Solution 2: Arrow function wrapper
const wrappedGreet = () => user.greet();
wrappedGreet(); // 'Hello, Alice'

// ✅ Solution 3: Call with object context
greetFn.call(user); // 'Hello, Alice'
```

### this in Arrow Functions

Arrow functions don't have their own `this`:

```javascript
const obj = {
  name: 'Alice',

  // ❌ Arrow function - 'this' is lexical (not obj)
  greetArrow: () => {
    console.log(this.name); // undefined (or global)
  },

  // ✅ Regular function - 'this' is obj
  greetRegular() {
    console.log(this.name); // 'Alice'
  },

  // ✅ Arrow function inside regular method
  greetDelayed() {
    setTimeout(() => {
      console.log(this.name); // 'Alice' (inherits from greetDelayed)
    }, 100);
  }
};

obj.greetArrow();   // undefined
obj.greetRegular(); // 'Alice'
obj.greetDelayed(); // 'Alice' (after 100ms)
```

---

## Object Destructuring

ES6 destructuring extracts properties into variables:

### Basic Destructuring

```javascript
const user = {
  name: 'Alice',
  age: 25,
  email: 'alice@ex.com'
};

// Traditional approach
const name = user.name;
const age = user.age;

// ✅ Destructuring
const { name, age, email } = user;
console.log(name);  // 'Alice'
console.log(age);   // 25
console.log(email); // 'alice@ex.com'
```

### Renaming Variables

```javascript
const user = { name: 'Alice', age: 25 };

// Rename during destructuring
const { name: userName, age: userAge } = user;
console.log(userName); // 'Alice'
console.log(userAge);  // 25
```

### Default Values

```javascript
const user = { name: 'Alice' };

// Provide defaults for missing properties
const { name, age = 18, city = 'Unknown' } = user;
console.log(name); // 'Alice'
console.log(age);  // 18 (default)
console.log(city); // 'Unknown' (default)
```

### Nested Destructuring

```javascript
const user = {
  name: 'Alice',
  address: {
    city: 'NYC',
    zip: '10001'
  }
};

// Destructure nested objects
const { name, address: { city, zip } } = user;
console.log(name); // 'Alice'
console.log(city); // 'NYC'
console.log(zip);  // '10001'

// ⚠️ 'address' is not defined
// console.log(address); // ReferenceError

// To get both:
const { name, address, address: { city } } = user;
console.log(address); // { city: 'NYC', zip: '10001' }
```

### Destructuring in Function Parameters

```javascript
// Without destructuring
function greet(user) {
  return `Hello, ${user.name} from ${user.city}`;
}

// ✅ With destructuring
function greetDestructured({ name, city = 'Unknown' }) {
  return `Hello, ${name} from ${city}`;
}

const user = { name: 'Alice', city: 'NYC' };
console.log(greetDestructured(user)); // 'Hello, Alice from NYC'

// With default parameter
function greet2({ name, age } = {}) {
  return `${name}, ${age}`;
}

greet2(); // 'undefined, undefined' (no error)
```

### Rest Properties

```javascript
const user = {
  name: 'Alice',
  age: 25,
  email: 'alice@ex.com',
  city: 'NYC'
};

// Extract some, collect rest
const { name, age, ...rest } = user;
console.log(name); // 'Alice'
console.log(age);  // 25
console.log(rest); // { email: 'alice@ex.com', city: 'NYC' }
```

---

## Spread Operator with Objects

The spread operator `...` expands object properties:

### Copying Objects (Shallow)

```javascript
const original = {
  name: 'Alice',
  age: 25
};

// Clone using spread
const copy = { ...original };
copy.age = 26;

console.log(original); // { name: 'Alice', age: 25 }
console.log(copy);     // { name: 'Alice', age: 26 }
```

### Merging Objects

```javascript
const defaults = {
  theme: 'light',
  fontSize: 14,
  notifications: true
};

const userPrefs = {
  theme: 'dark',
  fontSize: 16
};

// Merge (later properties override earlier)
const config = { ...defaults, ...userPrefs };
console.log(config);
// {
//   theme: 'dark',        // overridden
//   fontSize: 16,         // overridden
//   notifications: true   // from defaults
// }
```

### Adding/Overriding Properties

```javascript
const user = { name: 'Alice', age: 25 };

// Add new property
const userWithEmail = { ...user, email: 'alice@ex.com' };

// Override existing property
const olderUser = { ...user, age: 30 };

// Computed property names
const key = 'city';
const userWithCity = { ...user, [key]: 'NYC' };

console.log(userWithCity); // { name: 'Alice', age: 25, city: 'NYC' }
```

### Shallow Copy Gotcha

```javascript
const user = {
  name: 'Alice',
  address: {
    city: 'NYC'
  }
};

const copy = { ...user };

// ⚠️ Nested objects are still referenced!
copy.address.city = 'LA';
console.log(user.address.city); // 'LA' (affected!)

// ✅ Deep copy needed for nested objects
const deepCopy = {
  ...user,
  address: { ...user.address }
};
```

---

## Object Static Methods

### Object.keys()

Returns array of object's own property names:

```javascript
const user = { name: 'Alice', age: 25, email: 'alice@ex.com' };

const keys = Object.keys(user);
console.log(keys); // ['name', 'age', 'email']

// Iterate over properties
Object.keys(user).forEach(key => {
  console.log(`${key}: ${user[key]}`);
});
```

### Object.values()

Returns array of object's own property values:

```javascript
const user = { name: 'Alice', age: 25, email: 'alice@ex.com' };

const values = Object.values(user);
console.log(values); // ['Alice', 25, 'alice@ex.com']

// Sum numeric values
const scores = { math: 85, english: 90, science: 88 };
const total = Object.values(scores).reduce((sum, score) => sum + score, 0);
console.log(total); // 263
```

### Object.entries()

Returns array of [key, value] pairs:

```javascript
const user = { name: 'Alice', age: 25, email: 'alice@ex.com' };

const entries = Object.entries(user);
console.log(entries);
// [
//   ['name', 'Alice'],
//   ['age', 25],
//   ['email', 'alice@ex.com']
// ]

// Iterate with destructuring
for (const [key, value] of Object.entries(user)) {
  console.log(`${key}: ${value}`);
}

// Convert to Map
const userMap = new Map(Object.entries(user));
```

### Object.fromEntries()

Converts [key, value] pairs to object (inverse of Object.entries()):

```javascript
const entries = [
  ['name', 'Alice'],
  ['age', 25],
  ['email', 'alice@ex.com']
];

const user = Object.fromEntries(entries);
console.log(user); // { name: 'Alice', age: 25, email: 'alice@ex.com' }

// Convert Map to object
const map = new Map([['a', 1], ['b', 2]]);
const obj = Object.fromEntries(map);
console.log(obj); // { a: 1, b: 2 }
```

### Object.assign()

Copies properties from source objects to target:

```javascript
const target = { a: 1, b: 2 };
const source = { b: 3, c: 4 };

// Mutates target
Object.assign(target, source);
console.log(target); // { a: 1, b: 3, c: 4 }

// Create new object (common pattern)
const merged = Object.assign({}, target, source);

// ✅ Modern alternative: spread operator
const merged2 = { ...target, ...source };
```

---

## Property Shorthand and Computed Properties

### Property Shorthand

```javascript
const name = 'Alice';
const age = 25;

// ❌ Redundant
const user1 = {
  name: name,
  age: age
};

// ✅ Shorthand (ES6)
const user2 = { name, age };
console.log(user2); // { name: 'Alice', age: 25 }

// Common in function returns
const createUser = (name, email) => ({ name, email });
```

### Method Shorthand

```javascript
// ❌ Old way
const obj1 = {
  greet: function() {
    return 'Hello';
  }
};

// ✅ Shorthand
const obj2 = {
  greet() {
    return 'Hello';
  }
};
```

### Computed Property Names

```javascript
// Dynamic property names
const propName = 'age';
const user = {
  name: 'Alice',
  [propName]: 25,                    // age: 25
  ['user_' + 'id']: 123,            // user_id: 123
  [`${propName}_verified`]: true    // age_verified: true
};

console.log(user);
// {
//   name: 'Alice',
//   age: 25,
//   user_id: 123,
//   age_verified: true
// }

// Function return values as keys
const getKey = () => 'dynamicKey';
const obj = {
  [getKey()]: 'value'
};
console.log(obj); // { dynamicKey: 'value' }
```

---

## Getters and Setters

Getters and setters provide controlled access to properties:

### Basic Getters

```javascript
const user = {
  firstName: 'Alice',
  lastName: 'Smith',

  // Getter: computed property
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
};

// Access like a property (no parentheses)
console.log(user.fullName); // 'Alice Smith'

// ❌ Can't call as function
// console.log(user.fullName()); // TypeError
```

### Basic Setters

```javascript
const user = {
  firstName: 'Alice',
  lastName: 'Smith',

  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  },

  set fullName(name) {
    const parts = name.split(' ');
    this.firstName = parts[0];
    this.lastName = parts[1];
  }
};

// Set using assignment
user.fullName = 'Bob Jones';
console.log(user.firstName); // 'Bob'
console.log(user.lastName);  // 'Jones'
console.log(user.fullName);  // 'Bob Jones'
```

### Validation with Setters

```javascript
const account = {
  _balance: 0, // Convention: underscore indicates private

  get balance() {
    return this._balance;
  },

  set balance(amount) {
    if (typeof amount !== 'number') {
      throw new TypeError('Balance must be a number');
    }
    if (amount < 0) {
      throw new Error('Balance cannot be negative');
    }
    this._balance = amount;
  }
};

account.balance = 100;
console.log(account.balance); // 100

// ❌ Validation errors
// account.balance = -50;     // Error: Balance cannot be negative
// account.balance = 'text';  // TypeError: Balance must be a number
```

### Lazy Evaluation

```javascript
const user = {
  firstName: 'Alice',
  lastName: 'Smith',
  _fullName: null,

  get fullName() {
    // Calculate only once
    if (!this._fullName) {
      console.log('Computing full name...');
      this._fullName = `${this.firstName} ${this.lastName}`;
    }
    return this._fullName;
  }
};

console.log(user.fullName); // "Computing full name..." + "Alice Smith"
console.log(user.fullName); // "Alice Smith" (cached)
```

---

## Worked Examples

### Example 1: User Management System (Intermediate)

```javascript
/**
 * User Management with Object Methods
 * Demonstrates: methods, this, object manipulation
 */

const userDatabase = {
  users: [],

  addUser(name, email, role = 'user') {
    const user = {
      id: this.users.length + 1,
      name,
      email,
      role,
      createdAt: new Date(),
      active: true
    };
    this.users.push(user);
    return user;
  },

  findUserById(id) {
    return this.users.find(user => user.id === id);
  },

  findUsersByRole(role) {
    return this.users.filter(user => user.role === role);
  },

  updateUser(id, updates) {
    const user = this.findUserById(id);
    if (user) {
      Object.assign(user, updates);
      return user;
    }
    return null;
  },

  deleteUser(id) {
    const index = this.users.findIndex(user => user.id === id);
    if (index !== -1) {
      return this.users.splice(index, 1)[0];
    }
    return null;
  },

  getStats() {
    return {
      total: this.users.length,
      active: this.users.filter(u => u.active).length,
      byRole: this.users.reduce((acc, user) => {
        acc[user.role] = (acc[user.role] || 0) + 1;
        return acc;
      }, {})
    };
  }
};

// Usage
userDatabase.addUser('Alice', 'alice@ex.com', 'admin');
userDatabase.addUser('Bob', 'bob@ex.com');
userDatabase.addUser('Charlie', 'charlie@ex.com', 'moderator');

console.log(userDatabase.getStats());
// {
//   total: 3,
//   active: 3,
//   byRole: { admin: 1, user: 1, moderator: 1 }
// }
```

### Example 2: Configuration Manager (Advanced)

```javascript
/**
 * Configuration with Getters/Setters and Validation
 * Demonstrates: getters, setters, computed properties
 */

const config = {
  _host: 'localhost',
  _port: 3000,
  _protocol: 'http',
  _apiVersion: 'v1',

  get host() {
    return this._host;
  },

  set host(value) {
    if (typeof value !== 'string' || value.trim() === '') {
      throw new Error('Host must be a non-empty string');
    }
    this._host = value;
  },

  get port() {
    return this._port;
  },

  set port(value) {
    if (!Number.isInteger(value) || value < 1 || value > 65535) {
      throw new Error('Port must be between 1 and 65535');
    }
    this._port = value;
  },

  get protocol() {
    return this._protocol;
  },

  set protocol(value) {
    if (!['http', 'https'].includes(value)) {
      throw new Error('Protocol must be http or https');
    }
    this._protocol = value;
  },

  // Computed properties
  get baseUrl() {
    return `${this.protocol}://${this.host}:${this.port}`;
  },

  get apiUrl() {
    return `${this.baseUrl}/api/${this._apiVersion}`;
  },

  // Methods
  toJSON() {
    return {
      host: this.host,
      port: this.port,
      protocol: this.protocol,
      baseUrl: this.baseUrl,
      apiUrl: this.apiUrl
    };
  }
};

console.log(config.baseUrl); // 'http://localhost:3000'
console.log(config.apiUrl);  // 'http://localhost:3000/api/v1'

config.protocol = 'https';
config.port = 443;
console.log(config.baseUrl); // 'https://localhost:443'
```

### Example 3: Shopping Cart with Calculations (Complex)

```javascript
/**
 * Shopping Cart with Dynamic Calculations
 * Demonstrates: methods, reduce, getters, object manipulation
 */

const shoppingCart = {
  items: [],
  taxRate: 0.08,
  discountCode: null,
  discountRates: {
    'SAVE10': 0.10,
    'SAVE20': 0.20
  },

  addItem(product, quantity = 1) {
    const existingItem = this.items.find(item => item.product.id === product.id);

    if (existingItem) {
      existingItem.quantity += quantity;
    } else {
      this.items.push({
        product: { ...product },
        quantity
      });
    }
    return this;
  },

  removeItem(productId) {
    this.items = this.items.filter(item => item.product.id !== productId);
    return this;
  },

  updateQuantity(productId, quantity) {
    const item = this.items.find(item => item.product.id === productId);
    if (item) {
      item.quantity = quantity;
    }
    return this;
  },

  applyDiscount(code) {
    if (this.discountRates[code]) {
      this.discountCode = code;
    }
    return this;
  },

  get subtotal() {
    return this.items.reduce((sum, item) => {
      return sum + (item.product.price * item.quantity);
    }, 0);
  },

  get discount() {
    if (!this.discountCode) return 0;
    const rate = this.discountRates[this.discountCode];
    return this.subtotal * rate;
  },

  get tax() {
    return (this.subtotal - this.discount) * this.taxRate;
  },

  get total() {
    return this.subtotal - this.discount + this.tax;
  },

  getSummary() {
    return {
      itemCount: this.items.reduce((sum, item) => sum + item.quantity, 0),
      subtotal: this.subtotal.toFixed(2),
      discount: this.discount.toFixed(2),
      tax: this.tax.toFixed(2),
      total: this.total.toFixed(2)
    };
  },

  clear() {
    this.items = [];
    this.discountCode = null;
    return this;
  }
};

// Usage
shoppingCart
  .addItem({ id: 1, name: 'Laptop', price: 999 }, 1)
  .addItem({ id: 2, name: 'Mouse', price: 25 }, 2)
  .applyDiscount('SAVE10');

console.log(shoppingCart.getSummary());
// {
//   itemCount: 3,
//   subtotal: '1049.00',
//   discount: '104.90',
//   tax: '75.53',
//   total: '1019.63'
// }
```

---

## Exercises

### Exercise 1: Object Basics (Easy)

**Task:** Create a `book` object with properties: title, author, year, pages. Add a method `getSummary()` that returns a formatted string.

```javascript
// Example
const book = createBook('1984', 'George Orwell', 1949, 328);
book.getSummary(); // "1984 by George Orwell (1949), 328 pages"
```

**Solution:** See `solutions/09_objects_fundamentals_solutions.js`

---

### Exercise 2: Property Manipulation (Easy)

**Task:** Write functions:
- `addProperty(obj, key, value)` - adds property to object
- `removeProperty(obj, key)` - removes property from object
- `hasProperty(obj, key)` - checks if property exists

**Solution:** See solutions file.

---

### Exercise 3: Object Merging (Medium)

**Task:** Write a function `deepMerge(target, source)` that merges two objects, including nested objects.

```javascript
// Example
const obj1 = { a: 1, b: { c: 2 } };
const obj2 = { b: { d: 3 }, e: 4 };
deepMerge(obj1, obj2); // { a: 1, b: { c: 2, d: 3 }, e: 4 }
```

**Solution:** See solutions file.

---

### Exercise 4: Getters and Setters (Medium)

**Task:** Create a `Rectangle` object with private `_width` and `_height` properties. Implement:
- Getters/setters for width and height (validate > 0)
- Getter for `area`
- Getter for `perimeter`

**Solution:** See solutions file.

---

### Exercise 5: Object Transformation (Medium)

**Task:** Write a function `transformKeys(obj, transformFn)` that creates a new object with transformed keys.

```javascript
// Example
const obj = { first_name: 'Alice', last_name: 'Smith' };
const camelCase = str => str.replace(/_([a-z])/g, (_, l) => l.toUpperCase());
transformKeys(obj, camelCase); // { firstName: 'Alice', lastName: 'Smith' }
```

**Solution:** See solutions file.

---

### Exercise 6: Inventory System (Hard)

**Task:** Create an `inventory` object with methods:
- `addProduct(id, name, quantity, price)`
- `removeProduct(id)`
- `updateStock(id, quantity)` - add to stock
- `sellProduct(id, quantity)` - reduce stock
- `getLowStock(threshold)` - products below threshold
- `getTotalValue()` - total inventory value

**Solution:** See solutions file.

---

### Exercise 7: Object Validation (Hard)

**Task:** Create a `validator` object that validates user registration data:
- Username: 3-20 chars, alphanumeric
- Email: valid email format
- Age: 18+
- Password: 8+ chars, at least one number

Return object with `isValid` boolean and `errors` array.

**Solution:** See solutions file.

---

## Testing & Verification

### Manual Testing

```javascript
// Test object creation
const testCreation = () => {
  const user = { name: 'Alice', age: 25 };
  console.assert(user.name === 'Alice', 'Name should be Alice');
  console.assert(user.age === 25, 'Age should be 25');
  console.log('✅ Object creation tests passed');
};

// Test property access
const testAccess = () => {
  const obj = { name: 'Test', 'key-name': 'value' };
  console.assert(obj.name === 'Test', 'Dot notation works');
  console.assert(obj['key-name'] === 'value', 'Bracket notation works');
  console.log('✅ Property access tests passed');
};

testCreation();
testAccess();
```

### Using Vitest

```javascript
// objects.test.js
import { describe, it, expect } from 'vitest';

describe('Object Operations', () => {
  describe('Property access', () => {
    it('should access properties with dot notation', () => {
      const user = { name: 'Alice', age: 25 };
      expect(user.name).toBe('Alice');
      expect(user.age).toBe(25);
    });

    it('should access properties with bracket notation', () => {
      const obj = { 'key-name': 'value' };
      expect(obj['key-name']).toBe('value');
    });
  });

  describe('Object methods', () => {
    it('should execute methods with correct this context', () => {
      const user = {
        name: 'Alice',
        greet() {
          return `Hello, ${this.name}`;
        }
      };
      expect(user.greet()).toBe('Hello, Alice');
    });
  });

  describe('Destructuring', () => {
    it('should destructure object properties', () => {
      const user = { name: 'Alice', age: 25 };
      const { name, age } = user;
      expect(name).toBe('Alice');
      expect(age).toBe(25);
    });

    it('should provide default values', () => {
      const user = { name: 'Alice' };
      const { name, age = 18 } = user;
      expect(age).toBe(18);
    });
  });
});
```

---

## Best Practices

### 1. Use Object Literals

```javascript
// ✅ Concise and clear
const user = { name: 'Alice', age: 25 };

// ❌ Verbose
const user = new Object();
user.name = 'Alice';
user.age = 25;
```

### 2. Consistent Property Access

```javascript
// ✅ Use dot notation for known properties
user.name
user.email

// ✅ Use bracket notation for dynamic/invalid identifiers
user[propertyName]
user['first-name']
```

### 3. Avoid Modifying Prototypes

```javascript
// ❌ Never do this
Object.prototype.myMethod = function() {};

// ✅ Use composition or classes
```

### 4. Use Shorthand Syntax

```javascript
// ✅ Modern syntax
const createUser = (name, email) => ({ name, email });

// ❌ Redundant
const createUser = (name, email) => ({ name: name, email: email });
```

### 5. Validate in Setters

```javascript
// ✅ Validate input
set age(value) {
  if (value < 0) throw new Error('Age cannot be negative');
  this._age = value;
}

// ❌ No validation
set age(value) {
  this._age = value;
}
```

---

## Common Pitfalls

### 1. this Context Loss

```javascript
// ❌ Problem
const greetFn = user.greet;
greetFn(); // 'this' is undefined

// ✅ Solution
const greetFn = user.greet.bind(user);
```

### 2. Arrow Functions as Methods

```javascript
// ❌ Arrow function - wrong 'this'
const obj = {
  name: 'Alice',
  greet: () => console.log(this.name) // undefined
};

// ✅ Regular function
const obj = {
  name: 'Alice',
  greet() { console.log(this.name); }
};
```

### 3. Shallow Copy Issues

```javascript
// ❌ Nested objects still referenced
const copy = { ...original };
copy.nested.value = 'changed'; // Affects original!

// ✅ Deep copy nested objects
const copy = {
  ...original,
  nested: { ...original.nested }
};
```

### 4. Forgetting Quotes for Invalid Keys

```javascript
// ❌ Syntax error
const obj = { first-name: 'Alice' };

// ✅ Quotes needed
const obj = { 'first-name': 'Alice' };
```

### 5. Checking Property Existence

```javascript
// ❌ Doesn't distinguish undefined value from missing property
if (obj.prop === undefined) {}

// ✅ Check existence explicitly
if ('prop' in obj) {}
if (obj.hasOwnProperty('prop')) {}
```

---

## Summary & Next Steps

### Key Takeaways

- **Objects store key-value pairs** for entity representation
- **Multiple creation methods**: literals (best), constructors, Object.create()
- **Property access**: dot (static), bracket (dynamic/invalid identifiers)
- **Methods**: Functions with `this` context
- **Destructuring & spread**: Modern ES6+ features for manipulation
- **Object.keys/values/entries**: Iterate and transform objects
- **Getters/setters**: Controlled property access and validation
- **Shallow vs deep copy**: Be aware of nested object references

### Related Topics

- [Arrays Fundamentals](./07.Arrays_Fundamentals.md)
- [Reference Types & Memory](./10.Reference_Types_And_Memory.md)
- [Classes and Inheritance](../11.Classes_and_inheritance/01.classes.md)

### Further Reading

- [MDN: Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
- [JavaScript.info: Objects](https://javascript.info/object)
- [Understanding 'this' in JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this)

---

## References

1. **MDN Web Docs**: [Working with Objects](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects)
2. **ECMAScript Specification**: [Object Type](https://tc39.es/ecma262/#sec-object-type)
3. **JavaScript.info**: [Objects Tutorial](https://javascript.info/object)
4. **Eloquent JavaScript**: [Data Structures: Objects and Arrays](https://eloquentjavascript.net/04_data.html)

---

**Last Updated:** 2025-11-22
**Version:** 1.0.0
**Curriculum:** JavaScript for Backend Development
