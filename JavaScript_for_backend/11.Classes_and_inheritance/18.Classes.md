# ES6 Classes in JavaScript

**Difficulty:** Intermediate
**Estimated Time:** 60-75 minutes
**Prerequisites:** Objects, functions, prototypes, `this` keyword, ES6 syntax
**Target:** Node.js 18+ LTS, Modern Browsers (ES2021+)

---

## Learning Objectives

By the end of this lesson, you will be able to:

1. Understand the class syntax and how it relates to constructor functions and prototypes
2. Create classes with constructors, methods, and properties
3. Implement static methods and properties for class-level functionality
4. Use getters and setters for controlled property access
5. Work with public and private fields (including the # syntax)
6. Utilize class expressions and anonymous classes
7. Compare classes with constructor functions and understand when to use each
8. Master the `this` keyword behavior in classes
9. Apply class patterns in real-world backend development
10. Debug common class-related issues

---

## Table of Contents

1. [Introduction](#introduction)
2. [Class Syntax Fundamentals](#class-syntax-fundamentals)
3. [Constructors in Classes](#constructors-in-classes)
4. [Methods](#methods)
5. [Getters and Setters](#getters-and-setters)
6. [Static Methods and Properties](#static-methods-and-properties)
7. [Public and Private Fields](#public-and-private-fields)
8. [Class Expressions](#class-expressions)
9. [Classes vs Constructor Functions](#classes-vs-constructor-functions)
10. [The `this` Keyword in Classes](#the-this-keyword-in-classes)
11. [Worked Examples](#worked-examples)
12. [Exercises](#exercises)
13. [Testing & Verification](#testing--verification)
14. [Best Practices](#best-practices)
15. [Common Pitfalls](#common-pitfalls)
16. [Performance Considerations](#performance-considerations)
17. [Summary & Next Steps](#summary--next-steps)
18. [References](#references)

---

## Introduction

Classes in JavaScript (introduced in ES6/ES2015) provide a cleaner, more intuitive syntax for creating objects and implementing object-oriented programming patterns. While JavaScript's class syntax is **syntactic sugar** over the existing prototype-based inheritance model, it offers significant improvements in readability and developer experience.

**Why Classes Matter:**

- **Clarity:** More readable and intuitive than constructor functions
- **Structure:** Clear organization of properties and methods
- **Familiarity:** Syntax similar to other OOP languages (Java, C++, Python)
- **Modern Features:** Support for private fields, static members, and more
- **Maintainability:** Easier to understand and modify
- **Industry Standard:** Widely used in modern JavaScript codebases

**Real-World Applications:**

In backend development (Node.js), classes are used for:
- Database models and ORM entities
- Service layer implementations
- API controllers and middleware
- Business logic encapsulation
- Error handling with custom error classes
- Design patterns (Factory, Singleton, Builder, etc.)

---

## Class Syntax Fundamentals

### Basic Class Declaration

A class is declared using the `class` keyword followed by the class name (conventionally in PascalCase).

```javascript
class User {
  // Class body
}

// Creating an instance
const user = new User();
console.log(user); // User {}
```

### Class Naming Conventions

```javascript
// ✅ CORRECT: PascalCase for class names
class StudentRecord {}
class DatabaseConnection {}
class HttpRequest {}

// ❌ WRONG: camelCase or lowercase
class studentRecord {}  // Incorrect
class database_connection {}  // Incorrect
```

### Class Anatomy

```javascript
class Product {
  // Constructor (runs when new instance is created)
  constructor(name, price) {
    this.name = name;
    this.price = price;
  }

  // Instance method
  getDetails() {
    return `${this.name}: $${this.price}`;
  }

  // Static method (belongs to class, not instances)
  static compare(product1, product2) {
    return product1.price - product2.price;
  }
}

// Usage
const laptop = new Product('MacBook Pro', 2499);
console.log(laptop.getDetails()); // "MacBook Pro: $2499"
console.log(Product.compare(laptop, new Product('iPad', 799))); // 1700
```

---

## Constructors in Classes

The **constructor** is a special method that initializes new objects. It runs automatically when you create an instance with `new`.

### Basic Constructor

```javascript
class Student {
  constructor(name, age, course) {
    this.name = name;
    this.age = age;
    this.course = course;
    this.enrollmentDate = new Date();
  }
}

const alice = new Student('Alice', 20, 'Computer Science');
console.log(alice.name);  // "Alice"
console.log(alice.enrollmentDate);  // Current date
```

### Constructor with Validation

```javascript
class BankAccount {
  constructor(accountNumber, initialBalance) {
    if (initialBalance < 0) {
      throw new Error('Initial balance cannot be negative');
    }

    if (typeof accountNumber !== 'string') {
      throw new TypeError('Account number must be a string');
    }

    this.accountNumber = accountNumber;
    this.balance = initialBalance;
    this.transactions = [];
  }
}

const account = new BankAccount('ACC001', 1000);  // ✅ Valid
// const invalidAccount = new BankAccount('ACC002', -100);  // ❌ Throws error
```

### Constructor with Default Values

```javascript
class Configuration {
  constructor({
    host = 'localhost',
    port = 3000,
    environment = 'development',
    debug = false
  } = {}) {
    this.host = host;
    this.port = port;
    this.environment = environment;
    this.debug = debug;
  }

  getConnectionString() {
    return `${this.host}:${this.port}`;
  }
}

// Usage with defaults
const config1 = new Configuration();
console.log(config1.host);  // "localhost"

// Usage with custom values
const config2 = new Configuration({ host: 'api.example.com', port: 8080 });
console.log(config2.getConnectionString());  // "api.example.com:8080"
```

### Only One Constructor Allowed

```javascript
class Example {
  constructor(value) {
    this.value = value;
  }

  // ❌ ERROR: Only one constructor allowed
  // constructor(value, name) {
  //   this.value = value;
  //   this.name = name;
  // }
}

// Solution: Use default parameters or factory methods
class Example2 {
  constructor(value, name = 'default') {
    this.value = value;
    this.name = name;
  }

  static create(value) {
    return new Example2(value);
  }

  static createWithName(value, name) {
    return new Example2(value, name);
  }
}
```

---

## Methods

Methods are functions defined inside a class that operate on instance data.

### Instance Methods

```javascript
class Rectangle {
  constructor(width, height) {
    this.width = width;
    this.height = height;
  }

  // Instance method
  calculateArea() {
    return this.width * this.height;
  }

  calculatePerimeter() {
    return 2 * (this.width + this.height);
  }

  resize(newWidth, newHeight) {
    this.width = newWidth;
    this.height = newHeight;
  }

  isSquare() {
    return this.width === this.height;
  }
}

const rect = new Rectangle(10, 20);
console.log(rect.calculateArea());       // 200
console.log(rect.calculatePerimeter());  // 60
console.log(rect.isSquare());            // false
```

### Methods with Complex Logic

```javascript
class OrderProcessor {
  constructor(orderId) {
    this.orderId = orderId;
    this.items = [];
    this.status = 'pending';
  }

  addItem(product, quantity, price) {
    this.items.push({ product, quantity, price });
  }

  calculateTotal() {
    return this.items.reduce((total, item) => {
      return total + (item.quantity * item.price);
    }, 0);
  }

  applyDiscount(percentage) {
    const total = this.calculateTotal();
    const discount = total * (percentage / 100);
    return total - discount;
  }

  process() {
    if (this.items.length === 0) {
      throw new Error('Cannot process order with no items');
    }

    this.status = 'processing';
    const total = this.calculateTotal();

    // Simulate processing logic
    console.log(`Processing order ${this.orderId} - Total: $${total}`);
    this.status = 'completed';

    return {
      orderId: this.orderId,
      total,
      itemCount: this.items.length,
      status: this.status
    };
  }
}

const order = new OrderProcessor('ORD-001');
order.addItem('Laptop', 1, 999);
order.addItem('Mouse', 2, 25);
console.log(order.calculateTotal());  // 1049
console.log(order.applyDiscount(10)); // 944.1
console.log(order.process());
```

### Method Chaining

```javascript
class QueryBuilder {
  constructor(table) {
    this.table = table;
    this.whereClause = '';
    this.orderClause = '';
    this.limitValue = null;
  }

  where(condition) {
    this.whereClause = condition;
    return this;  // Return this for chaining
  }

  orderBy(column) {
    this.orderClause = column;
    return this;
  }

  limit(count) {
    this.limitValue = count;
    return this;
  }

  build() {
    let query = `SELECT * FROM ${this.table}`;
    if (this.whereClause) query += ` WHERE ${this.whereClause}`;
    if (this.orderClause) query += ` ORDER BY ${this.orderClause}`;
    if (this.limitValue) query += ` LIMIT ${this.limitValue}`;
    return query;
  }
}

// Method chaining in action
const query = new QueryBuilder('users')
  .where('age > 18')
  .orderBy('name')
  .limit(10)
  .build();

console.log(query);
// "SELECT * FROM users WHERE age > 18 ORDER BY name LIMIT 10"
```

---

## Getters and Setters

Getters and setters provide controlled access to object properties with computed values or validation.

### Basic Getters and Setters

```javascript
class Temperature {
  constructor(celsius) {
    this._celsius = celsius;
  }

  // Getter - accessed like a property
  get celsius() {
    return this._celsius;
  }

  // Setter - assigned like a property
  set celsius(value) {
    if (typeof value !== 'number') {
      throw new TypeError('Temperature must be a number');
    }
    this._celsius = value;
  }

  get fahrenheit() {
    return (this._celsius * 9/5) + 32;
  }

  set fahrenheit(value) {
    this._celsius = (value - 32) * 5/9;
  }
}

const temp = new Temperature(25);
console.log(temp.celsius);     // 25
console.log(temp.fahrenheit);  // 77

temp.fahrenheit = 86;
console.log(temp.celsius);     // 30
```

### Getters for Computed Properties

```javascript
class Person {
  constructor(firstName, lastName, birthYear) {
    this.firstName = firstName;
    this.lastName = lastName;
    this.birthYear = birthYear;
  }

  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }

  get age() {
    return new Date().getFullYear() - this.birthYear;
  }

  get initials() {
    return `${this.firstName[0]}${this.lastName[0]}`.toUpperCase();
  }
}

const person = new Person('John', 'Doe', 1990);
console.log(person.fullName);  // "John Doe"
console.log(person.age);       // 34 (in 2024)
console.log(person.initials);  // "JD"
```

### Setters with Validation

```javascript
class UserAccount {
  constructor(username, email) {
    this._username = username;
    this._email = email;
    this._password = null;
  }

  get username() {
    return this._username;
  }

  set username(value) {
    if (value.length < 3) {
      throw new Error('Username must be at least 3 characters');
    }
    if (!/^[a-zA-Z0-9_]+$/.test(value)) {
      throw new Error('Username can only contain letters, numbers, and underscores');
    }
    this._username = value;
  }

  get email() {
    return this._email;
  }

  set email(value) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(value)) {
      throw new Error('Invalid email format');
    }
    this._email = value;
  }

  set password(value) {
    if (value.length < 8) {
      throw new Error('Password must be at least 8 characters');
    }
    // In production, hash the password
    this._password = value;
  }
}

const user = new UserAccount('john_doe', 'john@example.com');
user.password = 'securePass123';
console.log(user.username);  // "john_doe"
// user.username = 'ab';  // ❌ Throws error: too short
```

---

## Static Methods and Properties

Static members belong to the class itself, not to instances. They're useful for utility functions and class-level data.

### Static Methods

```javascript
class MathUtils {
  static add(a, b) {
    return a + b;
  }

  static multiply(a, b) {
    return a * b;
  }

  static factorial(n) {
    if (n === 0 || n === 1) return 1;
    return n * MathUtils.factorial(n - 1);
  }

  static isPrime(num) {
    if (num < 2) return false;
    for (let i = 2; i <= Math.sqrt(num); i++) {
      if (num % i === 0) return false;
    }
    return true;
  }
}

// Called on the class, not on instances
console.log(MathUtils.add(5, 3));        // 8
console.log(MathUtils.factorial(5));     // 120
console.log(MathUtils.isPrime(17));      // true

// ❌ Cannot call on instances
const math = new MathUtils();
// math.add(5, 3);  // TypeError: math.add is not a function
```

### Static Properties

```javascript
class Config {
  static API_URL = 'https://api.example.com';
  static VERSION = '1.0.0';
  static MAX_RETRIES = 3;
  static TIMEOUT = 5000;

  static getFullUrl(endpoint) {
    return `${Config.API_URL}${endpoint}`;
  }
}

console.log(Config.API_URL);           // "https://api.example.com"
console.log(Config.getFullUrl('/users'));  // "https://api.example.com/users"
```

### Static Factory Methods

```javascript
class User {
  constructor(id, name, email, role) {
    this.id = id;
    this.name = name;
    this.email = email;
    this.role = role;
  }

  // Static factory method for creating admin users
  static createAdmin(id, name, email) {
    return new User(id, name, email, 'admin');
  }

  // Static factory method for creating regular users
  static createRegular(id, name, email) {
    return new User(id, name, email, 'user');
  }

  // Static factory method from API response
  static fromAPIResponse(data) {
    return new User(data.id, data.full_name, data.email_address, data.user_role);
  }
}

const admin = User.createAdmin(1, 'Alice', 'alice@example.com');
const user = User.createRegular(2, 'Bob', 'bob@example.com');

console.log(admin.role);  // "admin"
console.log(user.role);   // "user"
```

### Instance Counter with Static Property

```javascript
class DatabaseConnection {
  static connectionCount = 0;
  static maxConnections = 10;

  constructor(host, database) {
    if (DatabaseConnection.connectionCount >= DatabaseConnection.maxConnections) {
      throw new Error('Maximum connection limit reached');
    }

    this.host = host;
    this.database = database;
    this.connected = false;

    DatabaseConnection.connectionCount++;
  }

  connect() {
    this.connected = true;
    console.log(`Connected to ${this.database} on ${this.host}`);
  }

  disconnect() {
    if (this.connected) {
      this.connected = false;
      DatabaseConnection.connectionCount--;
      console.log(`Disconnected from ${this.database}`);
    }
  }

  static getActiveConnections() {
    return DatabaseConnection.connectionCount;
  }
}

const db1 = new DatabaseConnection('localhost', 'users_db');
const db2 = new DatabaseConnection('localhost', 'products_db');

db1.connect();
db2.connect();

console.log(DatabaseConnection.getActiveConnections());  // 2
```

---

## Public and Private Fields

Modern JavaScript supports public and private class fields, providing true encapsulation.

### Public Fields

```javascript
class Product {
  // Public fields (can be accessed from outside)
  name = '';
  price = 0;
  inStock = true;

  constructor(name, price) {
    this.name = name;
    this.price = price;
  }
}

const product = new Product('Laptop', 999);
console.log(product.name);   // "Laptop" - accessible
product.price = 1099;        // Can be modified
```

### Private Fields (# Syntax)

```javascript
class BankAccount {
  // Private fields - start with #
  #balance = 0;
  #accountNumber;
  #pin;

  constructor(accountNumber, initialBalance, pin) {
    this.#accountNumber = accountNumber;
    this.#balance = initialBalance;
    this.#pin = pin;
  }

  // Public method to access private field
  getBalance() {
    return this.#balance;
  }

  deposit(amount) {
    if (amount > 0) {
      this.#balance += amount;
      return this.#balance;
    }
    throw new Error('Deposit amount must be positive');
  }

  withdraw(amount, pin) {
    if (!this.#verifyPin(pin)) {
      throw new Error('Invalid PIN');
    }

    if (amount > this.#balance) {
      throw new Error('Insufficient funds');
    }

    this.#balance -= amount;
    return this.#balance;
  }

  // Private method
  #verifyPin(pin) {
    return this.#pin === pin;
  }
}

const account = new BankAccount('ACC123', 1000, '1234');
console.log(account.getBalance());  // 1000

account.deposit(500);
console.log(account.getBalance());  // 1500

// ❌ Cannot access private fields directly
// console.log(account.#balance);  // SyntaxError
// account.#balance = 10000;       // SyntaxError
```

### Private Methods

```javascript
class PasswordManager {
  #password;
  #salt;

  constructor() {
    this.#salt = this.#generateSalt();
  }

  setPassword(password) {
    if (password.length < 8) {
      throw new Error('Password too short');
    }
    this.#password = this.#hash(password);
  }

  verifyPassword(password) {
    return this.#hash(password) === this.#password;
  }

  // Private method for hashing
  #hash(value) {
    // Simplified hashing (use bcrypt in production)
    return `${value}_${this.#salt}`;
  }

  // Private method for salt generation
  #generateSalt() {
    return Math.random().toString(36).substring(2, 15);
  }
}

const pm = new PasswordManager();
pm.setPassword('mySecurePass');
console.log(pm.verifyPassword('mySecurePass'));   // true
console.log(pm.verifyPassword('wrongPassword'));  // false

// ❌ Cannot call private methods
// pm.#hash('test');  // SyntaxError
```

### Combining Public and Private

```javascript
class ShoppingCart {
  // Public fields
  customerId;
  createdAt = new Date();

  // Private fields
  #items = [];
  #discount = 0;

  constructor(customerId) {
    this.customerId = customerId;
  }

  addItem(product, quantity, price) {
    this.#items.push({ product, quantity, price });
  }

  removeItem(productName) {
    this.#items = this.#items.filter(item => item.product !== productName);
  }

  applyDiscount(code) {
    this.#discount = this.#validateDiscount(code);
  }

  getTotal() {
    const subtotal = this.#calculateSubtotal();
    return subtotal - this.#discount;
  }

  getItemCount() {
    return this.#items.length;
  }

  // Private helper methods
  #calculateSubtotal() {
    return this.#items.reduce((sum, item) => {
      return sum + (item.quantity * item.price);
    }, 0);
  }

  #validateDiscount(code) {
    const discountCodes = {
      'SAVE10': 10,
      'SAVE20': 20,
      'SAVE50': 50
    };
    return discountCodes[code] || 0;
  }
}

const cart = new ShoppingCart('CUST001');
cart.addItem('Laptop', 1, 999);
cart.addItem('Mouse', 2, 25);
cart.applyDiscount('SAVE10');

console.log(cart.getTotal());      // 1039 (1049 - 10)
console.log(cart.getItemCount());  // 2
```

---

## Class Expressions

Classes can be defined as expressions, similar to function expressions.

### Named Class Expression

```javascript
const Rectangle = class RectangleClass {
  constructor(width, height) {
    this.width = width;
    this.height = height;
  }

  getArea() {
    return this.width * this.height;
  }
};

const rect = new Rectangle(10, 5);
console.log(rect.getArea());  // 50

// Class name is only available inside the class
// RectangleClass  // ReferenceError
```

### Anonymous Class Expression

```javascript
const Circle = class {
  constructor(radius) {
    this.radius = radius;
  }

  getArea() {
    return Math.PI * this.radius ** 2;
  }

  getCircumference() {
    return 2 * Math.PI * this.radius;
  }
};

const circle = new Circle(5);
console.log(circle.getArea().toFixed(2));  // 78.54
```

### Class Expression as Function Argument

```javascript
function createInstance(ClassDefinition, ...args) {
  return new ClassDefinition(...args);
}

const user = createInstance(class {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  greet() {
    return `Hello, I'm ${this.name}`;
  }
}, 'Alice', 30);

console.log(user.greet());  // "Hello, I'm Alice"
```

### Factory Pattern with Class Expressions

```javascript
function createLogger(type) {
  if (type === 'console') {
    return class ConsoleLogger {
      log(message) {
        console.log(`[CONSOLE] ${message}`);
      }
    };
  } else if (type === 'file') {
    return class FileLogger {
      log(message) {
        console.log(`[FILE] ${message}`);
      }
    };
  }
}

const ConsoleLogger = createLogger('console');
const logger = new ConsoleLogger();
logger.log('Application started');  // "[CONSOLE] Application started"
```

---

## Classes vs Constructor Functions

Classes are syntactic sugar over JavaScript's prototype-based inheritance, but they offer cleaner syntax and additional features.

### Constructor Function (Old Way)

```javascript
function Person(name, age) {
  this.name = name;
  this.age = age;
}

Person.prototype.greet = function() {
  return `Hello, I'm ${this.name}`;
};

Person.createChild = function(name) {
  return new Person(name, 0);
};

const person = new Person('Alice', 30);
console.log(person.greet());
```

### Class Syntax (Modern Way)

```javascript
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  greet() {
    return `Hello, I'm ${this.name}`;
  }

  static createChild(name) {
    return new Person(name, 0);
  }
}

const person = new Person('Alice', 30);
console.log(person.greet());
```

### Key Differences

| Feature | Constructor Function | Class |
|---------|---------------------|-------|
| Syntax | Function-based | Class keyword |
| Methods | Added to prototype manually | Defined in class body |
| Static methods | Added as function properties | `static` keyword |
| Hoisting | Function hoisted | Not hoisted (TDZ) |
| `new` requirement | Optional (can be checked) | Mandatory (error without) |
| Private fields | Not supported | Supported with # |
| Inheritance | Manual prototype chain | `extends` keyword |

### Class Advantages

```javascript
// ✅ Classes enforce 'new'
class User {
  constructor(name) {
    this.name = name;
  }
}

// const user = User('Alice');  // ❌ TypeError: Class constructor cannot be invoked without 'new'

// ✅ Classes have cleaner method syntax
class Calculator {
  add(a, b) { return a + b; }
  multiply(a, b) { return a * b; }
}

// ✅ Classes support private fields
class Secret {
  #value = 42;
  getValue() { return this.#value; }
}
```

---

## The `this` Keyword in Classes

Understanding `this` is crucial for working with classes effectively.

### `this` in Methods

```javascript
class Counter {
  constructor() {
    this.count = 0;
  }

  increment() {
    this.count++;  // 'this' refers to the instance
  }

  getValue() {
    return this.count;
  }
}

const counter = new Counter();
counter.increment();
console.log(counter.getValue());  // 1
```

### Losing `this` Context

```javascript
class Button {
  constructor(label) {
    this.label = label;
    this.clickCount = 0;
  }

  click() {
    this.clickCount++;
    console.log(`${this.label} clicked ${this.clickCount} times`);
  }
}

const btn = new Button('Submit');

// Direct call - works fine
btn.click();  // "Submit clicked 1 times"

// Losing context when passing method as callback
setTimeout(btn.click, 1000);  // ❌ TypeError: Cannot read property 'clickCount' of undefined
```

### Solutions for Context Loss

#### Solution 1: Arrow Function Wrapper

```javascript
setTimeout(() => btn.click(), 1000);  // ✅ Works
```

#### Solution 2: bind()

```javascript
setTimeout(btn.click.bind(btn), 1000);  // ✅ Works
```

#### Solution 3: Arrow Function Method (Class Field)

```javascript
class Button {
  constructor(label) {
    this.label = label;
    this.clickCount = 0;
  }

  // Arrow function automatically binds 'this'
  click = () => {
    this.clickCount++;
    console.log(`${this.label} clicked ${this.clickCount} times`);
  }
}

const btn = new Button('Submit');
setTimeout(btn.click, 1000);  // ✅ Works
```

### `this` in Static Methods

```javascript
class Example {
  static className = 'Example';

  static getClassName() {
    return this.className;  // 'this' refers to the class itself
  }

  static createInstance() {
    return new this();  // 'this' is the class constructor
  }
}

console.log(Example.getClassName());  // "Example"
```

---

## Worked Examples

### Example 1: User Authentication System

```javascript
class AuthenticationSystem {
  #users = new Map();
  #sessions = new Map();

  registerUser(username, password, email) {
    if (this.#users.has(username)) {
      throw new Error('Username already exists');
    }

    const user = {
      username,
      password: this.#hashPassword(password),
      email,
      createdAt: new Date(),
      isActive: true
    };

    this.#users.set(username, user);
    return { username, email, createdAt: user.createdAt };
  }

  login(username, password) {
    const user = this.#users.get(username);

    if (!user || !user.isActive) {
      throw new Error('Invalid credentials');
    }

    if (this.#hashPassword(password) !== user.password) {
      throw new Error('Invalid credentials');
    }

    const sessionId = this.#generateSessionId();
    this.#sessions.set(sessionId, { username, loginTime: new Date() });

    return sessionId;
  }

  logout(sessionId) {
    return this.#sessions.delete(sessionId);
  }

  isAuthenticated(sessionId) {
    return this.#sessions.has(sessionId);
  }

  #hashPassword(password) {
    // Simplified hashing (use bcrypt in production)
    return `hashed_${password}`;
  }

  #generateSessionId() {
    return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  getUserCount() {
    return this.#users.size;
  }

  getActiveSessionCount() {
    return this.#sessions.size;
  }
}

// Usage
const auth = new AuthenticationSystem();

auth.registerUser('alice', 'password123', 'alice@example.com');
auth.registerUser('bob', 'securePass', 'bob@example.com');

const sessionId = auth.login('alice', 'password123');
console.log('Logged in:', auth.isAuthenticated(sessionId));  // true

auth.logout(sessionId);
console.log('After logout:', auth.isAuthenticated(sessionId));  // false

console.log('Total users:', auth.getUserCount());  // 2
```

### Example 2: Product Inventory Manager

```javascript
class Product {
  static #nextId = 1;

  #id;
  #costPrice;

  constructor(name, costPrice, sellingPrice, quantity) {
    this.#id = Product.#nextId++;
    this.name = name;
    this.#costPrice = costPrice;
    this.sellingPrice = sellingPrice;
    this.quantity = quantity;
  }

  get id() {
    return this.#id;
  }

  get profit() {
    return this.sellingPrice - this.#costPrice;
  }

  get profitMargin() {
    return ((this.profit / this.sellingPrice) * 100).toFixed(2);
  }

  restock(amount) {
    this.quantity += amount;
  }

  sell(amount) {
    if (amount > this.quantity) {
      throw new Error('Insufficient stock');
    }
    this.quantity -= amount;
  }

  getDetails() {
    return {
      id: this.#id,
      name: this.name,
      sellingPrice: this.sellingPrice,
      quantity: this.quantity,
      profit: this.profit,
      profitMargin: `${this.profitMargin}%`
    };
  }
}

class InventoryManager {
  #products = new Map();

  addProduct(name, costPrice, sellingPrice, quantity) {
    const product = new Product(name, costPrice, sellingPrice, quantity);
    this.#products.set(product.id, product);
    return product.id;
  }

  getProduct(id) {
    return this.#products.get(id);
  }

  sellProduct(id, quantity) {
    const product = this.#products.get(id);
    if (!product) {
      throw new Error('Product not found');
    }
    product.sell(quantity);
  }

  restockProduct(id, quantity) {
    const product = this.#products.get(id);
    if (!product) {
      throw new Error('Product not found');
    }
    product.restock(quantity);
  }

  getTotalInventoryValue() {
    let total = 0;
    for (const product of this.#products.values()) {
      total += product.sellingPrice * product.quantity;
    }
    return total;
  }

  getLowStockProducts(threshold = 10) {
    const lowStock = [];
    for (const product of this.#products.values()) {
      if (product.quantity < threshold) {
        lowStock.push(product.getDetails());
      }
    }
    return lowStock;
  }
}

// Usage
const inventory = new InventoryManager();

const laptop = inventory.addProduct('Laptop', 800, 1200, 15);
const mouse = inventory.addProduct('Mouse', 10, 25, 50);
const keyboard = inventory.addProduct('Keyboard', 30, 60, 8);

inventory.sellProduct(laptop, 3);
inventory.restockProduct(keyboard, 20);

console.log('Total inventory value:', inventory.getTotalInventoryValue());
console.log('Low stock products:', inventory.getLowStockProducts());
```

### Example 3: Task Queue System

```javascript
class Task {
  static STATUS = {
    PENDING: 'pending',
    RUNNING: 'running',
    COMPLETED: 'completed',
    FAILED: 'failed'
  };

  constructor(id, name, priority = 0) {
    this.id = id;
    this.name = name;
    this.priority = priority;
    this.status = Task.STATUS.PENDING;
    this.createdAt = new Date();
    this.completedAt = null;
  }

  execute() {
    // Simulate task execution
    this.status = Task.STATUS.RUNNING;
    return new Promise((resolve) => {
      setTimeout(() => {
        this.status = Task.STATUS.COMPLETED;
        this.completedAt = new Date();
        resolve(this);
      }, 1000);
    });
  }
}

class TaskQueue {
  #queue = [];
  #running = false;
  #maxConcurrent = 3;
  #activeTaskCount = 0;

  enqueue(task) {
    this.#queue.push(task);
    this.#queue.sort((a, b) => b.priority - a.priority);

    if (!this.#running) {
      this.#processQueue();
    }
  }

  async #processQueue() {
    this.#running = true;

    while (this.#queue.length > 0 || this.#activeTaskCount > 0) {
      while (this.#queue.length > 0 && this.#activeTaskCount < this.#maxConcurrent) {
        const task = this.#queue.shift();
        this.#activeTaskCount++;

        task.execute().then(() => {
          this.#activeTaskCount--;
          console.log(`Task ${task.name} completed`);
        });
      }

      await new Promise(resolve => setTimeout(resolve, 100));
    }

    this.#running = false;
  }

  get queueLength() {
    return this.#queue.length;
  }

  get isRunning() {
    return this.#running;
  }
}

// Usage
const queue = new TaskQueue();

queue.enqueue(new Task(1, 'Task 1', 5));
queue.enqueue(new Task(2, 'Task 2', 10));
queue.enqueue(new Task(3, 'Task 3', 1));

console.log('Queue length:', queue.queueLength);
```

---

## Exercises

### Exercise 1: Library Book Manager (Easy)

Create a `Book` class and a `Library` class to manage a collection of books.

**Requirements:**

Book class should have:
- Properties: title, author, isbn, isAvailable
- Method: `getInfo()` returns formatted string
- Method: `toggleAvailability()` changes availability status

Library class should have:
- Private array to store books
- Method: `addBook(book)` adds a book
- Method: `removeBook(isbn)` removes a book
- Method: `findBookByTitle(title)` finds and returns books
- Method: `getAvailableBooks()` returns all available books
- Getter: `bookCount` returns total number of books

**Example:**
```javascript
const library = new Library();
const book1 = new Book('1984', 'George Orwell', '1234567890');
library.addBook(book1);
console.log(library.bookCount);  // 1
console.log(library.getAvailableBooks());
```

---

### Exercise 2: Bank Account with Transaction History (Medium)

Create a `BankAccount` class with private balance and transaction history.

**Requirements:**
- Private fields: `#balance`, `#transactions`, `#accountNumber`
- Constructor: takes accountNumber and initialBalance
- Methods:
  - `deposit(amount)` - adds to balance, records transaction
  - `withdraw(amount)` - subtracts from balance, records transaction (prevent overdraft)
  - `getBalance()` - returns current balance
  - `getTransactionHistory()` - returns copy of transactions
  - `calculateInterest(rate)` - calculates and adds interest to balance
- Each transaction should record: type, amount, timestamp, balanceAfter

**Example:**
```javascript
const account = new BankAccount('ACC001', 1000);
account.deposit(500);
account.withdraw(200);
console.log(account.getBalance());  // 1300
console.log(account.getTransactionHistory());
```

---

### Exercise 3: Configurable Validation System (Medium)

Create a `Validator` class that can validate different types of inputs with configurable rules.

**Requirements:**
- Static method `createEmailValidator()` returns validator for emails
- Static method `createPasswordValidator(minLength, requireSpecial)` returns configurable password validator
- Static method `createNumberValidator(min, max)` returns number range validator
- Each validator should have:
  - `validate(value)` method returns { isValid: boolean, errors: string[] }
  - Appropriate validation logic
- Use private methods for individual validation checks

**Example:**
```javascript
const emailValidator = Validator.createEmailValidator();
console.log(emailValidator.validate('test@example.com'));
// { isValid: true, errors: [] }

const passwordValidator = Validator.createPasswordValidator(8, true);
console.log(passwordValidator.validate('weak'));
// { isValid: false, errors: ['Password too short', 'Missing special character'] }
```

---

### Exercise 4: Cache with TTL (Time To Live) (Hard)

Create a `Cache` class that stores key-value pairs with expiration times.

**Requirements:**
- Private Map to store cache entries
- Each entry should store: value, timestamp, ttl (time to live in milliseconds)
- Methods:
  - `set(key, value, ttl)` - stores value with expiration
  - `get(key)` - returns value if not expired, null otherwise
  - `has(key)` - returns true if key exists and not expired
  - `delete(key)` - removes entry
  - `clear()` - removes all entries
  - `cleanup()` - removes all expired entries
- Automatically clean up expired entries on get operations
- Getter `size` returns count of non-expired entries
- Static default TTL property

**Example:**
```javascript
const cache = new Cache();
cache.set('user', { name: 'Alice' }, 5000);  // 5 second TTL
console.log(cache.get('user'));  // { name: 'Alice' }
// After 5 seconds
console.log(cache.get('user'));  // null (expired)
```

---

### Exercise 5: Event Emitter (Advanced)

Create an `EventEmitter` class that implements the observer pattern.

**Requirements:**
- Private Map to store event listeners
- Methods:
  - `on(eventName, callback)` - registers event listener
  - `off(eventName, callback)` - removes specific listener
  - `once(eventName, callback)` - registers one-time listener
  - `emit(eventName, ...args)` - triggers all listeners for event
  - `listenerCount(eventName)` - returns number of listeners
  - `removeAllListeners(eventName)` - removes all listeners for event
- Support for multiple listeners per event
- Listeners should be called in order of registration
- Use private methods for validation

**Example:**
```javascript
const emitter = new EventEmitter();

emitter.on('data', (data) => console.log('Received:', data));
emitter.once('data', (data) => console.log('One time:', data));

emitter.emit('data', 'Hello');
// Received: Hello
// One time: Hello

emitter.emit('data', 'World');
// Received: World
// (once listener not called)
```

---

### Exercise 6: Rate Limiter (Advanced)

Create a `RateLimiter` class that limits function calls within a time window.

**Requirements:**
- Constructor takes: `maxCalls` (number), `timeWindow` (milliseconds)
- Private tracking of call timestamps
- Method: `attempt(key)` - returns true if allowed, false if rate limit exceeded
- Method: `reset(key)` - resets rate limit for specific key
- Method: `resetAll()` - resets all rate limits
- Getter: `getRemainingCalls(key)` - returns how many calls are left
- Static method: `createPerSecond(maxCalls)` - factory for per-second limiter
- Static method: `createPerMinute(maxCalls)` - factory for per-minute limiter
- Automatically clean up old timestamps

**Example:**
```javascript
const limiter = RateLimiter.createPerSecond(3);

console.log(limiter.attempt('user1'));  // true
console.log(limiter.attempt('user1'));  // true
console.log(limiter.attempt('user1'));  // true
console.log(limiter.attempt('user1'));  // false (rate limited)
console.log(limiter.getRemainingCalls('user1'));  // 0
```

---

## Testing & Verification

### Manual Testing

```javascript
class Calculator {
  add(a, b) {
    return a + b;
  }

  multiply(a, b) {
    return a * b;
  }
}

// Manual tests
const calc = new Calculator();
console.assert(calc.add(2, 3) === 5, 'Add test failed');
console.assert(calc.multiply(4, 5) === 20, 'Multiply test failed');
console.log('✓ All tests passed');
```

### Using Test Framework (Vitest)

```javascript
import { describe, it, expect } from 'vitest';

class StringUtils {
  static capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }

  static reverse(str) {
    return str.split('').reverse().join('');
  }
}

describe('StringUtils', () => {
  describe('capitalize()', () => {
    it('should capitalize first letter', () => {
      expect(StringUtils.capitalize('hello')).toBe('Hello');
    });

    it('should handle empty string', () => {
      expect(StringUtils.capitalize('')).toBe('');
    });
  });

  describe('reverse()', () => {
    it('should reverse string', () => {
      expect(StringUtils.reverse('hello')).toBe('olleh');
    });
  });
});
```

---

## Best Practices

### 1. Use PascalCase for Class Names

```javascript
// ✅ CORRECT
class UserAccount {}
class ProductCatalog {}

// ❌ WRONG
class userAccount {}
class product_catalog {}
```

### 2. Keep Constructors Simple

```javascript
// ❌ AVOID: Complex logic in constructor
class User {
  constructor(data) {
    this.name = data.name;
    this.email = data.email;
    // Complex validation and transformation
    this.processUserData();
    this.validateEmail();
    this.loadUserPreferences();
  }
}

// ✅ BETTER: Use factory methods or separate initialization
class User {
  constructor(name, email) {
    this.name = name;
    this.email = email;
  }

  static fromAPIResponse(data) {
    const user = new User(data.name, data.email);
    user.processUserData();
    return user;
  }
}
```

### 3. Use Private Fields for Encapsulation

```javascript
// ✅ CORRECT: Private fields for internal state
class Counter {
  #count = 0;

  increment() {
    this.#count++;
  }

  getValue() {
    return this.#count;
  }
}
```

### 4. Use Static Methods for Utilities

```javascript
class MathUtils {
  static average(numbers) {
    return numbers.reduce((a, b) => a + b) / numbers.length;
  }

  static median(numbers) {
    const sorted = [...numbers].sort((a, b) => a - b);
    const mid = Math.floor(sorted.length / 2);
    return sorted.length % 2 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
  }
}
```

### 5. Document with JSDoc

```javascript
/**
 * Represents a user account
 * @class
 */
class User {
  /**
   * Creates a new user
   * @param {string} name - User's full name
   * @param {string} email - User's email address
   */
  constructor(name, email) {
    this.name = name;
    this.email = email;
  }

  /**
   * Validates user's email format
   * @returns {boolean} True if valid
   */
  validateEmail() {
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(this.email);
  }
}
```

---

## Common Pitfalls

### 1. Forgetting `new` Keyword

```javascript
class User {
  constructor(name) {
    this.name = name;
  }
}

// ❌ ERROR: Cannot call class without 'new'
// const user = User('Alice');  // TypeError

// ✅ CORRECT
const user = new User('Alice');
```

### 2. Accessing Private Fields Externally

```javascript
class Example {
  #private = 42;
}

const ex = new Example();
// console.log(ex.#private);  // ❌ SyntaxError
```

### 3. Incorrect Arrow Function Methods

```javascript
class Button {
  constructor() {
    this.clicks = 0;
  }

  // ⚠️ This creates a new function for each instance
  handleClick = () => {
    this.clicks++;
  }
}

// Each instance has its own copy of handleClick
// This increases memory usage but preserves 'this' binding
```

### 4. Method vs Property Confusion

```javascript
class Example {
  // Getter (accessed like property)
  get value() {
    return this._value;
  }

  // Method (called with parentheses)
  getValue() {
    return this._value;
  }
}

const ex = new Example();
ex.value;       // ✅ Getter
ex.getValue();  // ✅ Method
// ex.value();     // ❌ TypeError: value is not a function
```

---

## Performance Considerations

### Instance vs Static Methods

```javascript
class Example {
  // Instance method - created once on prototype
  instanceMethod() {
    return 'instance';
  }

  // Arrow function - created for each instance
  arrowMethod = () => {
    return 'arrow';
  }

  // Static method - no 'this' binding needed
  static staticMethod() {
    return 'static';
  }
}

// Performance comparison
const instances = Array.from({ length: 1000 }, () => new Example());
// instanceMethod: shared across all instances (memory efficient)
// arrowMethod: 1000 separate functions (more memory)
// staticMethod: called on class, no instances needed
```

### Private Field Access Performance

```javascript
// Private fields have minimal performance overhead
class FastClass {
  #value = 0;

  increment() {
    this.#value++;  // Slightly slower than public, but negligible
  }
}
```

---

## Summary & Next Steps

### Key Takeaways

- Classes provide clean syntax for object-oriented programming in JavaScript
- Constructors initialize instances, methods define behavior
- Static members belong to the class, not instances
- Private fields (#) provide true encapsulation
- Getters/setters enable computed properties and validation
- Classes are syntactic sugar over prototypes but offer additional features
- Understanding `this` context is crucial for proper class usage

### Common Use Cases

- **Models:** Database entities, data structures
- **Controllers:** Request handlers, business logic
- **Services:** Reusable business logic, API integrations
- **Utilities:** Helper classes with static methods
- **Design Patterns:** Singleton, Factory, Builder, Observer

### Related Topics

- [Inheritance and `extends`](./19.Inheritance.md)
- [Prototypes and Prototype Chain](../advanced/prototypes.md)
- [Design Patterns with Classes](../advanced/design-patterns.md)

### Further Reading

- [MDN: Classes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes)
- [JavaScript.info: Classes](https://javascript.info/classes)
- [TC39: Class Fields Proposal](https://github.com/tc39/proposal-class-fields)

---

## References

- **ECMAScript Specification:** [Classes](https://tc39.es/ecma262/#sec-class-definitions)
- **MDN Web Docs:** [Classes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes)
- **Node.js Documentation:** [ES6 Features](https://nodejs.org/en/docs/es6/)
- **JavaScript.info:** [Class Basic Syntax](https://javascript.info/class)

---

**Practice Exercise:** Build a complete user management system with authentication, using all the class features covered in this lesson.

**Next Lesson:** [19.Inheritance.md](./19.Inheritance.md) - Master class inheritance, `extends`, `super`, and polymorphism.
