# Inheritance in JavaScript

**Difficulty:** Intermediate to Advanced
**Estimated Time:** 60-75 minutes
**Prerequisites:** ES6 Classes, prototypes, `this` keyword, object-oriented programming basics
**Target:** Node.js 18+ LTS, Modern Browsers (ES2021+)

---

## Learning Objectives

By the end of this lesson, you will be able to:

1. Understand inheritance and the `extends` keyword in JavaScript classes
2. Master the `super` keyword for calling parent constructors and methods
3. Implement method overriding and understand polymorphism
4. Navigate the prototype chain with classes
5. Use `instanceof` and check class hierarchies
6. Implement abstract patterns and interfaces in JavaScript
7. Apply mixins and composition for code reuse
8. Design class hierarchies for real-world applications
9. Avoid common inheritance pitfalls and anti-patterns
10. Choose between inheritance and composition appropriately

---

## Table of Contents

1. [Introduction](#introduction)
2. [The `extends` Keyword](#the-extends-keyword)
3. [The `super` Keyword](#the-super-keyword)
4. [Method Overriding](#method-overriding)
5. [Prototype Chain with Classes](#prototype-chain-with-classes)
6. [instanceof and Class Hierarchy](#instanceof-and-class-hierarchy)
7. [Abstract Patterns](#abstract-patterns)
8. [Mixins and Composition](#mixins-and-composition)
9. [Multi-Level Inheritance](#multi-level-inheritance)
10. [Worked Examples](#worked-examples)
11. [Exercises](#exercises)
12. [Testing & Verification](#testing--verification)
13. [Best Practices](#best-practices)
14. [Common Pitfalls](#common-pitfalls)
15. [Inheritance vs Composition](#inheritance-vs-composition)
16. [Summary & Next Steps](#summary--next-steps)
17. [References](#references)

---

## Introduction

**Inheritance** is a fundamental concept in object-oriented programming that allows one class to inherit properties and methods from another class. In JavaScript, the `extends` keyword provides a clean syntax for implementing inheritance.

**Why Inheritance Matters:**

- **Code Reuse:** Avoid duplicating common functionality
- **Hierarchy:** Model real-world relationships (is-a relationships)
- **Polymorphism:** Different classes can be treated uniformly
- **Organization:** Structure complex codebases logically
- **Extensibility:** Add functionality without modifying existing code
- **Maintenance:** Changes in parent classes propagate to children

**Real-World Applications:**

- **Error Classes:** Custom error types extending Error
- **Database Models:** Common model features inherited by specific models
- **UI Components:** Base component with common behavior
- **API Clients:** Base client with shared authentication, specialized endpoints
- **Game Entities:** Character, Enemy, NPC all extending Entity
- **Middleware:** Base middleware with shared setup

---

## The `extends` Keyword

The `extends` keyword establishes an inheritance relationship between classes.

### Basic Syntax

```javascript
class Parent {
  constructor(name) {
    this.name = name;
  }

  greet() {
    return `Hello, I'm ${this.name}`;
  }
}

class Child extends Parent {
  // Child inherits all properties and methods from Parent
}

const child = new Child('Alice');
console.log(child.greet());  // "Hello, I'm Alice"
console.log(child.name);     // "Alice"
```

### Inheritance Terminology

```javascript
class Animal {  // Base class, superclass, parent class
  constructor(name) {
    this.name = name;
  }
}

class Dog extends Animal {  // Derived class, subclass, child class
  bark() {
    return `${this.name} says Woof!`;
  }
}

const dog = new Dog('Max');
console.log(dog.name);   // Inherited from Animal
console.log(dog.bark());  // Defined in Dog
```

### Extending with Additional Properties

```javascript
class Vehicle {
  constructor(brand, year) {
    this.brand = brand;
    this.year = year;
  }

  getInfo() {
    return `${this.brand} (${this.year})`;
  }
}

class Car extends Vehicle {
  constructor(brand, year, doors) {
    super(brand, year);  // Call parent constructor
    this.doors = doors;   // Additional property
  }

  getCarInfo() {
    return `${this.getInfo()} - ${this.doors} doors`;
  }
}

const car = new Car('Toyota', 2024, 4);
console.log(car.getCarInfo());  // "Toyota (2024) - 4 doors"
```

### Single Inheritance Only

```javascript
class A {}
class B {}

// ❌ JavaScript doesn't support multiple inheritance
// class C extends A, B {}  // SyntaxError

// ✅ Use mixins for multiple inheritance-like behavior (covered later)
```

---

## The `super` Keyword

The `super` keyword is used to:
1. Call the parent class constructor
2. Access parent class methods

### Calling Parent Constructor

```javascript
class Employee {
  constructor(name, department) {
    this.name = name;
    this.department = department;
  }
}

class Manager extends Employee {
  constructor(name, department, teamSize) {
    // Must call super() before using 'this'
    super(name, department);
    this.teamSize = teamSize;
  }
}

const manager = new Manager('Alice', 'Engineering', 10);
console.log(manager.name);       // "Alice"
console.log(manager.teamSize);   // 10
```

### `super` Must Come First

```javascript
class Parent {
  constructor(value) {
    this.value = value;
  }
}

class Child extends Parent {
  constructor(value, extra) {
    // ❌ WRONG: Using 'this' before super()
    // this.extra = extra;  // ReferenceError
    // super(value);

    // ✅ CORRECT: super() must be called first
    super(value);
    this.extra = extra;
  }
}
```

### Calling Parent Methods with `super`

```javascript
class Shape {
  constructor(color) {
    this.color = color;
  }

  describe() {
    return `A ${this.color} shape`;
  }
}

class Circle extends Shape {
  constructor(color, radius) {
    super(color);
    this.radius = radius;
  }

  describe() {
    // Call parent method and extend its behavior
    const baseDescription = super.describe();
    return `${baseDescription} with radius ${this.radius}`;
  }

  getArea() {
    return Math.PI * this.radius ** 2;
  }
}

const circle = new Circle('red', 5);
console.log(circle.describe());  // "A red shape with radius 5"
console.log(circle.getArea());   // 78.54
```

### `super` in Static Methods

```javascript
class Parent {
  static greet() {
    return 'Hello from Parent';
  }
}

class Child extends Parent {
  static greet() {
    const parentGreeting = super.greet();
    return `${parentGreeting} and Child`;
  }
}

console.log(Child.greet());  // "Hello from Parent and Child"
```

---

## Method Overriding

Method overriding allows child classes to provide specific implementations of methods defined in parent classes.

### Basic Method Overriding

```javascript
class Animal {
  makeSound() {
    return 'Some generic sound';
  }

  move() {
    return 'Moving...';
  }
}

class Dog extends Animal {
  makeSound() {
    return 'Woof! Woof!';  // Override parent method
  }
  // move() is inherited without overriding
}

class Cat extends Animal {
  makeSound() {
    return 'Meow!';  // Different override
  }

  move() {
    return 'Cat is sneaking...';  // Override move too
  }
}

const dog = new Dog();
const cat = new Cat();

console.log(dog.makeSound());  // "Woof! Woof!"
console.log(dog.move());       // "Moving..." (inherited)

console.log(cat.makeSound());  // "Meow!"
console.log(cat.move());       // "Cat is sneaking..." (overridden)
```

### Overriding with Enhanced Behavior

```javascript
class Logger {
  log(message) {
    console.log(message);
  }
}

class TimestampedLogger extends Logger {
  log(message) {
    const timestamp = new Date().toISOString();
    super.log(`[${timestamp}] ${message}`);
  }
}

class FileLogger extends TimestampedLogger {
  constructor(filename) {
    super();
    this.filename = filename;
  }

  log(message) {
    // Add file info, then call parent
    const enhanced = `${this.filename}: ${message}`;
    super.log(enhanced);
  }
}

const fileLogger = new FileLogger('app.log');
fileLogger.log('Application started');
// Logs: "[2024-11-22T10:30:00.000Z] app.log: Application started"
```

### Polymorphism

```javascript
class Payment {
  process(amount) {
    throw new Error('process() must be implemented');
  }
}

class CreditCardPayment extends Payment {
  constructor(cardNumber) {
    super();
    this.cardNumber = cardNumber;
  }

  process(amount) {
    return `Processing $${amount} via credit card ${this.cardNumber}`;
  }
}

class PayPalPayment extends Payment {
  constructor(email) {
    super();
    this.email = email;
  }

  process(amount) {
    return `Processing $${amount} via PayPal (${this.email})`;
  }
}

// Polymorphism: treat different payment types uniformly
function processPayment(payment, amount) {
  return payment.process(amount);
}

const payments = [
  new CreditCardPayment('****-1234'),
  new PayPalPayment('user@example.com')
];

payments.forEach(payment => {
  console.log(processPayment(payment, 100));
});
```

---

## Prototype Chain with Classes

Classes in JavaScript use prototypes under the hood. Understanding the prototype chain helps debug inheritance issues.

### Prototype Chain Structure

```javascript
class Grandparent {
  grandparentMethod() {
    return 'grandparent';
  }
}

class Parent extends Grandparent {
  parentMethod() {
    return 'parent';
  }
}

class Child extends Parent {
  childMethod() {
    return 'child';
  }
}

const child = new Child();

// Prototype chain lookup
console.log(child.childMethod());        // Found in Child.prototype
console.log(child.parentMethod());       // Found in Parent.prototype
console.log(child.grandparentMethod());  // Found in Grandparent.prototype

// Checking the prototype chain
console.log(Object.getPrototypeOf(child) === Child.prototype);  // true
console.log(Object.getPrototypeOf(Child.prototype) === Parent.prototype);  // true
console.log(Object.getPrototypeOf(Parent.prototype) === Grandparent.prototype);  // true
```

### Visualizing the Chain

```javascript
class A {
  methodA() { return 'A'; }
}

class B extends A {
  methodB() { return 'B'; }
}

const instance = new B();

console.log(instance.__proto__ === B.prototype);  // true
console.log(B.prototype.__proto__ === A.prototype);  // true
console.log(A.prototype.__proto__ === Object.prototype);  // true
console.log(Object.prototype.__proto__ === null);  // true

// Chain: instance → B.prototype → A.prototype → Object.prototype → null
```

### Property Lookup

```javascript
class Parent {
  constructor() {
    this.parentProp = 'parent instance';
  }

  static parentStatic = 'parent static';
}

Parent.prototype.protoProp = 'parent prototype';

class Child extends Parent {
  constructor() {
    super();
    this.childProp = 'child instance';
  }
}

const child = new Child();

// Property lookup order:
// 1. Own property
console.log(child.childProp);  // "child instance"

// 2. Parent own property (inherited via constructor)
console.log(child.parentProp);  // "parent instance"

// 3. Prototype chain
console.log(child.protoProp);  // "parent prototype"

// 4. Not found
console.log(child.nonExistent);  // undefined
```

---

## instanceof and Class Hierarchy

The `instanceof` operator tests whether an object is an instance of a class or its ancestors.

### Basic instanceof Usage

```javascript
class Animal {}
class Dog extends Animal {}
class Cat extends Animal {}

const dog = new Dog();
const cat = new Cat();

console.log(dog instanceof Dog);     // true
console.log(dog instanceof Animal);  // true
console.log(dog instanceof Cat);     // false
console.log(dog instanceof Object);  // true (all objects inherit from Object)
```

### Type Checking in Functions

```javascript
class User {
  constructor(name) {
    this.name = name;
  }
}

class Admin extends User {
  constructor(name, permissions) {
    super(name);
    this.permissions = permissions;
  }

  hasPermission(permission) {
    return this.permissions.includes(permission);
  }
}

function processUser(user) {
  if (!(user instanceof User)) {
    throw new TypeError('Expected User instance');
  }

  console.log(`Processing user: ${user.name}`);

  if (user instanceof Admin) {
    console.log('User is admin with permissions:', user.permissions);
  }
}

processUser(new User('Bob'));
processUser(new Admin('Alice', ['read', 'write']));
// processUser({ name: 'Invalid' });  // TypeError
```

### Checking Constructor

```javascript
class Parent {}
class Child extends Parent {}

const child = new Child();

console.log(child.constructor === Child);   // true
console.log(child.constructor === Parent);  // false

// Get class name
console.log(child.constructor.name);  // "Child"
```

### isPrototypeOf

```javascript
class A {}
class B extends A {}
class C extends B {}

const c = new C();

console.log(C.prototype.isPrototypeOf(c));  // true
console.log(B.prototype.isPrototypeOf(c));  // true
console.log(A.prototype.isPrototypeOf(c));  // true
console.log(Object.prototype.isPrototypeOf(c));  // true
```

---

## Abstract Patterns

JavaScript doesn't have built-in abstract classes, but we can implement the pattern.

### Abstract Class Pattern

```javascript
class AbstractShape {
  constructor(color) {
    if (new.target === AbstractShape) {
      throw new Error('Cannot instantiate abstract class AbstractShape');
    }
    this.color = color;
  }

  // Abstract method (must be overridden)
  getArea() {
    throw new Error('getArea() must be implemented by subclass');
  }

  getPerimeter() {
    throw new Error('getPerimeter() must be implemented by subclass');
  }

  // Concrete method (can be used as-is)
  describe() {
    return `A ${this.color} shape with area ${this.getArea()}`;
  }
}

class Rectangle extends AbstractShape {
  constructor(color, width, height) {
    super(color);
    this.width = width;
    this.height = height;
  }

  getArea() {
    return this.width * this.height;
  }

  getPerimeter() {
    return 2 * (this.width + this.height);
  }
}

class Circle extends AbstractShape {
  constructor(color, radius) {
    super(color);
    this.radius = radius;
  }

  getArea() {
    return Math.PI * this.radius ** 2;
  }

  getPerimeter() {
    return 2 * Math.PI * this.radius;
  }
}

// ❌ Cannot instantiate abstract class
// const shape = new AbstractShape('red');  // Error

// ✅ Can instantiate concrete classes
const rect = new Rectangle('blue', 10, 5);
const circle = new Circle('red', 7);

console.log(rect.describe());    // "A blue shape with area 50"
console.log(circle.getArea());   // 153.94
```

### Interface Pattern

```javascript
// Define an interface (not enforced, just convention)
class Serializable {
  toJSON() {
    throw new Error('toJSON() must be implemented');
  }

  fromJSON(json) {
    throw new Error('fromJSON() must be implemented');
  }
}

class User extends Serializable {
  constructor(name, email) {
    super();
    this.name = name;
    this.email = email;
  }

  toJSON() {
    return JSON.stringify({
      name: this.name,
      email: this.email
    });
  }

  static fromJSON(json) {
    const data = JSON.parse(json);
    return new User(data.name, data.email);
  }
}

const user = new User('Alice', 'alice@example.com');
const json = user.toJSON();
console.log(json);  // '{"name":"Alice","email":"alice@example.com"}'

const restored = User.fromJSON(json);
console.log(restored.name);  // "Alice"
```

---

## Mixins and Composition

Mixins allow sharing functionality across unrelated classes without inheritance.

### Simple Mixin

```javascript
// Mixin: adds logging capabilities
const LoggableMixin = {
  log(message) {
    console.log(`[${this.constructor.name}] ${message}`);
  },

  logError(error) {
    console.error(`[${this.constructor.name}] ERROR: ${error}`);
  }
};

// Mixin: adds timestamping
const TimestampableMixin = {
  getTimestamp() {
    return new Date().toISOString();
  },

  addTimestamp(data) {
    return { ...data, timestamp: this.getTimestamp() };
  }
};

// Apply mixins
class User {
  constructor(name) {
    this.name = name;
  }
}

Object.assign(User.prototype, LoggableMixin, TimestampableMixin);

const user = new User('Alice');
user.log('User created');  // "[User] User created"

const data = user.addTimestamp({ action: 'login' });
console.log(data);  // { action: 'login', timestamp: '2024-11-22T...' }
```

### Mixin Factory Function

```javascript
const Timestamped = (Base) => class extends Base {
  constructor(...args) {
    super(...args);
    this.createdAt = new Date();
  }

  getAge() {
    return Date.now() - this.createdAt.getTime();
  }
};

const Serializable = (Base) => class extends Base {
  toJSON() {
    return JSON.stringify(this);
  }

  static fromJSON(json) {
    const data = JSON.parse(json);
    return new this(data);
  }
};

// Base class
class Entity {
  constructor(id) {
    this.id = id;
  }
}

// Apply multiple mixins
class User extends Timestamped(Serializable(Entity)) {
  constructor(id, name) {
    super(id);
    this.name = name;
  }
}

const user = new User(1, 'Alice');
console.log(user.id);         // 1
console.log(user.createdAt);  // Date object
console.log(user.toJSON());   // Serialized user
```

### Composition Over Inheritance

```javascript
// Instead of deep inheritance, use composition
class Engine {
  start() {
    return 'Engine started';
  }

  stop() {
    return 'Engine stopped';
  }
}

class GPS {
  navigate(destination) {
    return `Navigating to ${destination}`;
  }
}

class Radio {
  play(station) {
    return `Playing ${station}`;
  }
}

// Composition: Car HAS-A engine, gps, radio
class Car {
  constructor(brand) {
    this.brand = brand;
    this.engine = new Engine();
    this.gps = new GPS();
    this.radio = new Radio();
  }

  start() {
    return this.engine.start();
  }

  navigateTo(destination) {
    return this.gps.navigate(destination);
  }

  playRadio(station) {
    return this.radio.play(station);
  }
}

const car = new Car('Toyota');
console.log(car.start());              // "Engine started"
console.log(car.navigateTo('Home'));   // "Navigating to Home"
console.log(car.playRadio('FM 101')); // "Playing FM 101"
```

---

## Multi-Level Inheritance

JavaScript supports multi-level inheritance (chains of inheritance).

### Three-Level Hierarchy

```javascript
class LivingBeing {
  constructor(name) {
    this.name = name;
    this.alive = true;
  }

  breathe() {
    return `${this.name} is breathing`;
  }
}

class Animal extends LivingBeing {
  constructor(name, species) {
    super(name);
    this.species = species;
  }

  move() {
    return `${this.name} is moving`;
  }
}

class Dog extends Animal {
  constructor(name, breed) {
    super(name, 'Canine');
    this.breed = breed;
  }

  bark() {
    return `${this.name} says Woof!`;
  }
}

const dog = new Dog('Max', 'Golden Retriever');

// Has access to all levels
console.log(dog.breathe());  // LivingBeing method
console.log(dog.move());     // Animal method
console.log(dog.bark());     // Dog method

console.log(dog.name);      // LivingBeing property
console.log(dog.species);   // Animal property
console.log(dog.breed);     // Dog property
```

### Deep Hierarchy Example

```javascript
class Vehicle {
  constructor(brand, year) {
    this.brand = brand;
    this.year = year;
  }

  getBasicInfo() {
    return `${this.brand} (${this.year})`;
  }
}

class MotorVehicle extends Vehicle {
  constructor(brand, year, engineType) {
    super(brand, year);
    this.engineType = engineType;
  }

  getEngineInfo() {
    return `${this.getBasicInfo()} - ${this.engineType} engine`;
  }
}

class Car extends MotorVehicle {
  constructor(brand, year, engineType, doors) {
    super(brand, year, engineType);
    this.doors = doors;
  }

  getFullInfo() {
    return `${this.getEngineInfo()}, ${this.doors} doors`;
  }
}

class ElectricCar extends Car {
  constructor(brand, year, doors, batteryCapacity) {
    super(brand, year, 'Electric', doors);
    this.batteryCapacity = batteryCapacity;
  }

  getRange() {
    return `${this.batteryCapacity} kWh battery`;
  }
}

const tesla = new ElectricCar('Tesla', 2024, 4, 75);
console.log(tesla.getFullInfo());  // "Tesla (2024) - Electric engine, 4 doors"
console.log(tesla.getRange());     // "75 kWh battery"
```

---

## Worked Examples

### Example 1: HTTP Error Hierarchy

```javascript
class HttpError extends Error {
  constructor(message, statusCode) {
    super(message);
    this.name = this.constructor.name;
    this.statusCode = statusCode;
    this.timestamp = new Date().toISOString();
    Error.captureStackTrace(this, this.constructor);
  }

  toJSON() {
    return {
      name: this.name,
      message: this.message,
      statusCode: this.statusCode,
      timestamp: this.timestamp
    };
  }
}

class BadRequestError extends HttpError {
  constructor(message = 'Bad Request') {
    super(message, 400);
  }
}

class UnauthorizedError extends HttpError {
  constructor(message = 'Unauthorized') {
    super(message, 401);
  }
}

class NotFoundError extends HttpError {
  constructor(resource) {
    super(`${resource} not found`, 404);
    this.resource = resource;
  }
}

class InternalServerError extends HttpError {
  constructor(message = 'Internal Server Error') {
    super(message, 500);
  }
}

// Error handling middleware
function handleError(error) {
  if (error instanceof HttpError) {
    console.error(`HTTP ${error.statusCode}: ${error.message}`);
    return error.toJSON();
  }

  // Unknown error
  console.error('Unexpected error:', error);
  return new InternalServerError().toJSON();
}

// Usage
try {
  throw new NotFoundError('User');
} catch (error) {
  console.log(handleError(error));
  // { name: 'NotFoundError', message: 'User not found', statusCode: 404, timestamp: '...' }
}
```

### Example 2: Database Model Hierarchy

```javascript
class BaseModel {
  constructor(data = {}) {
    this.id = data.id || null;
    this.createdAt = data.createdAt || new Date();
    this.updatedAt = data.updatedAt || new Date();
  }

  static tableName = '';

  save() {
    this.updatedAt = new Date();
    console.log(`Saving ${this.constructor.tableName}: ${this.id}`);
    return this;
  }

  delete() {
    console.log(`Deleting ${this.constructor.tableName}: ${this.id}`);
  }

  toJSON() {
    return {
      id: this.id,
      createdAt: this.createdAt,
      updatedAt: this.updatedAt
    };
  }
}

class User extends BaseModel {
  static tableName = 'users';

  constructor(data) {
    super(data);
    this.username = data.username;
    this.email = data.email;
    this.passwordHash = data.passwordHash;
  }

  authenticate(password) {
    // Simplified authentication
    return this.passwordHash === `hashed_${password}`;
  }

  toJSON() {
    return {
      ...super.toJSON(),
      username: this.username,
      email: this.email
    };
  }
}

class Product extends BaseModel {
  static tableName = 'products';

  constructor(data) {
    super(data);
    this.name = data.name;
    this.price = data.price;
    this.stock = data.stock || 0;
  }

  updateStock(quantity) {
    this.stock += quantity;
    return this.save();
  }

  toJSON() {
    return {
      ...super.toJSON(),
      name: this.name,
      price: this.price,
      stock: this.stock
    };
  }
}

// Usage
const user = new User({
  id: 1,
  username: 'alice',
  email: 'alice@example.com',
  passwordHash: 'hashed_secret123'
});

console.log(user.authenticate('secret123'));  // true
console.log(user.toJSON());
user.save();

const product = new Product({
  id: 101,
  name: 'Laptop',
  price: 999,
  stock: 10
});

product.updateStock(5);
console.log(product.toJSON());
```

### Example 3: Event System with Inheritance

```javascript
class Event {
  constructor(type, data = {}) {
    this.type = type;
    this.data = data;
    this.timestamp = Date.now();
    this.id = Math.random().toString(36).substr(2, 9);
  }

  toString() {
    return `Event[${this.type}] at ${new Date(this.timestamp).toISOString()}`;
  }
}

class UserEvent extends Event {
  constructor(type, userId, data) {
    super(`user.${type}`, data);
    this.userId = userId;
  }

  toString() {
    return `${super.toString()} - User: ${this.userId}`;
  }
}

class OrderEvent extends Event {
  constructor(type, orderId, data) {
    super(`order.${type}`, data);
    this.orderId = orderId;
  }

  calculateTotal() {
    return this.data.items?.reduce((sum, item) => sum + item.price, 0) || 0;
  }
}

class EventBus {
  #listeners = new Map();

  on(eventType, callback) {
    if (!this.#listeners.has(eventType)) {
      this.#listeners.set(eventType, []);
    }
    this.#listeners.get(eventType).push(callback);
  }

  emit(event) {
    if (!(event instanceof Event)) {
      throw new TypeError('Must emit Event instance');
    }

    const listeners = this.#listeners.get(event.type) || [];
    listeners.forEach(callback => callback(event));
  }
}

// Usage
const bus = new EventBus();

bus.on('user.login', (event) => {
  console.log(`User ${event.userId} logged in`);
});

bus.on('order.created', (event) => {
  console.log(`Order ${event.orderId} created - Total: $${event.calculateTotal()}`);
});

bus.emit(new UserEvent('login', 123, { ip: '192.168.1.1' }));
bus.emit(new OrderEvent('created', 'ORD-001', {
  items: [{ price: 100 }, { price: 200 }]
}));
```

---

## Exercises

### Exercise 1: Shape Hierarchy (Easy)

Create a hierarchy of geometric shapes with inheritance.

**Requirements:**
- Base class `Shape` with:
  - Constructor taking `color`
  - Abstract methods: `getArea()`, `getPerimeter()`
  - Concrete method: `describe()` returns description with color and area
- Child class `Rectangle`:
  - Constructor: `(color, width, height)`
  - Implement `getArea()` and `getPerimeter()`
- Child class `Circle`:
  - Constructor: `(color, radius)`
  - Implement `getArea()` and `getPerimeter()`
- Child class `Square` extends `Rectangle`:
  - Constructor: `(color, side)`
  - Call Rectangle constructor with side for both width and height

**Example:**
```javascript
const rect = new Rectangle('blue', 10, 5);
console.log(rect.getArea());      // 50
console.log(rect.describe());     // "A blue shape with area 50"

const circle = new Circle('red', 7);
console.log(circle.getPerimeter().toFixed(2));  // 43.98
```

---

### Exercise 2: Employee Management System (Medium)

Create an employee hierarchy with different roles and benefits.

**Requirements:**
- Base class `Employee`:
  - Properties: `name`, `id`, `baseSalary`
  - Method: `getSalary()` returns base salary
  - Method: `getDetails()` returns employee info
- Class `Manager` extends `Employee`:
  - Additional property: `teamSize`
  - Override `getSalary()`: add 10% per team member
  - Override `getDetails()`: include team size
- Class `Developer` extends `Employee`:
  - Additional properties: `programmingLanguages` (array), `level` (junior/senior)
  - Override `getSalary()`: senior gets 20% bonus, junior gets base
  - Method: `canCode(language)` checks if knows language
- Class `Designer` extends `Employee`:
  - Additional property: `tools` (array of design tools)
  - Override `getSalary()`: add 15% if knows more than 3 tools

**Example:**
```javascript
const manager = new Manager('Alice', 'M001', 80000, 5);
console.log(manager.getSalary());  // 84000 (80000 + 10% * 5)

const dev = new Developer('Bob', 'D001', 70000, ['JavaScript', 'Python'], 'senior');
console.log(dev.getSalary());      // 84000 (70000 + 20%)
console.log(dev.canCode('Python'));  // true
```

---

### Exercise 3: Custom Error Classes (Medium)

Create a hierarchy of custom error classes for an application.

**Requirements:**
- Base class `AppError` extends `Error`:
  - Constructor: `(message, code, isOperational = true)`
  - Properties: `code`, `isOperational`, `timestamp`
  - Method: `toJSON()` returns error details
- Class `ValidationError` extends `AppError`:
  - Constructor: `(message, fieldErrors = {})`
  - Code: 'VALIDATION_ERROR'
  - Additional property: `fieldErrors` (object mapping field to error)
- Class `DatabaseError` extends `AppError`:
  - Constructor: `(message, query = null)`
  - Code: 'DATABASE_ERROR'
  - Set `isOperational` to false
  - Additional property: `query`
- Class `AuthenticationError` extends `AppError`:
  - Constructor: `(message = 'Authentication failed')`
  - Code: 'AUTH_ERROR'
- Create error handler function that handles each type differently

**Example:**
```javascript
throw new ValidationError('Invalid input', {
  email: 'Invalid format',
  age: 'Must be positive'
});

throw new DatabaseError('Connection failed', 'SELECT * FROM users');
```

---

### Exercise 4: Vehicle Rental System (Hard)

Create a comprehensive vehicle rental system with inheritance.

**Requirements:**
- Base class `Vehicle`:
  - Properties: `id`, `brand`, `model`, `dailyRate`, `isRented`
  - Method: `rent()` - marks as rented
  - Method: `return()` - marks as available
  - Method: `calculateRentalCost(days)` - returns total cost
- Class `Car` extends `Vehicle`:
  - Additional: `seats`, `transmission` ('auto' or 'manual')
  - Override cost: add $10/day for automatic
- Class `Motorcycle` extends `Vehicle`:
  - Additional: `engineSize`
  - Override cost: 20% discount on base rate
- Class `Truck` extends `Vehicle`:
  - Additional: `capacity` (tons), `isCommercial`
  - Override cost: add $50/day if commercial, add $5/day per ton
- Class `RentalAgency`:
  - Manages fleet of vehicles
  - Methods: `addVehicle()`, `rentVehicle(id, days)`, `returnVehicle(id)`, `getAvailableVehicles()`, `getRevenue()`

**Example:**
```javascript
const agency = new RentalAgency();
agency.addVehicle(new Car('C001', 'Toyota', 'Camry', 50, 5, 'auto'));
agency.addVehicle(new Motorcycle('M001', 'Honda', 'CBR', 30, 600));

const receipt = agency.rentVehicle('C001', 3);
console.log(receipt);  // { id: 'C001', days: 3, cost: 180 }
```

---

### Exercise 5: Game Character System (Hard)

Create a game character hierarchy with abilities and stats.

**Requirements:**
- Base class `Character`:
  - Properties: `name`, `health`, `maxHealth`, `level`
  - Methods: `takeDamage(amount)`, `heal(amount)`, `levelUp()`, `isAlive()`
- Class `Warrior` extends `Character`:
  - Additional: `armor`, `strength`
  - Override `takeDamage()`: reduce damage by armor percentage
  - Method: `attack()` returns damage based on strength
- Class `Mage` extends `Character`:
  - Additional: `mana`, `maxMana`, `intelligence`
  - Methods: `castSpell(cost, damage)`, `restoreMana(amount)`
  - Override `levelUp()`: increase mana pool
- Class `Archer` extends `Character`:
  - Additional: `arrows`, `dexterity`
  - Methods: `shoot()` (costs arrow), `refillArrows(count)`
  - Critical hit chance based on dexterity
- All should have `getStats()` returning character info

**Example:**
```javascript
const warrior = new Warrior('Conan', 100, 1);
warrior.takeDamage(30);
console.log(warrior.health);  // Reduced by less than 30 due to armor

const mage = new Mage('Gandalf', 80, 1);
mage.castSpell(20, 50);
console.log(mage.mana);  // Reduced by 20
```

---

### Exercise 6: Stream Processing Pipeline (Advanced)

Create a stream processing system using inheritance for different stream types.

**Requirements:**
- Abstract class `Stream`:
  - Method: `read()` - abstract
  - Method: `pipe(destination)` - pipes to another stream
  - Method: `close()` - closes stream
- Class `ReadableStream` extends `Stream`:
  - Can read data from source
  - Method: `read(size)` returns chunk of data
- Class `WritableStream` extends `Stream`:
  - Method: `write(data)` writes to destination
- Class `TransformStream` extends both concepts:
  - Method: `transform(data)` - abstract transformation
  - Override `read()` to transform and return data
- Concrete transforms:
  - `UppercaseTransform` - converts to uppercase
  - `EncryptTransform` - simple encryption
  - `CompressTransform` - simulates compression
- Build a pipeline that chains transformations

**Example:**
```javascript
const source = new ReadableStream(['hello', 'world']);
const uppercase = new UppercaseTransform();
const encrypt = new EncryptTransform();

source.pipe(uppercase).pipe(encrypt).pipe(output);
```

---

## Testing & Verification

### Testing Inheritance

```javascript
import { describe, it, expect } from 'vitest';

class Animal {
  constructor(name) {
    this.name = name;
  }

  makeSound() {
    return 'generic sound';
  }
}

class Dog extends Animal {
  makeSound() {
    return 'Woof!';
  }
}

describe('Animal Inheritance', () => {
  it('should inherit constructor', () => {
    const dog = new Dog('Max');
    expect(dog.name).toBe('Max');
  });

  it('should override methods', () => {
    const dog = new Dog('Max');
    expect(dog.makeSound()).toBe('Woof!');
  });

  it('should work with instanceof', () => {
    const dog = new Dog('Max');
    expect(dog instanceof Dog).toBe(true);
    expect(dog instanceof Animal).toBe(true);
  });
});
```

---

## Best Practices

### 1. Favor Composition Over Inheritance

```javascript
// ❌ AVOID: Deep inheritance for behavior
class Animal {}
class FlyingAnimal extends Animal {}
class SwimmingAnimal extends Animal {}
// How to represent a duck that flies and swims?

// ✅ PREFER: Composition
class Animal {
  constructor(name) {
    this.name = name;
    this.abilities = [];
  }

  addAbility(ability) {
    this.abilities.push(ability);
  }
}

const duck = new Animal('Duck');
duck.addAbility(new FlyingAbility());
duck.addAbility(new SwimmingAbility());
```

### 2. Keep Hierarchies Shallow

```javascript
// ✅ GOOD: 2-3 levels maximum
class Entity {}
class User extends Entity {}
class AdminUser extends User {}  // OK

// ❌ AVOID: Deep hierarchies
class A {}
class B extends A {}
class C extends B {}
class D extends C {}  // Too deep!
```

### 3. Use Abstract Classes for Contracts

```javascript
class AbstractRepository {
  constructor() {
    if (new.target === AbstractRepository) {
      throw new Error('Cannot instantiate abstract class');
    }
  }

  find(id) {
    throw new Error('find() must be implemented');
  }

  save(entity) {
    throw new Error('save() must be implemented');
  }
}
```

### 4. Call super() First in Constructor

```javascript
// ✅ CORRECT
class Child extends Parent {
  constructor(value) {
    super();
    this.value = value;
  }
}

// ❌ WRONG
class Child extends Parent {
  constructor(value) {
    this.value = value;  // ReferenceError!
    super();
  }
}
```

---

## Common Pitfalls

### 1. Forgetting to Call super()

```javascript
class Parent {
  constructor(value) {
    this.value = value;
  }
}

class Child extends Parent {
  constructor(value, extra) {
    // ❌ Forgot super()
    this.extra = extra;  // ReferenceError
  }
}
```

### 2. Overriding Without super

```javascript
class Parent {
  setup() {
    this.initialized = true;
    // ... important setup
  }
}

class Child extends Parent {
  setup() {
    // ❌ Forgot to call super.setup()
    this.childReady = true;
    // Parent setup is lost!
  }
}

// ✅ CORRECT
class Child extends Parent {
  setup() {
    super.setup();
    this.childReady = true;
  }
}
```

### 3. Modifying Parent Prototype

```javascript
class Parent {}

class Child extends Parent {}

// ❌ DANGEROUS: Affects all children
Parent.prototype.newMethod = function() {};

// ✅ BETTER: Modify only child
Child.prototype.newMethod = function() {};
```

---

## Inheritance vs Composition

### When to Use Inheritance

✅ Use inheritance when:
- True "is-a" relationship exists
- Child needs all parent functionality
- Hierarchy is shallow (2-3 levels)
- Polymorphism is needed

### When to Use Composition

✅ Use composition when:
- "has-a" relationship exists
- Need flexible combination of behaviors
- Want to avoid tight coupling
- Multiple inheritance-like behavior needed

### Example Comparison

```javascript
// Inheritance: "is-a" relationship
class Employee extends Person {
  // Employee IS-A Person
}

// Composition: "has-a" relationship
class Car {
  constructor() {
    this.engine = new Engine();  // Car HAS-A Engine
    this.wheels = [new Wheel(), new Wheel(), new Wheel(), new Wheel()];
  }
}
```

---

## Summary & Next Steps

### Key Takeaways

- `extends` creates inheritance relationships between classes
- `super` calls parent constructors and methods
- Method overriding enables polymorphism
- Prototype chain underlies class inheritance
- Abstract classes enforce contracts
- Mixins provide multiple inheritance-like functionality
- Favor composition over deep inheritance hierarchies

### When to Use Each Pattern

- **Inheritance:** Clear hierarchical relationships, shared behavior
- **Composition:** Flexible behavior combinations, avoiding tight coupling
- **Mixins:** Share functionality across unrelated classes

### Related Topics

- [ES6 Classes](./18.Classes.md)
- [Prototypes and Prototype Chain](../advanced/prototypes.md)
- [Design Patterns](../advanced/design-patterns.md)

### Further Reading

- [MDN: Inheritance](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)
- [JavaScript.info: Class Inheritance](https://javascript.info/class-inheritance)
- [Composition vs Inheritance](https://www.youtube.com/watch?v=wfMtDGfHWpA)

---

## References

- **ECMAScript Specification:** [Class Definitions](https://tc39.es/ecma262/#sec-class-definitions)
- **MDN Web Docs:** [extends](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/extends)
- **MDN Web Docs:** [super](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/super)
- **JavaScript.info:** [Class Inheritance](https://javascript.info/class-inheritance)

---

**Practice Exercise:** Build a complete e-commerce system with Product, PhysicalProduct, DigitalProduct, and SubscriptionProduct classes.

**Next Lesson:** [20.Modules.md](../12.modules_iterators_and_generators/20.Modules.md) - Learn ES6 modules for code organization.
