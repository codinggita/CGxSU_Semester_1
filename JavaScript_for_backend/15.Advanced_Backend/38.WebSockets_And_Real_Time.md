# WebSockets and Real-Time Communication

**Difficulty:** Intermediate to Advanced
**Estimated Time:** 90-120 minutes
**Prerequisites:** Node.js, Express.js, async/await, events, HTTP fundamentals
**Target:** Node.js 18+ LTS, Socket.IO 4+

---

## Learning Objectives

By the end of this lesson, you will be able to:

1. Understand the WebSocket protocol and how it differs from HTTP
2. Set up Socket.IO for real-time bidirectional communication
3. Build a real-time chat application from scratch
4. Implement broadcasting and rooms for targeted messaging
5. Handle disconnections and reconnections gracefully
6. Scale WebSocket applications across multiple servers
7. Compare WebSockets with HTTP polling and Server-Sent Events
8. Implement authentication for WebSocket connections
9. Debug and monitor real-time applications
10. Apply best practices for production WebSocket systems

---

## Table of Contents

1. [Introduction](#introduction)
2. [WebSocket Protocol Basics](#websocket-protocol-basics)
3. [Socket.IO Fundamentals](#socketio-fundamentals)
4. [Real-Time Chat Application](#real-time-chat-application)
5. [Broadcasting and Rooms](#broadcasting-and-rooms)
6. [Handling Disconnections](#handling-disconnections)
7. [Authentication and Authorization](#authentication-and-authorization)
8. [Scaling WebSockets](#scaling-websockets)
9. [WebSocket vs Polling vs SSE](#websocket-vs-polling-vs-sse)
10. [Worked Examples](#worked-examples)
11. [Exercises](#exercises)
12. [Testing & Verification](#testing--verification)
13. [Best Practices](#best-practices)
14. [Common Pitfalls](#common-pitfalls)
15. [Performance Considerations](#performance-considerations)
16. [Summary & Next Steps](#summary--next-steps)
17. [References](#references)

---

## Introduction

Real-time communication enables instant, bidirectional data exchange between clients and servers. WebSockets provide a persistent connection for low-latency messaging, essential for modern interactive applications.

**Why Real-Time Matters:**

- **User Experience:** Instant updates without page refresh
- **Collaboration:** Multiple users working together in real-time
- **Notifications:** Push updates to users immediately
- **Gaming:** Low-latency multiplayer interactions
- **Live Data:** Stock prices, sports scores, IoT sensors

**Real-World Applications:**

- **Chat Applications:** Slack, Discord, WhatsApp Web
- **Collaborative Tools:** Google Docs, Figma, Miro
- **Live Dashboards:** Analytics, monitoring systems
- **Gaming:** Multiplayer games, live leaderboards
- **Trading Platforms:** Real-time price updates
- **Social Media:** Live feeds, notifications, stories

---

## WebSocket Protocol Basics

### HTTP vs WebSocket

```javascript
/**
 * Understanding the fundamental differences
 */

const httpCharacteristics = {
  pattern: 'Request-Response',
  connection: 'Short-lived (closes after response)',
  direction: 'One-way (client initiates)',
  overhead: 'High (headers sent with each request)',
  latency: 'Higher (new connection for each request)',
  use: 'Traditional web pages, REST APIs'
};

const webSocketCharacteristics = {
  pattern: 'Bidirectional streaming',
  connection: 'Long-lived (persistent)',
  direction: 'Two-way (either side can send)',
  overhead: 'Low (minimal framing)',
  latency: 'Lower (reuses connection)',
  use: 'Real-time apps, chat, live updates'
};

/**
 * Connection lifecycle
 */

// HTTP: Multiple requests
// Client --> [Request 1] --> Server
// Client <-- [Response 1] <-- Server
// (Connection closes)
// Client --> [Request 2] --> Server
// Client <-- [Response 2] <-- Server
// (Connection closes)

// WebSocket: Single persistent connection
// Client --> [Upgrade Request] --> Server
// Client <-- [Upgrade Response] <-- Server
// (Connection stays open)
// Client <-- [Message] <-> Server
// Client <-- [Message] <-> Server
// Client <-- [Message] <-> Server
// ... (stays open until closed)
```

### WebSocket Handshake

```javascript
/**
 * WebSocket connection upgrade
 */

// 1. Client sends HTTP upgrade request
const upgradeRequest = `
GET /chat HTTP/1.1
Host: example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Version: 13
`;

// 2. Server responds with upgrade
const upgradeResponse = `
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
`;

// 3. Connection upgraded to WebSocket protocol
// 4. Bidirectional communication begins
```

### Native WebSocket API

```javascript
/**
 * Using native WebSocket in the browser
 */

// Client-side WebSocket
const socket = new WebSocket('ws://localhost:3000');

// Connection opened
socket.addEventListener('open', (event) => {
  console.log('Connected to server');
  socket.send(JSON.stringify({ type: 'hello', message: 'Hello Server!' }));
});

// Listen for messages
socket.addEventListener('message', (event) => {
  console.log('Message from server:', event.data);
  const data = JSON.parse(event.data);
  console.log('Parsed:', data);
});

// Handle errors
socket.addEventListener('error', (event) => {
  console.error('WebSocket error:', event);
});

// Connection closed
socket.addEventListener('close', (event) => {
  console.log('Disconnected from server', event.code, event.reason);
});

// Send message
const sendMessage = (message) => {
  if (socket.readyState === WebSocket.OPEN) {
    socket.send(JSON.stringify(message));
  } else {
    console.error('Socket not open');
  }
};

/**
 * Server-side WebSocket (using ws library)
 */

import { WebSocketServer } from 'ws';

const wss = new WebSocketServer({ port: 3000 });

wss.on('connection', (ws) => {
  console.log('New client connected');

  // Receive message
  ws.on('message', (data) => {
    console.log('Received:', data.toString());
    const message = JSON.parse(data);

    // Echo back
    ws.send(JSON.stringify({
      type: 'echo',
      message: message.message
    }));
  });

  // Handle close
  ws.on('close', () => {
    console.log('Client disconnected');
  });

  // Handle error
  ws.on('error', (error) => {
    console.error('WebSocket error:', error);
  });
});
```

---

## Socket.IO Fundamentals

### Why Socket.IO?

```javascript
/**
 * Socket.IO advantages over raw WebSocket
 */

const socketIOFeatures = {
  fallback: 'Automatic fallback to HTTP long-polling if WebSocket unavailable',
  reconnection: 'Automatic reconnection with exponential backoff',
  rooms: 'Built-in room and namespace support',
  broadcasting: 'Easy message broadcasting to groups',
  acknowledgments: 'Message delivery confirmation',
  binary: 'Binary data support (files, images)',
  middleware: 'Connection middleware for auth',
  scalability: 'Multi-server support with Redis adapter'
};
```

### Setting Up Socket.IO

```javascript
/**
 * Install: npm install socket.io
 */

import express from 'express';
import { createServer } from 'http';
import { Server } from 'socket.io';

const app = express();
const httpServer = createServer(app);

// Initialize Socket.IO
const io = new Server(httpServer, {
  cors: {
    origin: process.env.CLIENT_URL || 'http://localhost:3000',
    methods: ['GET', 'POST'],
    credentials: true
  },
  pingTimeout: 60000,
  pingInterval: 25000
});

// Serve static files
app.use(express.static('public'));

// Socket.IO connection handler
io.on('connection', (socket) => {
  console.log('User connected:', socket.id);

  // Listen for custom events
  socket.on('message', (data) => {
    console.log('Message received:', data);

    // Emit back to sender
    socket.emit('message', { text: 'Message received', data });
  });

  // Handle disconnection
  socket.on('disconnect', (reason) => {
    console.log('User disconnected:', socket.id, reason);
  });
});

const PORT = process.env.PORT || 3000;
httpServer.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
```

### Client-Side Socket.IO

```html
<!-- HTML -->
<!DOCTYPE html>
<html>
<head>
  <title>Socket.IO Chat</title>
  <script src="/socket.io/socket.io.js"></script>
</head>
<body>
  <div id="messages"></div>
  <input id="messageInput" type="text" placeholder="Type a message..." />
  <button id="sendButton">Send</button>

  <script>
    // Connect to server
    const socket = io('http://localhost:3000', {
      reconnection: true,
      reconnectionDelay: 1000,
      reconnectionAttempts: 5
    });

    // Connection events
    socket.on('connect', () => {
      console.log('Connected:', socket.id);
      displayMessage('System', 'Connected to server');
    });

    socket.on('disconnect', () => {
      console.log('Disconnected');
      displayMessage('System', 'Disconnected from server');
    });

    socket.on('connect_error', (error) => {
      console.error('Connection error:', error);
    });

    // Listen for messages
    socket.on('message', (data) => {
      console.log('Message received:', data);
      displayMessage('Server', data.text);
    });

    // Send message
    document.getElementById('sendButton').addEventListener('click', () => {
      const input = document.getElementById('messageInput');
      const message = input.value;

      if (message.trim()) {
        socket.emit('message', { text: message });
        displayMessage('You', message);
        input.value = '';
      }
    });

    // Display message in UI
    function displayMessage(sender, text) {
      const messagesDiv = document.getElementById('messages');
      const messageEl = document.createElement('div');
      messageEl.textContent = `${sender}: ${text}`;
      messagesDiv.appendChild(messageEl);
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }
  </script>
</body>
</html>
```

---

## Real-Time Chat Application

### Complete Chat Server

```javascript
/**
 * Full-featured chat server with Socket.IO
 */

import express from 'express';
import { createServer } from 'http';
import { Server } from 'socket.io';

const app = express();
const httpServer = createServer(app);
const io = new Server(httpServer);

// Store active users
const users = new Map();

// Store chat history
const messageHistory = [];
const MAX_HISTORY = 100;

io.on('connection', (socket) => {
  console.log('New connection:', socket.id);

  /**
   * User joins
   */
  socket.on('join', (username) => {
    // Store user info
    users.set(socket.id, {
      id: socket.id,
      username,
      joinedAt: new Date()
    });

    console.log(`${username} joined (${socket.id})`);

    // Send chat history to new user
    socket.emit('history', messageHistory);

    // Notify others
    socket.broadcast.emit('user-joined', {
      username,
      userId: socket.id,
      timestamp: new Date()
    });

    // Send updated user list to everyone
    io.emit('user-list', Array.from(users.values()));
  });

  /**
   * Chat message
   */
  socket.on('chat-message', (data) => {
    const user = users.get(socket.id);

    if (!user) {
      socket.emit('error', { message: 'Please join first' });
      return;
    }

    const message = {
      id: Date.now(),
      userId: socket.id,
      username: user.username,
      text: data.text,
      timestamp: new Date()
    };

    // Store in history
    messageHistory.push(message);
    if (messageHistory.length > MAX_HISTORY) {
      messageHistory.shift();
    }

    // Broadcast to all clients
    io.emit('chat-message', message);

    console.log(`${user.username}: ${data.text}`);
  });

  /**
   * Typing indicator
   */
  socket.on('typing', () => {
    const user = users.get(socket.id);
    if (user) {
      socket.broadcast.emit('user-typing', {
        username: user.username,
        userId: socket.id
      });
    }
  });

  socket.on('stop-typing', () => {
    const user = users.get(socket.id);
    if (user) {
      socket.broadcast.emit('user-stop-typing', {
        username: user.username,
        userId: socket.id
      });
    }
  });

  /**
   * Private message
   */
  socket.on('private-message', ({ recipientId, text }) => {
    const sender = users.get(socket.id);
    const recipient = users.get(recipientId);

    if (!sender || !recipient) {
      socket.emit('error', { message: 'User not found' });
      return;
    }

    const message = {
      from: sender.username,
      fromId: socket.id,
      text,
      timestamp: new Date()
    };

    // Send to recipient
    io.to(recipientId).emit('private-message', message);

    // Confirm to sender
    socket.emit('private-message-sent', {
      to: recipient.username,
      toId: recipientId,
      text,
      timestamp: new Date()
    });
  });

  /**
   * Disconnect
   */
  socket.on('disconnect', () => {
    const user = users.get(socket.id);

    if (user) {
      console.log(`${user.username} disconnected`);

      // Remove user
      users.delete(socket.id);

      // Notify others
      io.emit('user-left', {
        username: user.username,
        userId: socket.id,
        timestamp: new Date()
      });

      // Send updated user list
      io.emit('user-list', Array.from(users.values()));
    }
  });

  /**
   * Error handling
   */
  socket.on('error', (error) => {
    console.error('Socket error:', error);
  });
});

httpServer.listen(3000, () => {
  console.log('Chat server running on port 3000');
});
```

### Enhanced Chat Client

```javascript
/**
 * Client-side chat application
 */

class ChatClient {
  constructor(serverUrl) {
    this.socket = io(serverUrl);
    this.username = null;
    this.typingTimeout = null;
    this.setupEventListeners();
  }

  setupEventListeners() {
    // Connection events
    this.socket.on('connect', () => {
      console.log('Connected to server');
      this.onConnect();
    });

    this.socket.on('disconnect', () => {
      console.log('Disconnected from server');
      this.onDisconnect();
    });

    // Chat events
    this.socket.on('history', (messages) => {
      this.displayHistory(messages);
    });

    this.socket.on('chat-message', (message) => {
      this.displayMessage(message);
    });

    this.socket.on('user-joined', (data) => {
      this.displaySystemMessage(`${data.username} joined the chat`);
    });

    this.socket.on('user-left', (data) => {
      this.displaySystemMessage(`${data.username} left the chat`);
    });

    this.socket.on('user-list', (users) => {
      this.updateUserList(users);
    });

    this.socket.on('user-typing', (data) => {
      this.showTypingIndicator(data.username);
    });

    this.socket.on('user-stop-typing', (data) => {
      this.hideTypingIndicator(data.username);
    });

    this.socket.on('private-message', (message) => {
      this.displayPrivateMessage(message, false);
    });

    this.socket.on('private-message-sent', (message) => {
      this.displayPrivateMessage(message, true);
    });

    this.socket.on('error', (error) => {
      this.displayError(error.message);
    });
  }

  join(username) {
    this.username = username;
    this.socket.emit('join', username);
  }

  sendMessage(text) {
    this.socket.emit('chat-message', { text });
  }

  sendPrivateMessage(recipientId, text) {
    this.socket.emit('private-message', { recipientId, text });
  }

  startTyping() {
    this.socket.emit('typing');

    // Auto-stop typing after 3 seconds
    clearTimeout(this.typingTimeout);
    this.typingTimeout = setTimeout(() => {
      this.stopTyping();
    }, 3000);
  }

  stopTyping() {
    this.socket.emit('stop-typing');
    clearTimeout(this.typingTimeout);
  }

  displayMessage(message) {
    const messageEl = document.createElement('div');
    messageEl.className = 'message';
    messageEl.innerHTML = `
      <strong>${message.username}</strong>
      <span class="timestamp">${new Date(message.timestamp).toLocaleTimeString()}</span>
      <p>${this.escapeHtml(message.text)}</p>
    `;
    document.getElementById('messages').appendChild(messageEl);
    this.scrollToBottom();
  }

  displaySystemMessage(text) {
    const messageEl = document.createElement('div');
    messageEl.className = 'system-message';
    messageEl.textContent = text;
    document.getElementById('messages').appendChild(messageEl);
    this.scrollToBottom();
  }

  displayHistory(messages) {
    messages.forEach(message => this.displayMessage(message));
  }

  updateUserList(users) {
    const userListEl = document.getElementById('user-list');
    userListEl.innerHTML = '';

    users.forEach(user => {
      const userEl = document.createElement('div');
      userEl.className = 'user';
      userEl.textContent = user.username;
      userEl.dataset.userId = user.id;
      userListEl.appendChild(userEl);
    });
  }

  showTypingIndicator(username) {
    const indicatorEl = document.getElementById('typing-indicator');
    indicatorEl.textContent = `${username} is typing...`;
    indicatorEl.style.display = 'block';
  }

  hideTypingIndicator(username) {
    const indicatorEl = document.getElementById('typing-indicator');
    indicatorEl.style.display = 'none';
  }

  displayPrivateMessage(message, isSent) {
    const messageEl = document.createElement('div');
    messageEl.className = 'private-message';

    if (isSent) {
      messageEl.innerHTML = `
        <strong>To ${message.to}:</strong>
        <p>${this.escapeHtml(message.text)}</p>
      `;
    } else {
      messageEl.innerHTML = `
        <strong>From ${message.from}:</strong>
        <p>${this.escapeHtml(message.text)}</p>
      `;
    }

    document.getElementById('messages').appendChild(messageEl);
    this.scrollToBottom();
  }

  displayError(message) {
    const errorEl = document.createElement('div');
    errorEl.className = 'error-message';
    errorEl.textContent = message;
    document.getElementById('messages').appendChild(errorEl);
  }

  scrollToBottom() {
    const messagesEl = document.getElementById('messages');
    messagesEl.scrollTop = messagesEl.scrollHeight;
  }

  escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  onConnect() {
    document.getElementById('connection-status').textContent = 'Connected';
    document.getElementById('connection-status').className = 'connected';
  }

  onDisconnect() {
    document.getElementById('connection-status').textContent = 'Disconnected';
    document.getElementById('connection-status').className = 'disconnected';
  }
}

// Initialize chat
const chat = new ChatClient('http://localhost:3000');

// Join chat
const username = prompt('Enter your username:');
if (username) {
  chat.join(username);
}

// Send message on button click
document.getElementById('sendButton').addEventListener('click', () => {
  const input = document.getElementById('messageInput');
  const text = input.value.trim();

  if (text) {
    chat.sendMessage(text);
    input.value = '';
    chat.stopTyping();
  }
});

// Typing indicator
let typingTimer;
document.getElementById('messageInput').addEventListener('input', () => {
  chat.startTyping();
});

document.getElementById('messageInput').addEventListener('keyup', () => {
  clearTimeout(typingTimer);
  typingTimer = setTimeout(() => {
    chat.stopTyping();
  }, 500);
});
```

---

## Broadcasting and Rooms

### Broadcasting Patterns

```javascript
/**
 * Different broadcasting patterns in Socket.IO
 */

io.on('connection', (socket) => {

  // 1. Emit to sender only
  socket.emit('welcome', { message: 'Welcome!' });

  // 2. Broadcast to everyone except sender
  socket.broadcast.emit('user-joined', { userId: socket.id });

  // 3. Emit to everyone (including sender)
  io.emit('announcement', { message: 'Server announcement' });

  // 4. Emit to specific socket
  io.to(socketId).emit('private', { message: 'Just for you' });

  // 5. Emit to room
  io.to('room1').emit('room-message', { text: 'Hello room!' });

  // 6. Emit to multiple rooms
  io.to('room1').to('room2').emit('multi-room', { text: 'Hello!' });

  // 7. Broadcast to room except sender
  socket.to('room1').emit('room-broadcast', { text: 'From another user' });

  // 8. Emit to all sockets in namespace
  io.of('/admin').emit('admin-notification', { text: 'Admin only' });
});
```

### Implementing Rooms

```javascript
/**
 * Chat application with multiple rooms
 */

import express from 'express';
import { createServer } from 'http';
import { Server } from 'socket.io';

const app = express();
const httpServer = createServer(app);
const io = new Server(httpServer);

// Store room data
const rooms = new Map();

io.on('connection', (socket) => {
  console.log('User connected:', socket.id);

  /**
   * Create room
   */
  socket.on('create-room', ({ roomName, username }) => {
    if (rooms.has(roomName)) {
      socket.emit('error', { message: 'Room already exists' });
      return;
    }

    rooms.set(roomName, {
      name: roomName,
      createdBy: socket.id,
      createdAt: new Date(),
      members: new Set([socket.id]),
      messages: []
    });

    socket.join(roomName);
    socket.emit('room-created', { roomName });
    socket.emit('joined-room', { roomName });

    console.log(`Room ${roomName} created by ${username}`);
  });

  /**
   * Join room
   */
  socket.on('join-room', ({ roomName, username }) => {
    const room = rooms.get(roomName);

    if (!room) {
      socket.emit('error', { message: 'Room not found' });
      return;
    }

    // Add user to room
    socket.join(roomName);
    room.members.add(socket.id);

    // Send room history to new member
    socket.emit('room-history', {
      roomName,
      messages: room.messages
    });

    // Notify room members
    socket.to(roomName).emit('user-joined-room', {
      roomName,
      userId: socket.id,
      username
    });

    // Confirm to user
    socket.emit('joined-room', { roomName });

    // Send updated member list
    io.to(roomName).emit('room-members', {
      roomName,
      members: Array.from(room.members)
    });

    console.log(`${username} joined room ${roomName}`);
  });

  /**
   * Leave room
   */
  socket.on('leave-room', ({ roomName, username }) => {
    const room = rooms.get(roomName);

    if (!room) return;

    socket.leave(roomName);
    room.members.delete(socket.id);

    // Notify room
    socket.to(roomName).emit('user-left-room', {
      roomName,
      userId: socket.id,
      username
    });

    // Update member list
    io.to(roomName).emit('room-members', {
      roomName,
      members: Array.from(room.members)
    });

    // Delete room if empty
    if (room.members.size === 0) {
      rooms.delete(roomName);
      console.log(`Room ${roomName} deleted (empty)`);
    }
  });

  /**
   * Send message to room
   */
  socket.on('room-message', ({ roomName, text, username }) => {
    const room = rooms.get(roomName);

    if (!room) {
      socket.emit('error', { message: 'Room not found' });
      return;
    }

    if (!room.members.has(socket.id)) {
      socket.emit('error', { message: 'Not a member of this room' });
      return;
    }

    const message = {
      id: Date.now(),
      roomName,
      userId: socket.id,
      username,
      text,
      timestamp: new Date()
    };

    // Store message
    room.messages.push(message);

    // Broadcast to room
    io.to(roomName).emit('room-message', message);
  });

  /**
   * List available rooms
   */
  socket.on('list-rooms', () => {
    const roomList = Array.from(rooms.entries()).map(([name, data]) => ({
      name,
      memberCount: data.members.size,
      createdAt: data.createdAt
    }));

    socket.emit('room-list', roomList);
  });

  /**
   * Disconnect - leave all rooms
   */
  socket.on('disconnect', () => {
    // Remove from all rooms
    rooms.forEach((room, roomName) => {
      if (room.members.has(socket.id)) {
        room.members.delete(socket.id);

        // Notify room
        socket.to(roomName).emit('user-left-room', {
          roomName,
          userId: socket.id
        });

        // Delete empty rooms
        if (room.members.size === 0) {
          rooms.delete(roomName);
        }
      }
    });
  });
});

httpServer.listen(3000);
```

---

## Handling Disconnections

### Graceful Disconnection Handling

```javascript
/**
 * Robust disconnection and reconnection handling
 */

import { Server } from 'socket.io';

const io = new Server(httpServer, {
  // Connection settings
  pingTimeout: 60000, // How long to wait for pong before closing
  pingInterval: 25000, // How often to send ping

  // Reconnection settings (client-side)
  reconnection: true,
  reconnectionAttempts: 5,
  reconnectionDelay: 1000,
  reconnectionDelayMax: 5000
});

// Track user sessions across reconnections
const sessions = new Map();

io.on('connection', (socket) => {
  console.log('Connection:', socket.id);

  /**
   * Register session
   */
  socket.on('register', ({ userId, username }) => {
    // Store session data
    sessions.set(userId, {
      socketId: socket.id,
      username,
      lastSeen: new Date(),
      isOnline: true
    });

    // Associate socket with userId
    socket.userId = userId;
    socket.username = username;

    console.log(`${username} registered (${userId})`);

    // Notify others user is online
    socket.broadcast.emit('user-online', {
      userId,
      username
    });
  });

  /**
   * Handle disconnection
   */
  socket.on('disconnect', (reason) => {
    console.log('Disconnect:', socket.id, reason);

    if (socket.userId) {
      const session = sessions.get(socket.userId);

      if (session) {
        session.isOnline = false;
        session.lastSeen = new Date();

        // Give grace period before marking offline
        setTimeout(() => {
          const currentSession = sessions.get(socket.userId);

          // If still offline after grace period
          if (currentSession && !currentSession.isOnline) {
            console.log(`${socket.username} is offline`);

            socket.broadcast.emit('user-offline', {
              userId: socket.userId,
              username: socket.username,
              lastSeen: currentSession.lastSeen
            });
          }
        }, 5000); // 5 second grace period
      }
    }
  });

  /**
   * Handle reconnection
   */
  socket.on('reconnect-session', ({ userId }) => {
    const session = sessions.get(userId);

    if (session) {
      // Update session
      session.socketId = socket.id;
      session.isOnline = true;
      session.lastSeen = new Date();

      socket.userId = userId;
      socket.username = session.username;

      console.log(`${session.username} reconnected`);

      // Send restored data
      socket.emit('session-restored', {
        username: session.username,
        // Include any other session data
      });

      // Notify others
      socket.broadcast.emit('user-online', {
        userId,
        username: session.username
      });
    }
  });

  /**
   * Heartbeat mechanism
   */
  socket.on('ping', () => {
    socket.emit('pong');
  });

  /**
   * Graceful disconnect
   */
  socket.on('logout', () => {
    if (socket.userId) {
      sessions.delete(socket.userId);

      socket.broadcast.emit('user-offline', {
        userId: socket.userId,
        username: socket.username
      });
    }

    socket.disconnect(true);
  });
});

/**
 * Client-side reconnection handling
 */

const clientReconnection = `
const socket = io('http://localhost:3000', {
  reconnection: true,
  reconnectionAttempts: 5,
  reconnectionDelay: 1000
});

let userId = localStorage.getItem('userId');
if (!userId) {
  userId = generateUserId();
  localStorage.setItem('userId', userId);
}

socket.on('connect', () => {
  console.log('Connected');

  // Try to restore session
  socket.emit('reconnect-session', { userId });
});

socket.on('disconnect', () => {
  console.log('Disconnected');
  showReconnectingMessage();
});

socket.on('session-restored', (data) => {
  console.log('Session restored:', data);
  hideReconnectingMessage();
});

socket.on('connect_error', (error) => {
  console.error('Connection error:', error);
});

// Heartbeat
setInterval(() => {
  socket.emit('ping');
}, 30000);

socket.on('pong', () => {
  console.log('Server alive');
});
`;
```

---

## Authentication and Authorization

### Authenticating WebSocket Connections

```javascript
/**
 * WebSocket authentication with JWT
 */

import { Server } from 'socket.io';
import jwt from 'jsonwebtoken';

const io = new Server(httpServer, {
  cors: {
    origin: process.env.CLIENT_URL,
    credentials: true
  }
});

/**
 * Authentication middleware
 */
io.use((socket, next) => {
  try {
    // Get token from handshake
    const token = socket.handshake.auth.token ||
                 socket.handshake.headers.authorization?.split(' ')[1];

    if (!token) {
      return next(new Error('Authentication required'));
    }

    // Verify token
    const decoded = jwt.verify(token, process.env.JWT_SECRET);

    // Attach user to socket
    socket.user = {
      id: decoded.userId,
      email: decoded.email,
      username: decoded.username
    };

    next();
  } catch (error) {
    console.error('Auth error:', error);
    next(new Error('Invalid token'));
  }
});

/**
 * Authenticated connection
 */
io.on('connection', (socket) => {
  console.log(`Authenticated user connected: ${socket.user.username}`);

  // User has access to socket.user in all handlers
  socket.on('message', (data) => {
    console.log(`Message from ${socket.user.username}:`, data);

    io.emit('message', {
      userId: socket.user.id,
      username: socket.user.username,
      text: data.text,
      timestamp: new Date()
    });
  });
});

/**
 * Client-side authentication
 */

const clientAuth = `
// Get token (from login)
const token = localStorage.getItem('token');

// Connect with auth
const socket = io('http://localhost:3000', {
  auth: {
    token: token
  }
});

socket.on('connect_error', (error) => {
  if (error.message === 'Authentication required' ||
      error.message === 'Invalid token') {
    // Redirect to login
    window.location.href = '/login';
  }
});
`;
```

### Room-Based Authorization

```javascript
/**
 * Authorize access to specific rooms
 */

io.on('connection', (socket) => {

  socket.on('join-room', async ({ roomId }) => {
    try {
      // Check if user has permission
      const hasAccess = await checkRoomAccess(socket.user.id, roomId);

      if (!hasAccess) {
        socket.emit('error', {
          message: 'Not authorized to join this room'
        });
        return;
      }

      // Join room
      socket.join(roomId);
      socket.emit('joined-room', { roomId });

      // Notify room
      socket.to(roomId).emit('user-joined', {
        userId: socket.user.id,
        username: socket.user.username
      });
    } catch (error) {
      socket.emit('error', { message: 'Failed to join room' });
    }
  });

  socket.on('room-message', async ({ roomId, text }) => {
    // Verify user is in room
    const rooms = Array.from(socket.rooms);

    if (!rooms.includes(roomId)) {
      socket.emit('error', { message: 'Not a member of this room' });
      return;
    }

    // Broadcast message
    io.to(roomId).emit('room-message', {
      roomId,
      userId: socket.user.id,
      username: socket.user.username,
      text,
      timestamp: new Date()
    });
  });
});

/**
 * Check room access
 */
async function checkRoomAccess(userId, roomId) {
  // Check database for room membership
  const membership = await RoomMembership.findOne({
    userId,
    roomId,
    isActive: true
  });

  return !!membership;
}
```

---

## Scaling WebSockets

### Multi-Server Architecture

```javascript
/**
 * Scale Socket.IO across multiple servers using Redis
 *
 * Install: npm install @socket.io/redis-adapter redis
 */

import { Server } from 'socket.io';
import { createAdapter } from '@socket.io/redis-adapter';
import { createClient } from 'redis';

const io = new Server(httpServer);

// Create Redis clients
const pubClient = createClient({ url: 'redis://localhost:6379' });
const subClient = pubClient.duplicate();

// Connect to Redis
Promise.all([pubClient.connect(), subClient.connect()]).then(() => {
  // Setup Redis adapter
  io.adapter(createAdapter(pubClient, subClient));
  console.log('Redis adapter connected');
});

/**
 * Now Socket.IO can scale across multiple servers
 *
 * Server 1 (port 3000) <---> Redis <---> Server 2 (port 3001)
 *
 * When Server 1 emits: io.emit('message', data)
 * Clients on both servers receive the message
 */

io.on('connection', (socket) => {
  console.log('User connected:', socket.id);

  // This will work across all servers
  socket.on('broadcast', (data) => {
    io.emit('message', data); // All clients on all servers receive this
  });

  // Rooms also work across servers
  socket.on('join-room', (roomId) => {
    socket.join(roomId);
    io.to(roomId).emit('user-joined', socket.id); // Works across servers
  });
});
```

### Load Balancing with Nginx

```nginx
# nginx.conf for WebSocket load balancing

upstream socket_nodes {
    ip_hash; # Sticky sessions
    server localhost:3000;
    server localhost:3001;
    server localhost:3002;
}

server {
    listen 80;
    server_name example.com;

    location /socket.io/ {
        proxy_pass http://socket_nodes;
        proxy_http_version 1.1;

        # WebSocket headers
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;

        # Proxy headers
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # Timeouts
        proxy_connect_timeout 7d;
        proxy_send_timeout 7d;
        proxy_read_timeout 7d;
    }
}
```

---

## WebSocket vs Polling vs SSE

### Comparison

```javascript
/**
 * Real-time communication methods comparison
 */

const methods = {
  webSocket: {
    direction: 'Bidirectional (full-duplex)',
    latency: 'Very low',
    overhead: 'Low',
    browserSupport: 'Excellent (IE10+)',
    complexity: 'Medium',
    useCases: ['Chat', 'Gaming', 'Collaboration', 'Live trading'],
    pros: [
      'True real-time',
      'Bidirectional',
      'Low latency',
      'Low overhead'
    ],
    cons: [
      'More complex',
      'Stateful connections',
      'Scaling requires planning'
    ]
  },

  longPolling: {
    direction: 'Unidirectional (server to client)',
    latency: 'Medium',
    overhead: 'High',
    browserSupport: 'Universal',
    complexity: 'Low',
    useCases: ['Legacy browsers', 'Simple notifications'],
    pros: [
      'Universal browser support',
      'Simple',
      'Works through proxies'
    ],
    cons: [
      'High overhead',
      'Higher latency',
      'Server load from constant requests'
    ]
  },

  serverSentEvents: {
    direction: 'Unidirectional (server to client)',
    latency: 'Low',
    overhead: 'Low',
    browserSupport: 'Good (no IE)',
    complexity: 'Low',
    useCases: ['Live updates', 'Notifications', 'News feeds'],
    pros: [
      'Simple',
      'Low overhead',
      'Auto-reconnect',
      'Text-based'
    ],
    cons: [
      'One-way only',
      'No binary data',
      'Connection limits per domain'
    ]
  }
};
```

### HTTP Long Polling Example

```javascript
/**
 * Long polling implementation
 */

// Server
app.get('/api/poll', async (req, res) => {
  const lastId = parseInt(req.query.lastId) || 0;

  // Wait for new messages (with timeout)
  const timeout = 30000; // 30 seconds
  const interval = 100; // Check every 100ms
  const startTime = Date.now();

  const checkForMessages = async () => {
    const messages = await Message.find({
      id: { $gt: lastId }
    });

    if (messages.length > 0) {
      return res.json({ messages });
    }

    if (Date.now() - startTime > timeout) {
      return res.json({ messages: [] });
    }

    setTimeout(checkForMessages, interval);
  };

  checkForMessages();
});

// Client
async function pollForMessages(lastId = 0) {
  try {
    const response = await fetch(`/api/poll?lastId=${lastId}`);
    const data = await response.json();

    if (data.messages.length > 0) {
      displayMessages(data.messages);
      lastId = data.messages[data.messages.length - 1].id;
    }

    // Immediately poll again
    pollForMessages(lastId);
  } catch (error) {
    console.error('Polling error:', error);
    // Retry after delay
    setTimeout(() => pollForMessages(lastId), 5000);
  }
}

pollForMessages();
```

### Server-Sent Events Example

```javascript
/**
 * SSE implementation
 */

// Server
app.get('/api/events', (req, res) => {
  // Set SSE headers
  res.setHeader('Content-Type', 'text/event-stream');
  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('Connection', 'keep-alive');

  // Send initial connection message
  res.write('data: {"type":"connected"}\n\n');

  // Send events periodically
  const interval = setInterval(() => {
    const data = {
      type: 'update',
      timestamp: new Date(),
      value: Math.random()
    };

    res.write(`data: ${JSON.stringify(data)}\n\n`);
  }, 1000);

  // Cleanup on close
  req.on('close', () => {
    clearInterval(interval);
    res.end();
  });
});

// Client
const eventSource = new EventSource('/api/events');

eventSource.onmessage = (event) => {
  const data = JSON.parse(event.data);
  console.log('Received:', data);
};

eventSource.onerror = (error) => {
  console.error('SSE error:', error);
};

// Named events
eventSource.addEventListener('custom-event', (event) => {
  console.log('Custom event:', event.data);
});
```

---

## Worked Examples

### Example 1: Collaborative Drawing App

```javascript
/**
 * Real-time collaborative whiteboard
 *
 * Features:
 * - Multiple users drawing simultaneously
 * - Cursor tracking
 * - Color selection
 * - Clear board
 */

// Server
import { Server } from 'socket.io';

const io = new Server(httpServer);

// Store drawing state
const drawings = new Map();
const cursors = new Map();

io.on('connection', (socket) => {
  const roomId = socket.handshake.query.roomId || 'default';
  socket.join(roomId);

  // Send current drawing state
  const currentDrawing = drawings.get(roomId) || [];
  socket.emit('drawing-state', currentDrawing);

  // Drawing events
  socket.on('draw', (data) => {
    const drawingData = {
      ...data,
      userId: socket.id,
      timestamp: Date.now()
    };

    // Store drawing
    if (!drawings.has(roomId)) {
      drawings.set(roomId, []);
    }
    drawings.get(roomId).push(drawingData);

    // Broadcast to others in room
    socket.to(roomId).emit('draw', drawingData);
  });

  // Cursor movement
  socket.on('cursor-move', (data) => {
    cursors.set(socket.id, data);
    socket.to(roomId).emit('cursor-move', {
      userId: socket.id,
      ...data
    });
  });

  // Clear board
  socket.on('clear-board', () => {
    drawings.set(roomId, []);
    io.to(roomId).emit('board-cleared');
  });

  // Disconnect
  socket.on('disconnect', () => {
    cursors.delete(socket.id);
    socket.to(roomId).emit('cursor-remove', { userId: socket.id });
  });
});

// Client
class CollaborativeCanvas {
  constructor(canvasId, roomId) {
    this.canvas = document.getElementById(canvasId);
    this.ctx = this.canvas.getContext('2d');
    this.socket = io(`http://localhost:3000?roomId=${roomId}`);
    this.isDrawing = false;
    this.currentColor = '#000000';
    this.setupListeners();
  }

  setupListeners() {
    // Socket events
    this.socket.on('drawing-state', (drawings) => {
      drawings.forEach(draw => this.drawLine(draw));
    });

    this.socket.on('draw', (data) => {
      this.drawLine(data);
    });

    this.socket.on('cursor-move', (data) => {
      this.drawCursor(data);
    });

    this.socket.on('board-cleared', () => {
      this.clearCanvas();
    });

    // Canvas events
    this.canvas.addEventListener('mousedown', (e) => {
      this.isDrawing = true;
      this.lastX = e.offsetX;
      this.lastY = e.offsetY;
    });

    this.canvas.addEventListener('mousemove', (e) => {
      // Send cursor position
      this.socket.emit('cursor-move', {
        x: e.offsetX,
        y: e.offsetY
      });

      if (this.isDrawing) {
        const drawData = {
          x1: this.lastX,
          y1: this.lastY,
          x2: e.offsetX,
          y2: e.offsetY,
          color: this.currentColor
        };

        this.drawLine(drawData);
        this.socket.emit('draw', drawData);

        this.lastX = e.offsetX;
        this.lastY = e.offsetY;
      }
    });

    this.canvas.addEventListener('mouseup', () => {
      this.isDrawing = false;
    });
  }

  drawLine(data) {
    this.ctx.beginPath();
    this.ctx.moveTo(data.x1, data.y1);
    this.ctx.lineTo(data.x2, data.y2);
    this.ctx.strokeStyle = data.color;
    this.ctx.lineWidth = 2;
    this.ctx.stroke();
  }

  drawCursor(data) {
    // Draw other users' cursors
    this.ctx.fillStyle = 'red';
    this.ctx.fillRect(data.x - 2, data.y - 2, 4, 4);
  }

  clearCanvas() {
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
  }

  setColor(color) {
    this.currentColor = color;
  }

  clear() {
    this.socket.emit('clear-board');
    this.clearCanvas();
  }
}
```

### Example 2: Live Notifications System

```javascript
/**
 * Real-time notification system
 *
 * Features:
 * - User-specific notifications
 * - Read/unread status
 * - Notification history
 * - Push notifications
 */

// Server
io.on('connection', (socket) => {
  const userId = socket.user.id;

  // Join user's personal room
  socket.join(`user:${userId}`);

  // Send unread notifications
  socket.on('get-notifications', async () => {
    const notifications = await Notification.find({
      userId,
      read: false
    }).sort({ createdAt: -1 });

    socket.emit('notifications', notifications);
  });

  // Mark as read
  socket.on('mark-read', async (notificationId) => {
    await Notification.updateOne(
      { _id: notificationId, userId },
      { read: true, readAt: new Date() }
    );

    socket.emit('notification-read', { notificationId });
  });

  // Mark all as read
  socket.on('mark-all-read', async () => {
    await Notification.updateMany(
      { userId, read: false },
      { read: true, readAt: new Date() }
    );

    socket.emit('all-read');
  });
});

/**
 * Send notification to user (from anywhere in app)
 */
async function sendNotification(userId, notification) {
  // Save to database
  const saved = await Notification.create({
    userId,
    type: notification.type,
    title: notification.title,
    message: notification.message,
    data: notification.data,
    read: false
  });

  // Send via Socket.IO
  io.to(`user:${userId}`).emit('notification', saved);

  return saved;
}

// Client
class NotificationManager {
  constructor() {
    this.socket = io('http://localhost:3000', {
      auth: { token: localStorage.getItem('token') }
    });
    this.setupListeners();
  }

  setupListeners() {
    this.socket.on('notification', (notification) => {
      this.displayNotification(notification);
      this.updateBadge();
    });

    this.socket.on('notifications', (notifications) => {
      this.displayNotificationList(notifications);
    });
  }

  loadNotifications() {
    this.socket.emit('get-notifications');
  }

  markAsRead(notificationId) {
    this.socket.emit('mark-read', notificationId);
  }

  markAllAsRead() {
    this.socket.emit('mark-all-read');
  }

  displayNotification(notification) {
    // Show browser notification
    if ('Notification' in window && Notification.permission === 'granted') {
      new Notification(notification.title, {
        body: notification.message,
        icon: '/icon.png'
      });
    }

    // Show in-app notification
    const notifEl = document.createElement('div');
    notifEl.className = 'notification';
    notifEl.innerHTML = `
      <h4>${notification.title}</h4>
      <p>${notification.message}</p>
    `;
    document.getElementById('notifications').prepend(notifEl);

    this.updateBadge();
  }

  updateBadge() {
    const unreadCount = document.querySelectorAll('.notification.unread').length;
    document.getElementById('notification-badge').textContent = unreadCount;
  }
}
```

### Example 3: Live Dashboard

```javascript
/**
 * Real-time analytics dashboard
 *
 * Features:
 * - Live metrics updates
 * - Real-time charts
 * - Multiple data streams
 */

// Server
import { Server } from 'socket.io';

const io = new Server(httpServer);

// Simulated metrics (in real app, get from monitoring system)
function generateMetrics() {
  return {
    activeUsers: Math.floor(Math.random() * 1000) + 500,
    requestsPerSecond: Math.floor(Math.random() * 100) + 50,
    cpuUsage: Math.random() * 100,
    memoryUsage: Math.random() * 100,
    errorRate: Math.random() * 5,
    timestamp: new Date()
  };
}

io.on('connection', (socket) => {
  console.log('Dashboard connected:', socket.id);

  // Send initial metrics
  socket.emit('metrics', generateMetrics());

  // Send metrics every 2 seconds
  const interval = setInterval(() => {
    socket.emit('metrics', generateMetrics());
  }, 2000);

  socket.on('disconnect', () => {
    clearInterval(interval);
  });

  // Historical data request
  socket.on('get-history', async ({ metric, timeRange }) => {
    const history = await getMetricHistory(metric, timeRange);
    socket.emit('history', { metric, data: history });
  });
});

// Client
class LiveDashboard {
  constructor() {
    this.socket = io('http://localhost:3000');
    this.charts = {};
    this.setupListeners();
  }

  setupListeners() {
    this.socket.on('metrics', (data) => {
      this.updateMetrics(data);
      this.updateCharts(data);
    });

    this.socket.on('history', ({ metric, data }) => {
      this.renderHistoryChart(metric, data);
    });
  }

  updateMetrics(data) {
    document.getElementById('active-users').textContent = data.activeUsers;
    document.getElementById('requests-per-sec').textContent = data.requestsPerSecond;
    document.getElementById('cpu-usage').textContent = `${data.cpuUsage.toFixed(1)}%`;
    document.getElementById('memory-usage').textContent = `${data.memoryUsage.toFixed(1)}%`;
    document.getElementById('error-rate').textContent = `${data.errorRate.toFixed(2)}%`;
  }

  updateCharts(data) {
    // Update real-time line charts
    Object.keys(this.charts).forEach(chartId => {
      const chart = this.charts[chartId];

      // Add new data point
      chart.data.labels.push(new Date(data.timestamp).toLocaleTimeString());
      chart.data.datasets[0].data.push(data[chartId]);

      // Keep only last 20 points
      if (chart.data.labels.length > 20) {
        chart.data.labels.shift();
        chart.data.datasets[0].data.shift();
      }

      chart.update();
    });
  }

  getHistory(metric, timeRange) {
    this.socket.emit('get-history', { metric, timeRange });
  }
}
```

---

## Exercises

### Exercise 1: Build a Typing Indicator (Easy)

**Problem:** Implement a typing indicator for a chat application.

```javascript
/**
 * Requirements:
 * - Show "User is typing..." when they type
 * - Hide after 2 seconds of inactivity
 * - Don't show for the sender
 */

// Your implementation here
```

**Solution:** See `solutions/exercise1_websockets.js`

---

### Exercise 2: Online Users List (Medium)

**Problem:** Create a real-time online users list with presence tracking.

```javascript
/**
 * Requirements:
 * - Track users online/offline status
 * - Show last seen timestamp
 * - Handle page visibility (away status)
 * - Persist across reconnections
 */

// Your implementation
```

**Solution:** See `solutions/exercise2_websockets.js`

---

### Exercise 3: File Sharing (Medium)

**Problem:** Implement real-time file sharing in a chat room.

```javascript
/**
 * Requirements:
 * - Upload files through Socket.IO
 * - Show upload progress
 * - Broadcast to room members
 * - Handle large files (chunking)
 */

// Your implementation
```

**Solution:** See `solutions/exercise3_websockets.js`

---

### Exercise 4: Live Polls (Hard)

**Problem:** Create a real-time polling system.

```javascript
/**
 * Requirements:
 * - Create polls with multiple options
 * - Real-time vote counting
 * - Live results visualization
 * - Prevent double voting
 * - Handle concurrent votes
 */

// Your implementation
```

**Solution:** See `solutions/exercise4_websockets.js`

---

### Exercise 5: Multiplayer Game (Hard)

**Problem:** Build a simple multiplayer game (e.g., tic-tac-toe).

```javascript
/**
 * Requirements:
 * - Match players
 * - Synchronize game state
 * - Handle player disconnections
 * - Implement game logic
 * - Real-time move updates
 */

// Your implementation
```

**Solution:** See `solutions/exercise5_websockets.js`

---

## Testing & Verification

```javascript
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { Server } from 'socket.io';
import { io as Client } from 'socket.io-client';
import { createServer } from 'http';

describe('WebSocket Communication', () => {
  let io, httpServer, clientSocket, serverSocket;

  beforeAll((done) => {
    httpServer = createServer();
    io = new Server(httpServer);

    httpServer.listen(() => {
      const port = httpServer.address().port;
      clientSocket = Client(`http://localhost:${port}`);

      io.on('connection', (socket) => {
        serverSocket = socket;
      });

      clientSocket.on('connect', done);
    });
  });

  afterAll(() => {
    io.close();
    clientSocket.close();
  });

  it('should communicate between client and server', (done) => {
    clientSocket.on('hello', (message) => {
      expect(message).toBe('world');
      done();
    });

    serverSocket.emit('hello', 'world');
  });

  it('should broadcast messages', (done) => {
    const client2 = Client(`http://localhost:${httpServer.address().port}`);

    client2.on('broadcast', (message) => {
      expect(message).toBe('test');
      client2.close();
      done();
    });

    clientSocket.emit('send-broadcast', 'test');
  });

  it('should handle rooms', (done) => {
    serverSocket.join('room1');

    clientSocket.on('room-message', (message) => {
      expect(message).toBe('hello room');
      done();
    });

    io.to('room1').emit('room-message', 'hello room');
  });
});
```

---

## Best Practices

1. **Always authenticate WebSocket connections** before allowing access
2. **Implement reconnection logic** with exponential backoff
3. **Use rooms** for targeted messaging instead of broadcasting everything
4. **Validate all incoming messages** on the server
5. **Set appropriate timeouts** for ping/pong
6. **Implement rate limiting** to prevent abuse
7. **Use Redis adapter** when scaling across multiple servers
8. **Handle errors gracefully** with proper error events
9. **Monitor connection counts** and server resources
10. **Clean up resources** on disconnect (intervals, listeners)

---

## Common Pitfalls

1. **Not handling disconnections** properly
2. **Broadcasting too frequently** causing network congestion
3. **Storing too much state** in memory
4. **Not implementing authentication** for WebSocket connections
5. **Forgetting to clean up** listeners and intervals
6. **Not scaling** WebSocket servers properly
7. **Sending large payloads** over WebSockets
8. **Not implementing backpressure** control
9. **Exposing internal system details** in messages
10. **Not monitoring** connection health

---

## Performance Considerations

```javascript
/**
 * Performance optimization techniques
 */

// 1. Message batching
const messageBatch = [];
setInterval(() => {
  if (messageBatch.length > 0) {
    io.emit('messages-batch', messageBatch);
    messageBatch.length = 0;
  }
}, 100);

// 2. Binary data transmission
socket.emit('image', buffer); // Binary, not JSON

// 3. Compression
const io = new Server(httpServer, {
  perMessageDeflate: {
    threshold: 1024 // Only compress messages > 1KB
  }
});

// 4. Namespace isolation
const chatNamespace = io.of('/chat');
const notifNamespace = io.of('/notifications');

// 5. Room optimization
//  BAD: Check all sockets
io.sockets.sockets.forEach(socket => {
  if (socket.userId === targetUserId) {
    socket.emit('message', data);
  }
});

//  GOOD: Use rooms
io.to(`user:${targetUserId}`).emit('message', data);
```

---

## Summary & Next Steps

### Key Takeaways

- WebSockets provide persistent, bidirectional communication
- Socket.IO adds features like rooms, reconnection, and fallbacks
- Proper authentication and authorization are critical
- Handle disconnections gracefully with reconnection logic
- Scale with Redis adapter for multi-server deployments
- Choose the right real-time method for your use case

### Related Topics

- [Authentication and Authorization](./37.Authentication_And_Authorization.md)
- [Performance and Optimization](./40.Performance_And_Optimization.md)
- [Testing Backend Applications](./39.Testing_Backend_Applications.md)

### Further Reading

- [Socket.IO Documentation](https://socket.io/docs/)
- [WebSocket Protocol RFC 6455](https://tools.ietf.org/html/rfc6455)
- [Scaling WebSockets](https://socket.io/docs/v4/using-multiple-nodes/)

---

## References

- Socket.IO: https://socket.io/
- WebSocket API: https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API
- ws Library: https://github.com/websockets/ws
- Redis Adapter: https://socket.io/docs/v4/redis-adapter/

---

**Next Lesson:** [Testing Backend Applications](./39.Testing_Backend_Applications.md)
