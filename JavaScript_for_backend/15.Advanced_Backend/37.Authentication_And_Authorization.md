# Authentication and Authorization in Node.js

**Difficulty:** Intermediate to Advanced
**Estimated Time:** 90-120 minutes
**Prerequisites:** Node.js, Express.js, async/await, database integration
**Target:** Node.js 18+ LTS, Express 4+

---

## Learning Objectives

By the end of this lesson, you will be able to:

1. Understand the fundamental difference between authentication and authorization
2. Implement session-based authentication with express-session
3. Create token-based authentication using JWT (JSON Web Tokens)
4. Hash and verify passwords securely using bcrypt
5. Implement OAuth 2.0 authentication flow
6. Manage refresh tokens for long-lived sessions
7. Build role-based access control (RBAC) systems
8. Apply security best practices for auth systems
9. Handle common auth vulnerabilities
10. Choose the right authentication strategy for your application

---

## Table of Contents

1. [Introduction](#introduction)
2. [Authentication vs Authorization](#authentication-vs-authorization)
3. [Password Hashing with bcrypt](#password-hashing-with-bcrypt)
4. [Session-Based Authentication](#session-based-authentication)
5. [Token-Based Authentication (JWT)](#token-based-authentication-jwt)
6. [OAuth 2.0 Basics](#oauth-20-basics)
7. [Refresh Tokens](#refresh-tokens)
8. [Role-Based Access Control (RBAC)](#role-based-access-control-rbac)
9. [Security Best Practices](#security-best-practices)
10. [Worked Examples](#worked-examples)
11. [Exercises](#exercises)
12. [Testing & Verification](#testing--verification)
13. [Best Practices](#best-practices)
14. [Common Pitfalls](#common-pitfalls)
15. [Performance Considerations](#performance-considerations)
16. [Summary & Next Steps](#summary--next-steps)
17. [References](#references)

---

## Introduction

Authentication and authorization are fundamental security concepts in backend development. Properly implementing these systems protects user data and ensures only authorized users can access specific resources.

**Why Auth Matters:**

- **Security:** Protect sensitive user data and resources
- **Privacy:** Ensure users only see their own data
- **Compliance:** Meet regulatory requirements (GDPR, HIPAA, etc.)
- **User Experience:** Seamless login and access control
- **Accountability:** Track who did what and when

**Real-World Applications:**

- **E-commerce:** User accounts, order history, payment methods
- **Social Media:** User profiles, private messages, content access
- **SaaS Applications:** Multi-tenant systems, feature access tiers
- **Healthcare:** Patient records, HIPAA compliance
- **Financial Systems:** Account access, transaction authorization

---

## Authentication vs Authorization

### Understanding the Difference

```javascript
/**
 * Authentication vs Authorization
 */

const authConcepts = {
  authentication: {
    question: 'Who are you?',
    purpose: 'Verify user identity',
    examples: [
      'Login with username/password',
      'Verify JWT token',
      'OAuth login with Google',
      'Biometric verification'
    ],
    result: 'User is identified'
  },

  authorization: {
    question: 'What can you do?',
    purpose: 'Verify user permissions',
    examples: [
      'Can user access this resource?',
      'Does user have admin role?',
      'Is user owner of this data?',
      'Has subscription expired?'
    ],
    result: 'Access is granted or denied'
  }
};

/**
 * Real-world analogy
 */
const airportSecurity = {
  authentication: 'Checking your ID at security checkpoint',
  authorization: 'Checking your boarding pass for gate access'
};
```

### Flow Example

```javascript
/**
 * Typical auth flow in an Express app
 */

import express from 'express';

const app = express();

// 1. AUTHENTICATION: Who are you?
app.post('/api/login', async (req, res) => {
  const { email, password } = req.body;

  // Verify credentials
  const user = await User.findOne({ email });
  if (!user || !await user.comparePassword(password)) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }

  // User is authenticated - create session/token
  const token = generateToken(user);
  res.json({ token, user: { id: user.id, email: user.email } });
});

// 2. AUTHORIZATION: What can you do?
app.delete('/api/posts/:id', authenticateUser, async (req, res) => {
  const post = await Post.findById(req.params.id);

  // Check if user is authorized (owns the post or is admin)
  if (post.authorId !== req.user.id && !req.user.isAdmin) {
    return res.status(403).json({ error: 'Not authorized' });
  }

  await post.delete();
  res.json({ message: 'Post deleted' });
});
```

---

## Password Hashing with bcrypt

### Why Hash Passwords?

```javascript
/**
 * Install: npm install bcrypt
 */

import bcrypt from 'bcrypt';

/**
 * NEVER store passwords in plain text!
 */

// ❌ TERRIBLE - Never do this
const badUser = {
  email: 'user@example.com',
  password: 'MyPassword123' // Plain text - anyone with DB access can see it!
};

// ✅ GOOD - Hash passwords
const goodUser = {
  email: 'user@example.com',
  password: '$2b$10$rZY8qgwF4...' // Hashed - unreadable
};

/**
 * How bcrypt works
 */
const hashingExample = {
  input: 'MyPassword123',
  salt: 10, // Cost factor (higher = more secure, slower)
  hash: '$2b$10$rZY8qgwF4pZRfXZpF1dP7.V4WkN8KdBwdP2xSqf0V0FJ7X6k4H0gu',

  properties: {
    irreversible: 'Cannot decrypt hash back to password',
    unique: 'Same password + different salt = different hash',
    slow: 'Intentionally slow to prevent brute force',
    adaptive: 'Can increase cost factor over time'
  }
};
```

### Implementing Password Hashing

```javascript
/**
 * Complete password hashing implementation
 */

import bcrypt from 'bcrypt';

const SALT_ROUNDS = 10; // Balance between security and performance

/**
 * Hash a password
 */
const hashPassword = async (plainPassword) => {
  try {
    const hash = await bcrypt.hash(plainPassword, SALT_ROUNDS);
    return hash;
  } catch (error) {
    console.error('Error hashing password:', error);
    throw new Error('Could not hash password');
  }
};

/**
 * Verify a password
 */
const verifyPassword = async (plainPassword, hashedPassword) => {
  try {
    const isMatch = await bcrypt.compare(plainPassword, hashedPassword);
    return isMatch;
  } catch (error) {
    console.error('Error verifying password:', error);
    return false;
  }
};

/**
 * Example usage
 */
const demonstrateHashing = async () => {
  const password = 'MySecurePassword123!';

  // Hash the password
  const hash1 = await hashPassword(password);
  const hash2 = await hashPassword(password);

  console.log('Hash 1:', hash1);
  console.log('Hash 2:', hash2);
  console.log('Hashes are different:', hash1 !== hash2);

  // Verify password
  const isValid = await verifyPassword(password, hash1);
  console.log('Password valid:', isValid); // true

  const isInvalid = await verifyPassword('WrongPassword', hash1);
  console.log('Wrong password:', isInvalid); // false
};
```

### Integration with User Model

```javascript
/**
 * User model with password hashing (Mongoose example)
 */

import mongoose from 'mongoose';
import bcrypt from 'bcrypt';

const userSchema = new mongoose.Schema({
  email: {
    type: String,
    required: true,
    unique: true,
    lowercase: true
  },
  password: {
    type: String,
    required: true,
    minlength: 8
  },
  username: {
    type: String,
    required: true,
    unique: true
  }
}, { timestamps: true });

// Hash password before saving
userSchema.pre('save', async function(next) {
  // Only hash if password is new or modified
  if (!this.isModified('password')) {
    return next();
  }

  try {
    const hash = await bcrypt.hash(this.password, 10);
    this.password = hash;
    next();
  } catch (error) {
    next(error);
  }
});

// Method to compare passwords
userSchema.methods.comparePassword = async function(candidatePassword) {
  try {
    return await bcrypt.compare(candidatePassword, this.password);
  } catch (error) {
    return false;
  }
};

// Never return password in JSON
userSchema.methods.toJSON = function() {
  const obj = this.toObject();
  delete obj.password;
  return obj;
};

const User = mongoose.model('User', userSchema);

export default User;
```

---

## Session-Based Authentication

### How Sessions Work

```javascript
/**
 * Session-based authentication flow
 *
 * 1. User logs in with credentials
 * 2. Server creates session, stores session ID in cookie
 * 3. Browser sends cookie with every request
 * 4. Server validates session ID and retrieves user data
 * 5. User logs out, session is destroyed
 */

/**
 * Install: npm install express-session connect-mongo
 */

import express from 'express';
import session from 'express-session';
import MongoStore from 'connect-mongo';

const app = express();

// Configure session middleware
app.use(session({
  secret: process.env.SESSION_SECRET, // Strong random string
  resave: false, // Don't save session if unmodified
  saveUninitialized: false, // Don't create session until something stored
  store: MongoStore.create({
    mongoUrl: process.env.MONGO_URI,
    ttl: 24 * 60 * 60 // Session TTL (1 day)
  }),
  cookie: {
    secure: process.env.NODE_ENV === 'production', // HTTPS only in production
    httpOnly: true, // Prevent JavaScript access
    maxAge: 24 * 60 * 60 * 1000, // 1 day in milliseconds
    sameSite: 'strict' // CSRF protection
  }
}));
```

### Implementing Session Auth

```javascript
/**
 * Complete session authentication system
 */

import express from 'express';
import session from 'express-session';
import User from './models/User.js';

const app = express();
app.use(express.json());

// Session configuration (from above)
app.use(session({
  secret: process.env.SESSION_SECRET,
  resave: false,
  saveUninitialized: false,
  cookie: {
    secure: false, // Set to true with HTTPS
    httpOnly: true,
    maxAge: 24 * 60 * 60 * 1000
  }
}));

/**
 * Registration endpoint
 */
app.post('/api/auth/register', async (req, res) => {
  try {
    const { email, password, username } = req.body;

    // Validate input
    if (!email || !password || !username) {
      return res.status(400).json({ error: 'All fields required' });
    }

    if (password.length < 8) {
      return res.status(400).json({ error: 'Password must be at least 8 characters' });
    }

    // Check if user exists
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(409).json({ error: 'Email already registered' });
    }

    // Create user (password hashed by pre-save hook)
    const user = new User({ email, password, username });
    await user.save();

    // Create session
    req.session.userId = user.id;
    req.session.user = {
      id: user.id,
      email: user.email,
      username: user.username
    };

    res.status(201).json({
      message: 'Registration successful',
      user: req.session.user
    });
  } catch (error) {
    console.error('Registration error:', error);
    res.status(500).json({ error: 'Registration failed' });
  }
});

/**
 * Login endpoint
 */
app.post('/api/auth/login', async (req, res) => {
  try {
    const { email, password } = req.body;

    // Validate input
    if (!email || !password) {
      return res.status(400).json({ error: 'Email and password required' });
    }

    // Find user
    const user = await User.findOne({ email });
    if (!user) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    // Verify password
    const isValid = await user.comparePassword(password);
    if (!isValid) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    // Create session
    req.session.userId = user.id;
    req.session.user = {
      id: user.id,
      email: user.email,
      username: user.username
    };

    res.json({
      message: 'Login successful',
      user: req.session.user
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ error: 'Login failed' });
  }
});

/**
 * Logout endpoint
 */
app.post('/api/auth/logout', (req, res) => {
  req.session.destroy((err) => {
    if (err) {
      return res.status(500).json({ error: 'Logout failed' });
    }

    res.clearCookie('connect.sid'); // Clear session cookie
    res.json({ message: 'Logout successful' });
  });
});

/**
 * Get current user endpoint
 */
app.get('/api/auth/me', (req, res) => {
  if (!req.session.userId) {
    return res.status(401).json({ error: 'Not authenticated' });
  }

  res.json({ user: req.session.user });
});

/**
 * Authentication middleware
 */
const requireAuth = (req, res, next) => {
  if (!req.session.userId) {
    return res.status(401).json({ error: 'Authentication required' });
  }
  next();
};

/**
 * Protected route example
 */
app.get('/api/profile', requireAuth, async (req, res) => {
  try {
    const user = await User.findById(req.session.userId);
    res.json({ user });
  } catch (error) {
    res.status(500).json({ error: 'Could not fetch profile' });
  }
});
```

---

## Token-Based Authentication (JWT)

### How JWT Works

```javascript
/**
 * JWT Structure
 *
 * Format: header.payload.signature
 *
 * Example:
 * eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.
 * eyJ1c2VySWQiOiIxMjM0NSIsImVtYWlsIjoidXNlckBleGFtcGxlLmNvbSIsImlhdCI6MTYxNjI2MjQwMH0.
 * SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
 */

/**
 * Install: npm install jsonwebtoken
 */

import jwt from 'jsonwebtoken';

const jwtStructure = {
  header: {
    alg: 'HS256', // Algorithm
    typ: 'JWT'    // Type
  },
  payload: {
    userId: '12345',
    email: 'user@example.com',
    iat: 1616262400, // Issued at
    exp: 1616348800  // Expires at
  },
  signature: 'Server secret + header + payload hashed'
};

/**
 * JWT vs Sessions
 */

const comparison = {
  jwt: {
    storage: 'Client-side (localStorage, cookie)',
    stateless: true,
    scalability: 'Easy (no server storage)',
    revocation: 'Difficult (need blacklist)',
    size: 'Larger (contains data)',
    crossDomain: 'Easy'
  },
  session: {
    storage: 'Server-side (memory, Redis, database)',
    stateless: false,
    scalability: 'Harder (need shared storage)',
    revocation: 'Easy (delete session)',
    size: 'Smaller (just ID)',
    crossDomain: 'Complex'
  }
};
```

### Implementing JWT Authentication

```javascript
/**
 * Complete JWT authentication system
 */

import express from 'express';
import jwt from 'jsonwebtoken';
import User from './models/User.js';

const app = express();
app.use(express.json());

// JWT configuration
const JWT_SECRET = process.env.JWT_SECRET; // Strong random string
const JWT_EXPIRES_IN = '7d'; // Token lifetime

/**
 * Generate JWT token
 */
const generateToken = (user) => {
  const payload = {
    userId: user.id,
    email: user.email,
    username: user.username
  };

  const token = jwt.sign(payload, JWT_SECRET, {
    expiresIn: JWT_EXPIRES_IN,
    issuer: 'my-app',
    audience: 'my-app-users'
  });

  return token;
};

/**
 * Verify JWT token
 */
const verifyToken = (token) => {
  try {
    const decoded = jwt.verify(token, JWT_SECRET, {
      issuer: 'my-app',
      audience: 'my-app-users'
    });
    return decoded;
  } catch (error) {
    if (error.name === 'TokenExpiredError') {
      throw new Error('Token expired');
    }
    if (error.name === 'JsonWebTokenError') {
      throw new Error('Invalid token');
    }
    throw error;
  }
};

/**
 * Registration with JWT
 */
app.post('/api/auth/register', async (req, res) => {
  try {
    const { email, password, username } = req.body;

    // Validation
    if (!email || !password || !username) {
      return res.status(400).json({ error: 'All fields required' });
    }

    // Check existing user
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(409).json({ error: 'Email already registered' });
    }

    // Create user
    const user = new User({ email, password, username });
    await user.save();

    // Generate token
    const token = generateToken(user);

    res.status(201).json({
      message: 'Registration successful',
      token,
      user: {
        id: user.id,
        email: user.email,
        username: user.username
      }
    });
  } catch (error) {
    console.error('Registration error:', error);
    res.status(500).json({ error: 'Registration failed' });
  }
});

/**
 * Login with JWT
 */
app.post('/api/auth/login', async (req, res) => {
  try {
    const { email, password } = req.body;

    // Find user
    const user = await User.findOne({ email });
    if (!user) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    // Verify password
    const isValid = await user.comparePassword(password);
    if (!isValid) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    // Generate token
    const token = generateToken(user);

    res.json({
      message: 'Login successful',
      token,
      user: {
        id: user.id,
        email: user.email,
        username: user.username
      }
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ error: 'Login failed' });
  }
});

/**
 * JWT Authentication Middleware
 */
const authenticateJWT = async (req, res, next) => {
  try {
    // Get token from header
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({ error: 'No token provided' });
    }

    const token = authHeader.substring(7); // Remove 'Bearer '

    // Verify token
    const decoded = verifyToken(token);

    // Attach user to request
    req.user = decoded;

    // Optional: Fetch full user from database
    const user = await User.findById(decoded.userId);
    if (!user) {
      return res.status(401).json({ error: 'User not found' });
    }

    req.user.fullData = user;

    next();
  } catch (error) {
    console.error('Auth error:', error);
    res.status(401).json({ error: error.message });
  }
};

/**
 * Protected route
 */
app.get('/api/profile', authenticateJWT, (req, res) => {
  res.json({
    user: {
      id: req.user.userId,
      email: req.user.email,
      username: req.user.username
    }
  });
});

/**
 * Verify token endpoint
 */
app.get('/api/auth/verify', authenticateJWT, (req, res) => {
  res.json({
    valid: true,
    user: req.user
  });
});
```

---

## OAuth 2.0 Basics

### OAuth 2.0 Flow

```javascript
/**
 * OAuth 2.0 Authorization Code Flow
 *
 * 1. User clicks "Login with Google"
 * 2. Redirect to Google's authorization page
 * 3. User grants permission
 * 4. Google redirects back with authorization code
 * 5. Exchange code for access token
 * 6. Use token to get user info
 * 7. Create user session/JWT
 */

/**
 * Install: npm install passport passport-google-oauth20
 */

import passport from 'passport';
import { Strategy as GoogleStrategy } from 'passport-google-oauth20';
import User from './models/User.js';

/**
 * Configure Google OAuth strategy
 */
passport.use(new GoogleStrategy({
  clientID: process.env.GOOGLE_CLIENT_ID,
  clientSecret: process.env.GOOGLE_CLIENT_SECRET,
  callbackURL: 'http://localhost:3000/api/auth/google/callback'
},
async (accessToken, refreshToken, profile, done) => {
  try {
    // Check if user exists
    let user = await User.findOne({ googleId: profile.id });

    if (!user) {
      // Create new user
      user = await User.create({
        googleId: profile.id,
        email: profile.emails[0].value,
        username: profile.displayName,
        avatar: profile.photos[0]?.value,
        provider: 'google'
      });
    }

    return done(null, user);
  } catch (error) {
    return done(error, null);
  }
}));

/**
 * Serialize user for session
 */
passport.serializeUser((user, done) => {
  done(null, user.id);
});

passport.deserializeUser(async (id, done) => {
  try {
    const user = await User.findById(id);
    done(null, user);
  } catch (error) {
    done(error, null);
  }
});
```

### OAuth Routes

```javascript
/**
 * OAuth authentication routes
 */

import express from 'express';
import passport from 'passport';

const app = express();

// Initialize passport
app.use(passport.initialize());
app.use(passport.session());

/**
 * Initiate Google OAuth
 */
app.get('/api/auth/google',
  passport.authenticate('google', {
    scope: ['profile', 'email']
  })
);

/**
 * Google OAuth callback
 */
app.get('/api/auth/google/callback',
  passport.authenticate('google', { failureRedirect: '/login' }),
  (req, res) => {
    // Generate JWT for the authenticated user
    const token = generateToken(req.user);

    // Redirect to frontend with token
    res.redirect(`http://localhost:3000/auth/success?token=${token}`);
  }
);

/**
 * GitHub OAuth (similar pattern)
 */
import { Strategy as GitHubStrategy } from 'passport-github2';

passport.use(new GitHubStrategy({
  clientID: process.env.GITHUB_CLIENT_ID,
  clientSecret: process.env.GITHUB_CLIENT_SECRET,
  callbackURL: 'http://localhost:3000/api/auth/github/callback'
},
async (accessToken, refreshToken, profile, done) => {
  try {
    let user = await User.findOne({ githubId: profile.id });

    if (!user) {
      user = await User.create({
        githubId: profile.id,
        email: profile.emails?.[0]?.value,
        username: profile.username,
        avatar: profile.photos?.[0]?.value,
        provider: 'github'
      });
    }

    return done(null, user);
  } catch (error) {
    return done(error, null);
  }
}));

app.get('/api/auth/github',
  passport.authenticate('github', { scope: ['user:email'] })
);

app.get('/api/auth/github/callback',
  passport.authenticate('github', { failureRedirect: '/login' }),
  (req, res) => {
    const token = generateToken(req.user);
    res.redirect(`http://localhost:3000/auth/success?token=${token}`);
  }
);
```

---

## Refresh Tokens

### Why Refresh Tokens?

```javascript
/**
 * Problem with long-lived access tokens:
 * - If stolen, attacker has long-term access
 * - Can't easily revoke without blacklist
 *
 * Solution: Short-lived access token + long-lived refresh token
 * - Access token expires in 15 minutes
 * - Refresh token expires in 7 days
 * - Use refresh token to get new access token
 * - Can revoke refresh token server-side
 */

const tokenStrategy = {
  accessToken: {
    lifetime: '15m',
    purpose: 'Access protected resources',
    storage: 'Memory or localStorage',
    revocable: 'No (stateless)'
  },
  refreshToken: {
    lifetime: '7d',
    purpose: 'Get new access token',
    storage: 'httpOnly cookie or database',
    revocable: 'Yes (stored server-side)'
  }
};
```

### Implementing Refresh Tokens

```javascript
/**
 * Complete refresh token implementation
 */

import jwt from 'jsonwebtoken';
import crypto from 'crypto';
import RefreshToken from './models/RefreshToken.js';

const ACCESS_TOKEN_SECRET = process.env.ACCESS_TOKEN_SECRET;
const REFRESH_TOKEN_SECRET = process.env.REFRESH_TOKEN_SECRET;

/**
 * RefreshToken Model (Mongoose)
 */
const refreshTokenSchema = new mongoose.Schema({
  token: { type: String, required: true, unique: true },
  userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  expiresAt: { type: Date, required: true },
  createdByIp: String,
  revokedAt: Date,
  revokedByIp: String,
  replacedByToken: String
}, { timestamps: true });

/**
 * Generate token pair
 */
const generateTokenPair = async (user, ipAddress) => {
  // Generate access token (short-lived)
  const accessToken = jwt.sign(
    {
      userId: user.id,
      email: user.email,
      username: user.username
    },
    ACCESS_TOKEN_SECRET,
    { expiresIn: '15m' }
  );

  // Generate refresh token (long-lived)
  const refreshToken = crypto.randomBytes(40).toString('hex');

  // Store refresh token in database
  await RefreshToken.create({
    token: refreshToken,
    userId: user.id,
    expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days
    createdByIp: ipAddress
  });

  return { accessToken, refreshToken };
};

/**
 * Login with refresh token
 */
app.post('/api/auth/login', async (req, res) => {
  try {
    const { email, password } = req.body;

    // Authenticate user
    const user = await User.findOne({ email });
    if (!user || !await user.comparePassword(password)) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    // Generate tokens
    const { accessToken, refreshToken } = await generateTokenPair(
      user,
      req.ip
    );

    // Set refresh token in httpOnly cookie
    res.cookie('refreshToken', refreshToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
      maxAge: 7 * 24 * 60 * 60 * 1000 // 7 days
    });

    res.json({
      accessToken,
      user: {
        id: user.id,
        email: user.email,
        username: user.username
      }
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ error: 'Login failed' });
  }
});

/**
 * Refresh access token
 */
app.post('/api/auth/refresh', async (req, res) => {
  try {
    const { refreshToken } = req.cookies;

    if (!refreshToken) {
      return res.status(401).json({ error: 'Refresh token required' });
    }

    // Find refresh token in database
    const storedToken = await RefreshToken.findOne({ token: refreshToken });

    if (!storedToken) {
      return res.status(401).json({ error: 'Invalid refresh token' });
    }

    // Check if expired
    if (storedToken.expiresAt < new Date()) {
      return res.status(401).json({ error: 'Refresh token expired' });
    }

    // Check if revoked
    if (storedToken.revokedAt) {
      return res.status(401).json({ error: 'Refresh token revoked' });
    }

    // Get user
    const user = await User.findById(storedToken.userId);
    if (!user) {
      return res.status(401).json({ error: 'User not found' });
    }

    // Generate new token pair
    const { accessToken, refreshToken: newRefreshToken } =
      await generateTokenPair(user, req.ip);

    // Revoke old refresh token
    storedToken.revokedAt = new Date();
    storedToken.revokedByIp = req.ip;
    storedToken.replacedByToken = newRefreshToken;
    await storedToken.save();

    // Set new refresh token in cookie
    res.cookie('refreshToken', newRefreshToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
      maxAge: 7 * 24 * 60 * 60 * 1000
    });

    res.json({ accessToken });
  } catch (error) {
    console.error('Refresh error:', error);
    res.status(500).json({ error: 'Could not refresh token' });
  }
});

/**
 * Logout (revoke refresh token)
 */
app.post('/api/auth/logout', async (req, res) => {
  try {
    const { refreshToken } = req.cookies;

    if (refreshToken) {
      await RefreshToken.updateOne(
        { token: refreshToken },
        {
          revokedAt: new Date(),
          revokedByIp: req.ip
        }
      );
    }

    res.clearCookie('refreshToken');
    res.json({ message: 'Logout successful' });
  } catch (error) {
    console.error('Logout error:', error);
    res.status(500).json({ error: 'Logout failed' });
  }
});

/**
 * Revoke all refresh tokens for a user
 */
app.post('/api/auth/revoke-all', authenticateJWT, async (req, res) => {
  try {
    await RefreshToken.updateMany(
      {
        userId: req.user.userId,
        revokedAt: null
      },
      {
        revokedAt: new Date(),
        revokedByIp: req.ip
      }
    );

    res.json({ message: 'All tokens revoked' });
  } catch (error) {
    res.status(500).json({ error: 'Could not revoke tokens' });
  }
});
```

---

## Role-Based Access Control (RBAC)

### RBAC Concepts

```javascript
/**
 * RBAC Structure
 */

const rbacStructure = {
  roles: ['user', 'moderator', 'admin', 'superadmin'],

  permissions: {
    user: ['read:own', 'write:own', 'delete:own'],
    moderator: ['read:any', 'write:any', 'delete:any', 'ban:users'],
    admin: ['*'], // All permissions
    superadmin: ['*', 'manage:admins']
  },

  hierarchy: {
    superadmin: ['admin', 'moderator', 'user'],
    admin: ['moderator', 'user'],
    moderator: ['user'],
    user: []
  }
};
```

### Implementing RBAC

```javascript
/**
 * User model with roles
 */

const userSchema = new mongoose.Schema({
  email: String,
  password: String,
  username: String,
  roles: {
    type: [String],
    enum: ['user', 'moderator', 'admin', 'superadmin'],
    default: ['user']
  },
  permissions: {
    type: [String],
    default: []
  }
}, { timestamps: true });

// Check if user has role
userSchema.methods.hasRole = function(role) {
  return this.roles.includes(role);
};

// Check if user has permission
userSchema.methods.hasPermission = function(permission) {
  // Admins have all permissions
  if (this.hasRole('admin') || this.hasRole('superadmin')) {
    return true;
  }

  return this.permissions.includes(permission);
};

/**
 * Authorization middleware
 */

// Require specific role
const requireRole = (...allowedRoles) => {
  return (req, res, next) => {
    if (!req.user) {
      return res.status(401).json({ error: 'Authentication required' });
    }

    const hasRole = allowedRoles.some(role =>
      req.user.fullData.hasRole(role)
    );

    if (!hasRole) {
      return res.status(403).json({
        error: 'Insufficient permissions',
        required: allowedRoles
      });
    }

    next();
  };
};

// Require specific permission
const requirePermission = (...requiredPermissions) => {
  return (req, res, next) => {
    if (!req.user) {
      return res.status(401).json({ error: 'Authentication required' });
    }

    const hasPermission = requiredPermissions.every(permission =>
      req.user.fullData.hasPermission(permission)
    );

    if (!hasPermission) {
      return res.status(403).json({
        error: 'Insufficient permissions',
        required: requiredPermissions
      });
    }

    next();
  };
};

// Check resource ownership
const requireOwnership = (resourceModel, resourceParam = 'id') => {
  return async (req, res, next) => {
    try {
      const resourceId = req.params[resourceParam];
      const resource = await resourceModel.findById(resourceId);

      if (!resource) {
        return res.status(404).json({ error: 'Resource not found' });
      }

      // Admins can access any resource
      if (req.user.fullData.hasRole('admin')) {
        req.resource = resource;
        return next();
      }

      // Check ownership
      const isOwner = resource.userId?.toString() === req.user.userId ||
                     resource.authorId?.toString() === req.user.userId;

      if (!isOwner) {
        return res.status(403).json({ error: 'Not authorized' });
      }

      req.resource = resource;
      next();
    } catch (error) {
      console.error('Ownership check error:', error);
      res.status(500).json({ error: 'Authorization failed' });
    }
  };
};

/**
 * Protected routes with RBAC
 */

// Only admins can access
app.get('/api/admin/users',
  authenticateJWT,
  requireRole('admin', 'superadmin'),
  async (req, res) => {
    const users = await User.find();
    res.json({ users });
  }
);

// Only moderators and admins
app.delete('/api/posts/:id',
  authenticateJWT,
  requireRole('moderator', 'admin'),
  async (req, res) => {
    await Post.findByIdAndDelete(req.params.id);
    res.json({ message: 'Post deleted' });
  }
);

// User can only edit their own posts (or admin can edit any)
app.put('/api/posts/:id',
  authenticateJWT,
  requireOwnership(Post),
  async (req, res) => {
    const post = req.resource; // Set by requireOwnership
    post.title = req.body.title;
    post.content = req.body.content;
    await post.save();
    res.json({ post });
  }
);

// Require specific permission
app.post('/api/admin/ban-user/:userId',
  authenticateJWT,
  requirePermission('ban:users'),
  async (req, res) => {
    const user = await User.findById(req.params.userId);
    user.isBanned = true;
    await user.save();
    res.json({ message: 'User banned' });
  }
);
```

---

## Security Best Practices

### Comprehensive Security Checklist

```javascript
/**
 * Authentication Security Best Practices
 */

const securityBestPractices = {
  passwords: [
    'Minimum 8 characters (12+ recommended)',
    'Require mix of uppercase, lowercase, numbers, symbols',
    'Check against common password lists',
    'Use bcrypt with salt rounds 10-12',
    'Never log passwords',
    'Implement password reset with time-limited tokens'
  ],

  tokens: [
    'Use strong random secrets (32+ characters)',
    'Store secrets in environment variables',
    'Short expiration for access tokens (15-30 min)',
    'Longer expiration for refresh tokens (7-30 days)',
    'Implement token rotation',
    'Use httpOnly cookies for refresh tokens'
  ],

  sessions: [
    'Use secure random session IDs',
    'Set httpOnly, secure, sameSite flags',
    'Implement session timeout',
    'Regenerate session ID after login',
    'Clear sessions on logout',
    'Use Redis/database for session storage'
  ],

  network: [
    'Always use HTTPS in production',
    'Implement rate limiting',
    'Use CORS properly',
    'Set security headers (Helmet.js)',
    'Validate all input',
    'Sanitize output'
  ],

  general: [
    'Implement account lockout after failed attempts',
    'Log authentication events',
    'Use multi-factor authentication (MFA)',
    'Regular security audits',
    'Keep dependencies updated',
    'Implement CSRF protection'
  ]
};
```

### Security Implementation

```javascript
/**
 * Comprehensive security implementation
 */

import rateLimit from 'express-rate-limit';
import helmet from 'helmet';
import cors from 'cors';
import validator from 'validator';

const app = express();

// Security headers
app.use(helmet());

// CORS configuration
app.use(cors({
  origin: process.env.ALLOWED_ORIGINS.split(','),
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE'],
  allowedHeaders: ['Content-Type', 'Authorization']
}));

// Rate limiting
const loginLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // 5 attempts
  message: 'Too many login attempts, please try again later',
  standardHeaders: true,
  legacyHeaders: false,
});

app.use('/api/auth/login', loginLimiter);

// Global rate limit
const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 100
});

app.use('/api/', apiLimiter);

/**
 * Input validation
 */
const validateRegistration = (req, res, next) => {
  const { email, password, username } = req.body;

  const errors = [];

  // Validate email
  if (!email || !validator.isEmail(email)) {
    errors.push('Valid email required');
  }

  // Validate password
  if (!password || password.length < 8) {
    errors.push('Password must be at least 8 characters');
  }

  if (password && !validator.isStrongPassword(password, {
    minLength: 8,
    minLowercase: 1,
    minUppercase: 1,
    minNumbers: 1,
    minSymbols: 1
  })) {
    errors.push('Password must contain uppercase, lowercase, number, and symbol');
  }

  // Validate username
  if (!username || !validator.isAlphanumeric(username)) {
    errors.push('Username must be alphanumeric');
  }

  if (username && (username.length < 3 || username.length > 30)) {
    errors.push('Username must be 3-30 characters');
  }

  if (errors.length > 0) {
    return res.status(400).json({ errors });
  }

  next();
};

app.post('/api/auth/register', validateRegistration, async (req, res) => {
  // Registration logic
});

/**
 * Account lockout
 */
const loginAttemptSchema = new mongoose.Schema({
  email: { type: String, required: true },
  attempts: { type: Number, default: 0 },
  lockedUntil: Date
}, { timestamps: true });

const LoginAttempt = mongoose.model('LoginAttempt', loginAttemptSchema);

const checkAccountLockout = async (req, res, next) => {
  const { email } = req.body;

  const attempt = await LoginAttempt.findOne({ email });

  if (attempt && attempt.lockedUntil && attempt.lockedUntil > new Date()) {
    const minutes = Math.ceil((attempt.lockedUntil - new Date()) / 1000 / 60);
    return res.status(429).json({
      error: `Account locked. Try again in ${minutes} minutes`
    });
  }

  next();
};

const handleFailedLogin = async (email) => {
  let attempt = await LoginAttempt.findOne({ email });

  if (!attempt) {
    attempt = new LoginAttempt({ email, attempts: 1 });
  } else {
    attempt.attempts += 1;
  }

  // Lock account after 5 failed attempts
  if (attempt.attempts >= 5) {
    attempt.lockedUntil = new Date(Date.now() + 30 * 60 * 1000); // 30 minutes
  }

  await attempt.save();
};

const handleSuccessfulLogin = async (email) => {
  await LoginAttempt.deleteOne({ email });
};

app.post('/api/auth/login',
  checkAccountLockout,
  async (req, res) => {
    try {
      const { email, password } = req.body;

      const user = await User.findOne({ email });
      if (!user || !await user.comparePassword(password)) {
        await handleFailedLogin(email);
        return res.status(401).json({ error: 'Invalid credentials' });
      }

      await handleSuccessfulLogin(email);

      const token = generateToken(user);
      res.json({ token, user });
    } catch (error) {
      res.status(500).json({ error: 'Login failed' });
    }
  }
);
```

---

## Worked Examples

### Example 1: Complete Authentication System

```javascript
/**
 * Worked Example 1: Full-featured auth system
 *
 * Features:
 * - Registration with validation
 * - Login with JWT
 * - Refresh tokens
 * - Password reset
 * - Email verification
 */

import express from 'express';
import jwt from 'jsonwebtoken';
import crypto from 'crypto';
import nodemailer from 'nodemailer';
import User from './models/User.js';
import RefreshToken from './models/RefreshToken.js';

const app = express();
app.use(express.json());

// Email transporter
const transporter = nodemailer.createTransporter({
  host: process.env.SMTP_HOST,
  port: process.env.SMTP_PORT,
  auth: {
    user: process.env.SMTP_USER,
    pass: process.env.SMTP_PASS
  }
});

/**
 * Registration with email verification
 */
app.post('/api/auth/register', async (req, res) => {
  try {
    const { email, password, username } = req.body;

    // Check existing user
    const existing = await User.findOne({ email });
    if (existing) {
      return res.status(409).json({ error: 'Email already registered' });
    }

    // Generate verification token
    const verificationToken = crypto.randomBytes(32).toString('hex');

    // Create user
    const user = new User({
      email,
      password,
      username,
      verificationToken,
      isVerified: false
    });

    await user.save();

    // Send verification email
    const verificationUrl = `${process.env.APP_URL}/verify-email?token=${verificationToken}`;

    await transporter.sendMail({
      from: process.env.EMAIL_FROM,
      to: email,
      subject: 'Verify your email',
      html: `
        <h1>Welcome to Our App!</h1>
        <p>Please verify your email by clicking the link below:</p>
        <a href="${verificationUrl}">Verify Email</a>
      `
    });

    res.status(201).json({
      message: 'Registration successful. Please check your email to verify your account.'
    });
  } catch (error) {
    console.error('Registration error:', error);
    res.status(500).json({ error: 'Registration failed' });
  }
});

/**
 * Email verification
 */
app.post('/api/auth/verify-email', async (req, res) => {
  try {
    const { token } = req.body;

    const user = await User.findOne({ verificationToken: token });

    if (!user) {
      return res.status(400).json({ error: 'Invalid verification token' });
    }

    user.isVerified = true;
    user.verificationToken = undefined;
    await user.save();

    res.json({ message: 'Email verified successfully' });
  } catch (error) {
    res.status(500).json({ error: 'Verification failed' });
  }
});

/**
 * Password reset request
 */
app.post('/api/auth/forgot-password', async (req, res) => {
  try {
    const { email } = req.body;

    const user = await User.findOne({ email });

    if (!user) {
      // Don't reveal if user exists
      return res.json({ message: 'If email exists, reset link sent' });
    }

    // Generate reset token
    const resetToken = crypto.randomBytes(32).toString('hex');
    const resetTokenExpiry = new Date(Date.now() + 60 * 60 * 1000); // 1 hour

    user.resetToken = resetToken;
    user.resetTokenExpiry = resetTokenExpiry;
    await user.save();

    // Send reset email
    const resetUrl = `${process.env.APP_URL}/reset-password?token=${resetToken}`;

    await transporter.sendMail({
      from: process.env.EMAIL_FROM,
      to: email,
      subject: 'Password Reset Request',
      html: `
        <h1>Password Reset</h1>
        <p>Click the link below to reset your password:</p>
        <a href="${resetUrl}">Reset Password</a>
        <p>This link expires in 1 hour.</p>
      `
    });

    res.json({ message: 'If email exists, reset link sent' });
  } catch (error) {
    res.status(500).json({ error: 'Password reset request failed' });
  }
});

/**
 * Reset password
 */
app.post('/api/auth/reset-password', async (req, res) => {
  try {
    const { token, newPassword } = req.body;

    const user = await User.findOne({
      resetToken: token,
      resetTokenExpiry: { $gt: new Date() }
    });

    if (!user) {
      return res.status(400).json({ error: 'Invalid or expired reset token' });
    }

    // Update password
    user.password = newPassword;
    user.resetToken = undefined;
    user.resetTokenExpiry = undefined;
    await user.save();

    res.json({ message: 'Password reset successful' });
  } catch (error) {
    res.status(500).json({ error: 'Password reset failed' });
  }
});
```

### Example 2: Multi-Tenant RBAC System

```javascript
/**
 * Worked Example 2: Multi-tenant application with RBAC
 *
 * Features:
 * - Organization-based multi-tenancy
 * - Role-based permissions per organization
 * - Resource isolation
 */

// Organization Model
const organizationSchema = new mongoose.Schema({
  name: String,
  slug: { type: String, unique: true },
  plan: {
    type: String,
    enum: ['free', 'pro', 'enterprise'],
    default: 'free'
  }
}, { timestamps: true });

const Organization = mongoose.model('Organization', organizationSchema);

// User-Organization relationship
const membershipSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  organizationId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Organization',
    required: true
  },
  role: {
    type: String,
    enum: ['owner', 'admin', 'member', 'viewer'],
    default: 'member'
  },
  permissions: [String]
}, { timestamps: true });

membershipSchema.index({ userId: 1, organizationId: 1 }, { unique: true });

const Membership = mongoose.model('Membership', membershipSchema);

/**
 * Middleware to load organization context
 */
const loadOrganization = async (req, res, next) => {
  try {
    const orgSlug = req.headers['x-organization'] || req.params.orgSlug;

    if (!orgSlug) {
      return res.status(400).json({ error: 'Organization required' });
    }

    const org = await Organization.findOne({ slug: orgSlug });

    if (!org) {
      return res.status(404).json({ error: 'Organization not found' });
    }

    req.organization = org;
    next();
  } catch (error) {
    res.status(500).json({ error: 'Could not load organization' });
  }
};

/**
 * Middleware to check organization membership
 */
const requireOrganizationRole = (...allowedRoles) => {
  return async (req, res, next) => {
    try {
      const membership = await Membership.findOne({
        userId: req.user.userId,
        organizationId: req.organization.id
      });

      if (!membership) {
        return res.status(403).json({ error: 'Not a member of this organization' });
      }

      if (!allowedRoles.includes(membership.role)) {
        return res.status(403).json({
          error: 'Insufficient permissions',
          required: allowedRoles,
          current: membership.role
        });
      }

      req.membership = membership;
      next();
    } catch (error) {
      res.status(500).json({ error: 'Authorization failed' });
    }
  };
};

/**
 * Organization routes
 */

// Create organization
app.post('/api/organizations',
  authenticateJWT,
  async (req, res) => {
    try {
      const { name, slug } = req.body;

      const org = await Organization.create({ name, slug });

      // Make creator the owner
      await Membership.create({
        userId: req.user.userId,
        organizationId: org.id,
        role: 'owner'
      });

      res.status(201).json({ organization: org });
    } catch (error) {
      res.status(500).json({ error: 'Could not create organization' });
    }
  }
);

// Get organization members
app.get('/api/organizations/:orgSlug/members',
  authenticateJWT,
  loadOrganization,
  requireOrganizationRole('owner', 'admin', 'member'),
  async (req, res) => {
    try {
      const members = await Membership.find({
        organizationId: req.organization.id
      }).populate('userId', 'username email');

      res.json({ members });
    } catch (error) {
      res.status(500).json({ error: 'Could not fetch members' });
    }
  }
);

// Add member to organization
app.post('/api/organizations/:orgSlug/members',
  authenticateJWT,
  loadOrganization,
  requireOrganizationRole('owner', 'admin'),
  async (req, res) => {
    try {
      const { email, role } = req.body;

      const user = await User.findOne({ email });

      if (!user) {
        return res.status(404).json({ error: 'User not found' });
      }

      const membership = await Membership.create({
        userId: user.id,
        organizationId: req.organization.id,
        role: role || 'member'
      });

      res.status(201).json({ membership });
    } catch (error) {
      if (error.code === 11000) {
        return res.status(409).json({ error: 'User already a member' });
      }
      res.status(500).json({ error: 'Could not add member' });
    }
  }
);

// Remove member (only owners)
app.delete('/api/organizations/:orgSlug/members/:userId',
  authenticateJWT,
  loadOrganization,
  requireOrganizationRole('owner'),
  async (req, res) => {
    try {
      await Membership.deleteOne({
        userId: req.params.userId,
        organizationId: req.organization.id
      });

      res.json({ message: 'Member removed' });
    } catch (error) {
      res.status(500).json({ error: 'Could not remove member' });
    }
  }
);
```

### Example 3: API Key Authentication

```javascript
/**
 * Worked Example 3: API key authentication for external integrations
 *
 * Features:
 * - Generate API keys
 * - Rate limiting per key
 * - Key rotation
 * - Usage tracking
 */

// API Key Model
const apiKeySchema = new mongoose.Schema({
  key: {
    type: String,
    required: true,
    unique: true
  },
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  name: String,
  scopes: [String], // Permissions this key has
  rateLimit: {
    type: Number,
    default: 1000 // Requests per hour
  },
  lastUsed: Date,
  expiresAt: Date,
  isActive: {
    type: Boolean,
    default: true
  },
  requestCount: {
    type: Number,
    default: 0
  }
}, { timestamps: true });

const ApiKey = mongoose.model('ApiKey', apiKeySchema);

/**
 * Generate API key
 */
const generateApiKey = () => {
  return 'sk_' + crypto.randomBytes(32).toString('hex');
};

/**
 * Create API key
 */
app.post('/api/api-keys',
  authenticateJWT,
  async (req, res) => {
    try {
      const { name, scopes, expiresIn } = req.body;

      const key = generateApiKey();
      const expiresAt = expiresIn ?
        new Date(Date.now() + expiresIn * 24 * 60 * 60 * 1000) :
        null;

      const apiKey = await ApiKey.create({
        key,
        userId: req.user.userId,
        name,
        scopes: scopes || [],
        expiresAt
      });

      res.status(201).json({
        message: 'API key created',
        key, // Only shown once!
        id: apiKey.id,
        name: apiKey.name
      });
    } catch (error) {
      res.status(500).json({ error: 'Could not create API key' });
    }
  }
);

/**
 * List API keys (without showing actual keys)
 */
app.get('/api/api-keys',
  authenticateJWT,
  async (req, res) => {
    try {
      const keys = await ApiKey.find({
        userId: req.user.userId
      }).select('-key'); // Don't return actual key

      res.json({ keys });
    } catch (error) {
      res.status(500).json({ error: 'Could not fetch API keys' });
    }
  }
);

/**
 * API key authentication middleware
 */
const authenticateApiKey = async (req, res, next) => {
  try {
    const apiKey = req.headers['x-api-key'];

    if (!apiKey) {
      return res.status(401).json({ error: 'API key required' });
    }

    const keyDoc = await ApiKey.findOne({ key: apiKey, isActive: true });

    if (!keyDoc) {
      return res.status(401).json({ error: 'Invalid API key' });
    }

    // Check expiration
    if (keyDoc.expiresAt && keyDoc.expiresAt < new Date()) {
      return res.status(401).json({ error: 'API key expired' });
    }

    // Check rate limit
    const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);
    const recentRequests = await ApiKeyRequest.countDocuments({
      apiKeyId: keyDoc.id,
      createdAt: { $gte: oneHourAgo }
    });

    if (recentRequests >= keyDoc.rateLimit) {
      return res.status(429).json({
        error: 'Rate limit exceeded',
        limit: keyDoc.rateLimit,
        reset: new Date(Date.now() + 60 * 60 * 1000)
      });
    }

    // Track usage
    keyDoc.lastUsed = new Date();
    keyDoc.requestCount += 1;
    await keyDoc.save();

    // Log request
    await ApiKeyRequest.create({
      apiKeyId: keyDoc.id,
      endpoint: req.path,
      method: req.method,
      ipAddress: req.ip
    });

    req.apiKey = keyDoc;
    next();
  } catch (error) {
    console.error('API key auth error:', error);
    res.status(500).json({ error: 'Authentication failed' });
  }
};

/**
 * Public API endpoint
 */
app.get('/api/public/data',
  authenticateApiKey,
  async (req, res) => {
    try {
      // Check scopes
      if (!req.apiKey.scopes.includes('read:data')) {
        return res.status(403).json({ error: 'Insufficient scopes' });
      }

      const data = await Data.find().limit(100);
      res.json({ data });
    } catch (error) {
      res.status(500).json({ error: 'Could not fetch data' });
    }
  }
);
```

---

## Exercises

### Exercise 1: Implement Registration (Easy)

**Problem:** Create a user registration endpoint with proper validation and password hashing.

```javascript
/**
 * Requirements:
 * - Validate email format
 * - Enforce password strength (min 8 chars, mixed case, number, symbol)
 * - Hash password with bcrypt
 * - Check for duplicate email
 * - Return JWT token
 */

app.post('/api/auth/register', async (req, res) => {
  // Your implementation here
});
```

**Solution:** See `solutions/exercise1_auth.js`

---

### Exercise 2: Password Reset Flow (Medium)

**Problem:** Implement complete password reset functionality.

```javascript
/**
 * Requirements:
 * - Generate secure reset token
 * - Store token with expiration (1 hour)
 * - Validate token before reset
 * - Update password
 * - Invalidate token after use
 */

app.post('/api/auth/forgot-password', async (req, res) => {
  // Your implementation
});

app.post('/api/auth/reset-password', async (req, res) => {
  // Your implementation
});
```

**Solution:** See `solutions/exercise2_auth.js`

---

### Exercise 3: Permission System (Medium)

**Problem:** Create a flexible permission system.

```javascript
/**
 * Requirements:
 * - Define permissions (create:post, edit:post, delete:post, etc.)
 * - Assign permissions to roles
 * - Check permissions in middleware
 * - Support permission inheritance
 */

const requirePermissions = (...permissions) => {
  // Your implementation
};
```

**Solution:** See `solutions/exercise3_auth.js`

---

### Exercise 4: Two-Factor Authentication (Hard)

**Problem:** Implement TOTP-based 2FA.

```javascript
/**
 * Requirements:
 * - Generate QR code for setup
 * - Verify TOTP codes
 * - Backup codes
 * - Require 2FA for login
 */

import speakeasy from 'speakeasy';
import QRCode from 'qrcode';

app.post('/api/auth/2fa/setup', authenticateJWT, async (req, res) => {
  // Your implementation
});

app.post('/api/auth/2fa/verify', authenticateJWT, async (req, res) => {
  // Your implementation
});
```

**Solution:** See `solutions/exercise4_auth.js`

---

### Exercise 5: Social Login Integration (Hard)

**Problem:** Implement login with multiple OAuth providers.

```javascript
/**
 * Requirements:
 * - Support Google, GitHub, and Microsoft
 * - Link social accounts to existing users
 * - Handle account creation on first login
 * - Merge accounts
 */

// Your implementation
```

**Solution:** See `solutions/exercise5_auth.js`

---

## Testing & Verification

```javascript
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import request from 'supertest';
import app from '../app.js';
import User from '../models/User.js';
import mongoose from 'mongoose';

describe('Authentication System', () => {
  beforeAll(async () => {
    await mongoose.connect(process.env.TEST_MONGO_URI);
  });

  afterAll(async () => {
    await User.deleteMany({});
    await mongoose.connection.close();
  });

  describe('POST /api/auth/register', () => {
    it('should register a new user', async () => {
      const res = await request(app)
        .post('/api/auth/register')
        .send({
          email: 'test@example.com',
          password: 'SecurePass123!',
          username: 'testuser'
        });

      expect(res.status).toBe(201);
      expect(res.body).toHaveProperty('token');
      expect(res.body.user).toHaveProperty('email', 'test@example.com');
    });

    it('should reject weak password', async () => {
      const res = await request(app)
        .post('/api/auth/register')
        .send({
          email: 'test2@example.com',
          password: 'weak',
          username: 'testuser2'
        });

      expect(res.status).toBe(400);
    });

    it('should reject duplicate email', async () => {
      const res = await request(app)
        .post('/api/auth/register')
        .send({
          email: 'test@example.com',
          password: 'SecurePass123!',
          username: 'testuser3'
        });

      expect(res.status).toBe(409);
    });
  });

  describe('POST /api/auth/login', () => {
    it('should login with valid credentials', async () => {
      const res = await request(app)
        .post('/api/auth/login')
        .send({
          email: 'test@example.com',
          password: 'SecurePass123!'
        });

      expect(res.status).toBe(200);
      expect(res.body).toHaveProperty('token');
    });

    it('should reject invalid password', async () => {
      const res = await request(app)
        .post('/api/auth/login')
        .send({
          email: 'test@example.com',
          password: 'WrongPassword'
        });

      expect(res.status).toBe(401);
    });
  });

  describe('Protected Routes', () => {
    let token;

    beforeAll(async () => {
      const res = await request(app)
        .post('/api/auth/login')
        .send({
          email: 'test@example.com',
          password: 'SecurePass123!'
        });

      token = res.body.token;
    });

    it('should access protected route with valid token', async () => {
      const res = await request(app)
        .get('/api/profile')
        .set('Authorization', `Bearer ${token}`);

      expect(res.status).toBe(200);
    });

    it('should reject request without token', async () => {
      const res = await request(app)
        .get('/api/profile');

      expect(res.status).toBe(401);
    });

    it('should reject invalid token', async () => {
      const res = await request(app)
        .get('/api/profile')
        .set('Authorization', 'Bearer invalid-token');

      expect(res.status).toBe(401);
    });
  });
});
```

---

## Best Practices

1. **Always hash passwords** with bcrypt or argon2
2. **Use HTTPS** in production for all auth endpoints
3. **Implement rate limiting** to prevent brute force attacks
4. **Validate all input** before processing
5. **Use short-lived access tokens** (15-30 minutes)
6. **Implement refresh tokens** for long sessions
7. **Store tokens securely** (httpOnly cookies for refresh tokens)
8. **Never log sensitive data** (passwords, tokens)
9. **Implement account lockout** after failed attempts
10. **Use prepared statements** to prevent SQL injection

---

## Common Pitfalls

1. **Storing passwords in plain text** - Always hash!
2. **Weak JWT secrets** - Use long random strings
3. **No token expiration** - Tokens should expire
4. **Exposing user existence** - Don't reveal if email exists
5. **Missing CORS configuration** - Set proper origins
6. **No input validation** - Validate everything
7. **Hardcoded secrets** - Use environment variables
8. **No rate limiting** - Allows brute force attacks
9. **Mixing authentication and authorization** - Keep them separate
10. **Not regenerating session IDs** after login

---

## Performance Considerations

```javascript
/**
 * Performance optimizations
 */

// 1. Cache user data to avoid database lookups
import Redis from 'ioredis';
const redis = new Redis();

const getUserFromCache = async (userId) => {
  const cached = await redis.get(`user:${userId}`);
  if (cached) return JSON.parse(cached);

  const user = await User.findById(userId);
  await redis.setex(`user:${userId}`, 3600, JSON.stringify(user));
  return user;
};

// 2. Use Redis for session storage
import RedisStore from 'connect-redis';

app.use(session({
  store: new RedisStore({ client: redis }),
  // ... other options
}));

// 3. Implement token blacklist with Redis
const blacklistToken = async (token) => {
  const decoded = jwt.decode(token);
  const expiresIn = decoded.exp - Math.floor(Date.now() / 1000);
  await redis.setex(`blacklist:${token}`, expiresIn, '1');
};

const isTokenBlacklisted = async (token) => {
  const result = await redis.get(`blacklist:${token}`);
  return result === '1';
};

// 4. Batch permission checks
const checkMultiplePermissions = async (userId, permissions) => {
  const user = await User.findById(userId).select('roles permissions');
  return permissions.every(perm => user.hasPermission(perm));
};
```

---

## Summary & Next Steps

### Key Takeaways

- Authentication verifies identity, authorization controls access
- Always hash passwords with bcrypt (10+ salt rounds)
- Use JWT for stateless auth, sessions for stateful
- Implement refresh tokens for better security
- RBAC provides flexible permission management
- Security is critical - follow best practices

### Related Topics

- [Database Integration](./36.Database_Integration.md)
- [Security Best Practices](./41.Security_Best_Practices.md)
- [Testing Backend Applications](./39.Testing_Backend_Applications.md)

### Further Reading

- [OWASP Authentication Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html)
- [JWT.io](https://jwt.io/)
- [OAuth 2.0 Simplified](https://aaronparecki.com/oauth-2-simplified/)

---

## References

- OWASP Top 10: https://owasp.org/www-project-top-ten/
- bcrypt npm: https://www.npmjs.com/package/bcrypt
- jsonwebtoken: https://www.npmjs.com/package/jsonwebtoken
- Passport.js: http://www.passportjs.org/
- express-session: https://www.npmjs.com/package/express-session

---

**Next Lesson:** [WebSockets and Real-Time Communication](./38.WebSockets_And_Real_Time.md)
