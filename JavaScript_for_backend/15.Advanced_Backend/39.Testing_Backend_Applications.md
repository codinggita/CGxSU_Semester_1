# Testing Backend Applications

**Difficulty:** Intermediate to Advanced
**Estimated Time:** 90-120 minutes
**Prerequisites:** Node.js, Express.js, async/await, REST APIs
**Target:** Node.js 18+ LTS, Vitest 1+, Supertest 6+

---

## Learning Objectives

By the end of this lesson, you will be able to:

1. Understand different types of backend testing (unit, integration, E2E)
2. Write unit tests with Vitest for Node.js applications
3. Test REST APIs using Supertest
4. Implement integration tests for database operations
5. Use mocking and stubbing effectively
6. Measure and improve test coverage
7. Apply Test-Driven Development (TDD) workflow
8. Set up E2E testing for complete user flows
9. Configure CI/CD pipelines for automated testing
10. Follow testing best practices for production-ready code

---

## Table of Contents

1. [Introduction](#introduction)
2. [Testing Pyramid](#testing-pyramid)
3. [Unit Testing with Vitest](#unit-testing-with-vitest)
4. [Integration Testing](#integration-testing)
5. [API Testing with Supertest](#api-testing-with-supertest)
6. [Mocking and Stubs](#mocking-and-stubs)
7. [Test Coverage](#test-coverage)
8. [Test-Driven Development](#test-driven-development)
9. [E2E Testing](#e2e-testing)
10. [CI/CD for Testing](#cicd-for-testing)
11. [Worked Examples](#worked-examples)
12. [Exercises](#exercises)
13. [Testing & Verification](#testing--verification)
14. [Best Practices](#best-practices)
15. [Common Pitfalls](#common-pitfalls)
16. [Performance Considerations](#performance-considerations)
17. [Summary & Next Steps](#summary--next-steps)
18. [References](#references)

---

## Introduction

Testing is crucial for building reliable, maintainable backend applications. Proper testing catches bugs early, enables confident refactoring, and serves as living documentation.

**Why Testing Matters:**

- **Reliability:** Catch bugs before production
- **Confidence:** Refactor without fear of breaking things
- **Documentation:** Tests show how code should be used
- **Quality:** Maintain high code standards
- **Speed:** Faster development in the long run

**Real-World Applications:**

- **API Reliability:** Ensure endpoints work correctly
- **Data Integrity:** Verify database operations
- **Business Logic:** Test complex calculations
- **Integration:** Confirm third-party services work
- **Regression Prevention:** Ensure old bugs stay fixed

---

## Testing Pyramid

### Understanding the Pyramid

```javascript
/**
 * Testing Pyramid Structure
 *
 *           /\
 *          /E2E\        <- Few tests, slow, expensive
 *         /------\
 *        /  Integ \     <- Some tests, medium speed
 *       /----------\
 *      /    Unit    \   <- Many tests, fast, cheap
 *     /--------------\
 */

const testingPyramid = {
  unit: {
    percentage: '70%',
    speed: 'Very fast (milliseconds)',
    scope: 'Single function/class',
    dependencies: 'Mocked',
    cost: 'Low',
    examples: [
      'Test a utility function',
      'Test a class method',
      'Test business logic'
    ]
  },

  integration: {
    percentage: '20%',
    speed: 'Medium (seconds)',
    scope: 'Multiple components',
    dependencies: 'Real (database, etc.)',
    cost: 'Medium',
    examples: [
      'Test API endpoint with database',
      'Test service with repository',
      'Test authentication flow'
    ]
  },

  e2e: {
    percentage: '10%',
    speed: 'Slow (seconds to minutes)',
    scope: 'Complete user flow',
    dependencies: 'Real (entire system)',
    cost: 'High',
    examples: [
      'Test user registration to login',
      'Test checkout process',
      'Test admin dashboard'
    ]
  }
};
```

### Test Types Comparison

```javascript
/**
 * When to use each test type
 */

const testTypes = {
  unit: {
    test: 'Individual functions in isolation',
    setup: 'Minimal',
    speed: 'âš¡ Very fast',
    maintenance: 'Easy',
    confidence: 'Low to medium',
    when: 'Testing pure functions, utilities, business logic'
  },

  integration: {
    test: 'Multiple components working together',
    setup: 'Database, external services',
    speed: 'ðŸ¢ Medium',
    maintenance: 'Medium',
    confidence: 'Medium to high',
    when: 'Testing APIs, database operations, service integration'
  },

  e2e: {
    test: 'Complete user workflows',
    setup: 'Full application stack',
    speed: 'ðŸ¦¥ Slow',
    maintenance: 'Complex',
    confidence: 'Very high',
    when: 'Testing critical user paths, acceptance testing'
  }
};
```

---

## Unit Testing with Vitest

### Setup and Configuration

```javascript
/**
 * Install: npm install -D vitest
 */

// vitest.config.js
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      exclude: [
        'node_modules/',
        'dist/',
        '**/*.test.js',
        '**/*.spec.js'
      ]
    },
    setupFiles: ['./tests/setup.js']
  }
});

// package.json
{
  "scripts": {
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest --coverage"
  }
}
```

### Basic Unit Tests

```javascript
/**
 * Unit testing fundamentals
 */

import { describe, it, expect, beforeEach, afterEach } from 'vitest';

// Code to test
export function add(a, b) {
  return a + b;
}

export function divide(a, b) {
  if (b === 0) {
    throw new Error('Division by zero');
  }
  return a / b;
}

export class Calculator {
  constructor() {
    this.result = 0;
  }

  add(n) {
    this.result += n;
    return this;
  }

  subtract(n) {
    this.result -= n;
    return this;
  }

  getValue() {
    return this.result;
  }

  reset() {
    this.result = 0;
    return this;
  }
}

// Tests
describe('Math functions', () => {
  it('should add two numbers', () => {
    expect(add(2, 3)).toBe(5);
    expect(add(-1, 1)).toBe(0);
    expect(add(0, 0)).toBe(0);
  });

  it('should divide two numbers', () => {
    expect(divide(10, 2)).toBe(5);
    expect(divide(9, 3)).toBe(3);
  });

  it('should throw error when dividing by zero', () => {
    expect(() => divide(10, 0)).toThrow('Division by zero');
  });
});

describe('Calculator', () => {
  let calc;

  beforeEach(() => {
    calc = new Calculator();
  });

  it('should start with zero', () => {
    expect(calc.getValue()).toBe(0);
  });

  it('should add numbers', () => {
    calc.add(5).add(3);
    expect(calc.getValue()).toBe(8);
  });

  it('should subtract numbers', () => {
    calc.add(10).subtract(3);
    expect(calc.getValue()).toBe(7);
  });

  it('should reset to zero', () => {
    calc.add(100).reset();
    expect(calc.getValue()).toBe(0);
  });

  it('should chain operations', () => {
    const result = calc.add(5).add(3).subtract(2).getValue();
    expect(result).toBe(6);
  });
});
```

### Testing Async Code

```javascript
/**
 * Testing asynchronous functions
 */

// Async functions to test
export async function fetchUser(id) {
  const response = await fetch(`https://api.example.com/users/${id}`);
  return response.json();
}

export function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

export async function processData(data) {
  await delay(100);
  return data.map(item => item * 2);
}

// Tests
import { describe, it, expect } from 'vitest';

describe('Async functions', () => {
  it('should resolve promise', async () => {
    const result = await delay(10);
    expect(result).toBeUndefined();
  });

  it('should process data after delay', async () => {
    const input = [1, 2, 3];
    const result = await processData(input);
    expect(result).toEqual([2, 4, 6]);
  });

  it('should handle promise rejection', async () => {
    const failingFunction = async () => {
      throw new Error('Failed');
    };

    await expect(failingFunction()).rejects.toThrow('Failed');
  });

  it('should timeout after 1 second', async () => {
    const slowFunction = async () => {
      await delay(2000);
      return 'done';
    };

    await expect(slowFunction()).rejects.toThrow();
  }, 1000); // 1 second timeout
});
```

### Testing Error Handling

```javascript
/**
 * Testing error cases
 */

export class ValidationError extends Error {
  constructor(message, field) {
    super(message);
    this.name = 'ValidationError';
    this.field = field;
  }
}

export function validateEmail(email) {
  if (!email) {
    throw new ValidationError('Email is required', 'email');
  }

  if (!email.includes('@')) {
    throw new ValidationError('Invalid email format', 'email');
  }

  return true;
}

export async function createUser(userData) {
  validateEmail(userData.email);

  if (!userData.password || userData.password.length < 8) {
    throw new ValidationError('Password must be at least 8 characters', 'password');
  }

  return { id: 1, ...userData };
}

// Tests
describe('Validation', () => {
  describe('validateEmail', () => {
    it('should accept valid email', () => {
      expect(validateEmail('test@example.com')).toBe(true);
    });

    it('should reject empty email', () => {
      expect(() => validateEmail('')).toThrow(ValidationError);
      expect(() => validateEmail('')).toThrow('Email is required');
    });

    it('should reject invalid format', () => {
      try {
        validateEmail('invalid');
      } catch (error) {
        expect(error).toBeInstanceOf(ValidationError);
        expect(error.field).toBe('email');
        expect(error.message).toBe('Invalid email format');
      }
    });
  });

  describe('createUser', () => {
    it('should create user with valid data', async () => {
      const userData = {
        email: 'test@example.com',
        password: 'SecurePass123'
      };

      const user = await createUser(userData);
      expect(user).toHaveProperty('id');
      expect(user.email).toBe(userData.email);
    });

    it('should reject weak password', async () => {
      const userData = {
        email: 'test@example.com',
        password: 'weak'
      };

      await expect(createUser(userData)).rejects.toThrow(ValidationError);
    });
  });
});
```

---

## Integration Testing

### Database Integration Tests

```javascript
/**
 * Testing with real database
 */

import { describe, it, expect, beforeAll, afterAll, beforeEach } from 'vitest';
import mongoose from 'mongoose';
import User from '../models/User.js';

describe('User Model Integration', () => {
  // Setup test database
  beforeAll(async () => {
    const testUri = 'mongodb://localhost:27017/test';
    await mongoose.connect(testUri);
  });

  afterAll(async () => {
    await mongoose.connection.close();
  });

  beforeEach(async () => {
    // Clear database before each test
    await User.deleteMany({});
  });

  it('should create a user', async () => {
    const userData = {
      username: 'testuser',
      email: 'test@example.com',
      password: 'hashedpassword'
    };

    const user = await User.create(userData);

    expect(user).toHaveProperty('_id');
    expect(user.username).toBe(userData.username);
    expect(user.email).toBe(userData.email);
  });

  it('should not allow duplicate emails', async () => {
    const userData = {
      username: 'testuser',
      email: 'test@example.com',
      password: 'hashedpassword'
    };

    await User.create(userData);

    await expect(User.create({
      ...userData,
      username: 'testuser2'
    })).rejects.toThrow();
  });

  it('should find user by email', async () => {
    const userData = {
      username: 'testuser',
      email: 'test@example.com',
      password: 'hashedpassword'
    };

    await User.create(userData);

    const found = await User.findOne({ email: userData.email });
    expect(found).toBeTruthy();
    expect(found.username).toBe(userData.username);
  });

  it('should update user', async () => {
    const user = await User.create({
      username: 'testuser',
      email: 'test@example.com',
      password: 'hashedpassword'
    });

    user.username = 'updateduser';
    await user.save();

    const updated = await User.findById(user._id);
    expect(updated.username).toBe('updateduser');
  });

  it('should delete user', async () => {
    const user = await User.create({
      username: 'testuser',
      email: 'test@example.com',
      password: 'hashedpassword'
    });

    await User.findByIdAndDelete(user._id);

    const found = await User.findById(user._id);
    expect(found).toBeNull();
  });
});
```

### Service Integration Tests

```javascript
/**
 * Testing services with dependencies
 */

// UserService.js
export class UserService {
  constructor(userRepository, emailService) {
    this.userRepository = userRepository;
    this.emailService = emailService;
  }

  async registerUser(userData) {
    // Check if user exists
    const existing = await this.userRepository.findByEmail(userData.email);
    if (existing) {
      throw new Error('Email already registered');
    }

    // Create user
    const user = await this.userRepository.create(userData);

    // Send welcome email
    await this.emailService.sendWelcome(user.email, user.username);

    return user;
  }

  async updateProfile(userId, updates) {
    const user = await this.userRepository.findById(userId);

    if (!user) {
      throw new Error('User not found');
    }

    return await this.userRepository.update(userId, updates);
  }
}

// Tests
import { describe, it, expect, beforeEach } from 'vitest';
import { UserService } from '../services/UserService.js';
import { UserRepository } from '../repositories/UserRepository.js';
import { EmailService } from '../services/EmailService.js';

describe('UserService Integration', () => {
  let userService;
  let userRepository;
  let emailService;

  beforeEach(async () => {
    // Use real implementations
    userRepository = new UserRepository();
    emailService = new EmailService();
    userService = new UserService(userRepository, emailService);

    // Clear database
    await userRepository.deleteAll();
  });

  it('should register new user', async () => {
    const userData = {
      email: 'test@example.com',
      password: 'SecurePass123',
      username: 'testuser'
    };

    const user = await userService.registerUser(userData);

    expect(user).toHaveProperty('id');
    expect(user.email).toBe(userData.email);

    // Verify user exists in database
    const found = await userRepository.findById(user.id);
    expect(found).toBeTruthy();
  });

  it('should prevent duplicate registration', async () => {
    const userData = {
      email: 'test@example.com',
      password: 'SecurePass123',
      username: 'testuser'
    };

    await userService.registerUser(userData);

    await expect(userService.registerUser(userData))
      .rejects.toThrow('Email already registered');
  });

  it('should update user profile', async () => {
    const userData = {
      email: 'test@example.com',
      password: 'SecurePass123',
      username: 'testuser'
    };

    const user = await userService.registerUser(userData);

    const updated = await userService.updateProfile(user.id, {
      username: 'newusername'
    });

    expect(updated.username).toBe('newusername');
  });
});
```

---

## API Testing with Supertest

### Setup Supertest

```javascript
/**
 * Install: npm install -D supertest
 */

import express from 'express';
import request from 'supertest';
import { describe, it, expect, beforeAll, afterAll } from 'vitest';

// Create app
const app = express();
app.use(express.json());

// Routes
app.get('/api/health', (req, res) => {
  res.json({ status: 'ok' });
});

app.post('/api/users', async (req, res) => {
  const { username, email } = req.body;

  if (!username || !email) {
    return res.status(400).json({ error: 'Missing required fields' });
  }

  const user = {
    id: 1,
    username,
    email,
    createdAt: new Date()
  };

  res.status(201).json(user);
});

app.get('/api/users/:id', async (req, res) => {
  const userId = parseInt(req.params.id);

  if (isNaN(userId)) {
    return res.status(400).json({ error: 'Invalid user ID' });
  }

  // Simulate database lookup
  if (userId === 999) {
    return res.status(404).json({ error: 'User not found' });
  }

  res.json({
    id: userId,
    username: 'testuser',
    email: 'test@example.com'
  });
});

// Tests
describe('API Endpoints', () => {
  describe('GET /api/health', () => {
    it('should return health status', async () => {
      const response = await request(app)
        .get('/api/health')
        .expect(200)
        .expect('Content-Type', /json/);

      expect(response.body).toEqual({ status: 'ok' });
    });
  });

  describe('POST /api/users', () => {
    it('should create new user', async () => {
      const userData = {
        username: 'testuser',
        email: 'test@example.com'
      };

      const response = await request(app)
        .post('/api/users')
        .send(userData)
        .expect(201)
        .expect('Content-Type', /json/);

      expect(response.body).toMatchObject({
        username: userData.username,
        email: userData.email
      });
      expect(response.body).toHaveProperty('id');
      expect(response.body).toHaveProperty('createdAt');
    });

    it('should reject invalid data', async () => {
      const response = await request(app)
        .post('/api/users')
        .send({ username: 'testuser' }) // Missing email
        .expect(400);

      expect(response.body).toHaveProperty('error');
    });
  });

  describe('GET /api/users/:id', () => {
    it('should get user by id', async () => {
      const response = await request(app)
        .get('/api/users/1')
        .expect(200);

      expect(response.body).toHaveProperty('id', 1);
      expect(response.body).toHaveProperty('username');
      expect(response.body).toHaveProperty('email');
    });

    it('should return 404 for non-existent user', async () => {
      const response = await request(app)
        .get('/api/users/999')
        .expect(404);

      expect(response.body).toHaveProperty('error', 'User not found');
    });

    it('should reject invalid id', async () => {
      await request(app)
        .get('/api/users/invalid')
        .expect(400);
    });
  });
});
```

### Testing Authentication

```javascript
/**
 * Testing protected routes with authentication
 */

import jwt from 'jsonwebtoken';

// Auth middleware
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return res.status(401).json({ error: 'Token required' });
  }

  try {
    const user = jwt.verify(token, process.env.JWT_SECRET);
    req.user = user;
    next();
  } catch (error) {
    res.status(403).json({ error: 'Invalid token' });
  }
};

app.get('/api/profile', authenticateToken, (req, res) => {
  res.json({
    id: req.user.id,
    username: req.user.username
  });
});

// Tests
describe('Authentication', () => {
  let validToken;

  beforeAll(() => {
    validToken = jwt.sign(
      { id: 1, username: 'testuser' },
      process.env.JWT_SECRET,
      { expiresIn: '1h' }
    );
  });

  it('should access protected route with valid token', async () => {
    const response = await request(app)
      .get('/api/profile')
      .set('Authorization', `Bearer ${validToken}`)
      .expect(200);

    expect(response.body).toHaveProperty('username', 'testuser');
  });

  it('should reject request without token', async () => {
    await request(app)
      .get('/api/profile')
      .expect(401);
  });

  it('should reject invalid token', async () => {
    await request(app)
      .get('/api/profile')
      .set('Authorization', 'Bearer invalid-token')
      .expect(403);
  });
});
```

### Testing File Uploads

```javascript
/**
 * Testing file upload endpoints
 */

import multer from 'multer';
import path from 'path';

const upload = multer({ dest: 'uploads/' });

app.post('/api/upload', upload.single('file'), (req, res) => {
  if (!req.file) {
    return res.status(400).json({ error: 'No file uploaded' });
  }

  res.json({
    filename: req.file.filename,
    originalname: req.file.originalname,
    size: req.file.size,
    mimetype: req.file.mimetype
  });
});

// Tests
import fs from 'fs';

describe('File Upload', () => {
  it('should upload file', async () => {
    const testFile = path.join(__dirname, 'fixtures', 'test.txt');

    const response = await request(app)
      .post('/api/upload')
      .attach('file', testFile)
      .expect(200);

    expect(response.body).toHaveProperty('filename');
    expect(response.body).toHaveProperty('originalname', 'test.txt');
    expect(response.body).toHaveProperty('mimetype', 'text/plain');
  });

  it('should reject request without file', async () => {
    await request(app)
      .post('/api/upload')
      .expect(400);
  });
});
```

---

## Mocking and Stubs

### Mocking Functions

```javascript
/**
 * Mocking with Vitest
 */

import { describe, it, expect, vi, beforeEach } from 'vitest';

// External service
export class EmailService {
  async sendEmail(to, subject, body) {
    // Actually sends email
    console.log(`Sending email to ${to}`);
    return { success: true };
  }
}

// Service using email
export class UserService {
  constructor(emailService) {
    this.emailService = emailService;
  }

  async notifyUser(userId, message) {
    const user = await this.getUser(userId);
    await this.emailService.sendEmail(user.email, 'Notification', message);
    return { sent: true };
  }

  async getUser(userId) {
    return { id: userId, email: 'test@example.com' };
  }
}

// Tests with mocking
describe('UserService with Mocks', () => {
  let userService;
  let emailService;

  beforeEach(() => {
    emailService = new EmailService();
    userService = new UserService(emailService);
  });

  it('should notify user', async () => {
    // Mock the sendEmail method
    const sendEmailSpy = vi.spyOn(emailService, 'sendEmail')
      .mockResolvedValue({ success: true });

    const result = await userService.notifyUser(1, 'Hello!');

    expect(result).toEqual({ sent: true });
    expect(sendEmailSpy).toHaveBeenCalledOnce();
    expect(sendEmailSpy).toHaveBeenCalledWith(
      'test@example.com',
      'Notification',
      'Hello!'
    );
  });

  it('should handle email failure', async () => {
    // Mock email to fail
    vi.spyOn(emailService, 'sendEmail')
      .mockRejectedValue(new Error('Email failed'));

    await expect(userService.notifyUser(1, 'Hello!'))
      .rejects.toThrow('Email failed');
  });
});
```

### Mocking Modules

```javascript
/**
 * Mocking entire modules
 */

// database.js
export async function query(sql, params) {
  // Real database query
  return [];
}

// userRepository.js
import { query } from './database.js';

export async function findUserById(id) {
  const results = await query('SELECT * FROM users WHERE id = ?', [id]);
  return results[0];
}

// Tests
import { describe, it, expect, vi } from 'vitest';
import { findUserById } from '../userRepository.js';

// Mock the entire database module
vi.mock('../database.js', () => ({
  query: vi.fn()
}));

import { query } from '../database.js';

describe('User Repository', () => {
  it('should find user by id', async () => {
    const mockUser = { id: 1, username: 'testuser' };

    // Mock the query function
    query.mockResolvedValue([mockUser]);

    const user = await findUserById(1);

    expect(user).toEqual(mockUser);
    expect(query).toHaveBeenCalledWith(
      'SELECT * FROM users WHERE id = ?',
      [1]
    );
  });
});
```

### Test Doubles

```javascript
/**
 * Different types of test doubles
 */

// 1. Dummy - passed but never used
const dummyLogger = {
  log: () => {}
};

// 2. Stub - provides predefined responses
const stubDatabase = {
  query: () => Promise.resolve([{ id: 1, name: 'Test' }])
};

// 3. Spy - records how it's called
const spyLogger = {
  calls: [],
  log: function(message) {
    this.calls.push(message);
  }
};

// 4. Mock - verifies behavior
const mockEmailService = {
  sendEmail: vi.fn().mockResolvedValue({ success: true })
};

// 5. Fake - working implementation (simplified)
class FakeDatabase {
  constructor() {
    this.data = new Map();
  }

  async insert(table, data) {
    const id = this.data.size + 1;
    this.data.set(id, { ...data, id });
    return id;
  }

  async findById(id) {
    return this.data.get(id);
  }
}

// Usage in tests
describe('Test Doubles', () => {
  it('should use stub', () => {
    const service = new DataService(stubDatabase);
    // Will get predefined data
  });

  it('should use spy', () => {
    const service = new LoggingService(spyLogger);
    service.doSomething();

    expect(spyLogger.calls).toHaveLength(1);
  });

  it('should use mock', async () => {
    const service = new NotificationService(mockEmailService);
    await service.notify('test@example.com');

    expect(mockEmailService.sendEmail).toHaveBeenCalledWith(
      'test@example.com',
      expect.any(String),
      expect.any(String)
    );
  });

  it('should use fake', async () => {
    const fakeDb = new FakeDatabase();
    const service = new UserService(fakeDb);

    const userId = await service.createUser({ name: 'Test' });
    const user = await fakeDb.findById(userId);

    expect(user).toMatchObject({ name: 'Test' });
  });
});
```

---

## Test Coverage

### Measuring Coverage

```javascript
/**
 * Generate coverage report
 *
 * npm run test:coverage
 */

// vitest.config.js
export default defineConfig({
  test: {
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      all: true,
      include: ['src/**/*.js'],
      exclude: [
        'node_modules/',
        'dist/',
        '**/*.test.js',
        '**/*.spec.js',
        '**/index.js'
      ],
      lines: 80,      // Minimum 80% line coverage
      functions: 80,  // Minimum 80% function coverage
      branches: 75,   // Minimum 75% branch coverage
      statements: 80  // Minimum 80% statement coverage
    }
  }
});

/**
 * Coverage reports show:
 * - Lines covered
 * - Branches covered
 * - Functions covered
 * - Statements covered
 * - Uncovered code
 */
```

### Writing Testable Code

```javascript
/**
 * Make code more testable
 */

// âŒ Hard to test (tightly coupled)
class UserService {
  async createUser(userData) {
    const db = new Database('mongodb://localhost/myapp');
    const emailer = new EmailService(process.env.SMTP_HOST);

    const user = await db.insert('users', userData);
    await emailer.send(user.email, 'Welcome!');

    return user;
  }
}

// âœ… Easy to test (dependency injection)
class UserService {
  constructor(database, emailService) {
    this.database = database;
    this.emailService = emailService;
  }

  async createUser(userData) {
    const user = await this.database.insert('users', userData);
    await this.emailService.send(user.email, 'Welcome!');
    return user;
  }
}

// Test easily with mocks
const mockDb = { insert: vi.fn().mockResolvedValue({ id: 1 }) };
const mockEmail = { send: vi.fn().mockResolvedValue(true) };
const service = new UserService(mockDb, mockEmail);

// âŒ Hard to test (hidden dependencies)
function processOrder(orderId) {
  const db = require('./database');
  const payment = require('./payment');
  // ...
}

// âœ… Easy to test (explicit dependencies)
function processOrder(orderId, db, paymentService) {
  // Can pass mocks
}

// âŒ Hard to test (mixed concerns)
async function handleUserRegistration(req, res) {
  const userData = req.body;
  // Validation
  // Database
  // Email
  // Response
}

// âœ… Easy to test (separated concerns)
async function validateUserData(userData) { /* ... */ }
async function createUser(userData, db) { /* ... */ }
async function sendWelcomeEmail(user, emailService) { /* ... */ }

async function handleUserRegistration(req, res) {
  const userData = req.body;
  validateUserData(userData);
  const user = await createUser(userData, db);
  await sendWelcomeEmail(user, emailService);
  res.json(user);
}
```

---

## Test-Driven Development

### TDD Workflow

```javascript
/**
 * TDD Cycle: Red -> Green -> Refactor
 *
 * 1. RED: Write a failing test
 * 2. GREEN: Write minimal code to pass
 * 3. REFACTOR: Improve code while keeping tests green
 */

/**
 * Example: Build a password validator using TDD
 */

// Step 1: Write failing test
describe('Password Validator', () => {
  it('should reject passwords shorter than 8 characters', () => {
    expect(validatePassword('short')).toBe(false);
  });
});

// Test fails (function doesn't exist)

// Step 2: Make it pass
function validatePassword(password) {
  return password.length >= 8;
}

// Test passes

// Step 3: Add more requirements
it('should require uppercase letter', () => {
  expect(validatePassword('alllowercase123')).toBe(false);
  expect(validatePassword('HasUpper123')).toBe(true);
});

// Update implementation
function validatePassword(password) {
  if (password.length < 8) return false;
  if (!/[A-Z]/.test(password)) return false;
  return true;
}

// Step 4: Add more tests
it('should require lowercase letter', () => {
  expect(validatePassword('ALLUPPERCASE123')).toBe(false);
  expect(validatePassword('HasLower123')).toBe(true);
});

it('should require number', () => {
  expect(validatePassword('NoNumbers')).toBe(false);
  expect(validatePassword('HasNumber1')).toBe(true);
});

it('should require special character', () => {
  expect(validatePassword('NoSpecial123')).toBe(false);
  expect(validatePassword('HasSpecial!123')).toBe(true);
});

// Final implementation
function validatePassword(password) {
  if (password.length < 8) return false;
  if (!/[A-Z]/.test(password)) return false;
  if (!/[a-z]/.test(password)) return false;
  if (!/[0-9]/.test(password)) return false;
  if (!/[!@#$%^&*]/.test(password)) return false;
  return true;
}

// Refactor for clarity
function validatePassword(password) {
  const requirements = [
    { test: (p) => p.length >= 8, message: 'At least 8 characters' },
    { test: (p) => /[A-Z]/.test(p), message: 'Uppercase letter' },
    { test: (p) => /[a-z]/.test(p), message: 'Lowercase letter' },
    { test: (p) => /[0-9]/.test(p), message: 'Number' },
    { test: (p) => /[!@#$%^&*]/.test(p), message: 'Special character' }
  ];

  return requirements.every(req => req.test(password));
}
```

---

## E2E Testing

### Setup Playwright

```javascript
/**
 * Install: npm install -D @playwright/test
 *
 * npx playwright install
 */

// playwright.config.js
import { defineConfig } from '@playwright/test';

export default defineConfig({
  testDir: './e2e',
  timeout: 30000,
  retries: 2,
  use: {
    baseURL: 'http://localhost:3000',
    screenshot: 'only-on-failure',
    video: 'retain-on-failure'
  },
  webServer: {
    command: 'npm run start',
    port: 3000,
    reuseExistingServer: !process.env.CI
  }
});
```

### E2E Test Examples

```javascript
/**
 * End-to-end user flows
 */

import { test, expect } from '@playwright/test';

test.describe('User Registration Flow', () => {
  test('should register new user', async ({ page }) => {
    // Navigate to registration page
    await page.goto('/register');

    // Fill form
    await page.fill('[name="username"]', 'testuser');
    await page.fill('[name="email"]', 'test@example.com');
    await page.fill('[name="password"]', 'SecurePass123!');

    // Submit
    await page.click('[type="submit"]');

    // Verify redirect to dashboard
    await expect(page).toHaveURL('/dashboard');

    // Verify welcome message
    await expect(page.locator('.welcome')).toContainText('Welcome, testuser');
  });

  test('should show validation errors', async ({ page }) => {
    await page.goto('/register');

    await page.fill('[name="username"]', 'ab'); // Too short
    await page.click('[type="submit"]');

    await expect(page.locator('.error')).toContainText(
      'Username must be at least 3 characters'
    );
  });
});

test.describe('Login Flow', () => {
  test('should login successfully', async ({ page }) => {
    await page.goto('/login');

    await page.fill('[name="email"]', 'test@example.com');
    await page.fill('[name="password"]', 'SecurePass123!');
    await page.click('[type="submit"]');

    await expect(page).toHaveURL('/dashboard');
  });

  test('should reject invalid credentials', async ({ page }) => {
    await page.goto('/login');

    await page.fill('[name="email"]', 'test@example.com');
    await page.fill('[name="password"]', 'wrong');
    await page.click('[type="submit"]');

    await expect(page.locator('.error')).toContainText('Invalid credentials');
  });
});

test.describe('Checkout Flow', () => {
  test.beforeEach(async ({ page }) => {
    // Login first
    await page.goto('/login');
    await page.fill('[name="email"]', 'test@example.com');
    await page.fill('[name="password"]', 'SecurePass123!');
    await page.click('[type="submit"]');
  });

  test('should complete purchase', async ({ page }) => {
    // Add item to cart
    await page.goto('/products');
    await page.click('.product:first-child .add-to-cart');

    // Go to cart
    await page.click('.cart-icon');
    await expect(page.locator('.cart-items')).toContainText('1 item');

    // Proceed to checkout
    await page.click('.checkout-button');

    // Fill shipping info
    await page.fill('[name="address"]', '123 Main St');
    await page.fill('[name="city"]', 'New York');
    await page.fill('[name="zip"]', '10001');

    // Fill payment info (test mode)
    await page.fill('[name="cardNumber"]', '4242424242424242');
    await page.fill('[name="expiry"]', '12/25');
    await page.fill('[name="cvv"]', '123');

    // Complete purchase
    await page.click('.complete-purchase');

    // Verify success
    await expect(page).toHaveURL(/\/order\/\d+/);
    await expect(page.locator('.success')).toContainText('Order confirmed');
  });
});
```

---

## CI/CD for Testing

### GitHub Actions

```yaml
# .github/workflows/test.yml
name: Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  test:
    runs-on: ubuntu-latest

    services:
      mongodb:
        image: mongo:6
        ports:
          - 27017:27017

      redis:
        image: redis:7
        ports:
          - 6379:6379

    strategy:
      matrix:
        node-version: [18.x, 20.x]

    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v3
        with:
          node-version: ${{ matrix.node-version }}

      - name: Install dependencies
        run: npm ci

      - name: Run linter
        run: npm run lint

      - name: Run unit tests
        run: npm run test:unit

      - name: Run integration tests
        run: npm run test:integration
        env:
          MONGO_URI: mongodb://localhost:27017/test
          REDIS_URI: redis://localhost:6379

      - name: Run E2E tests
        run: npm run test:e2e

      - name: Generate coverage
        run: npm run test:coverage

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage/coverage-final.json

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: test-results
          path: |
            coverage/
            test-results/
```

### GitLab CI

```yaml
# .gitlab-ci.yml
stages:
  - test
  - build
  - deploy

variables:
  NODE_VERSION: "18"
  MONGO_URI: "mongodb://mongo:27017/test"

services:
  - mongo:6

test:unit:
  stage: test
  image: node:${NODE_VERSION}
  before_script:
    - npm ci
  script:
    - npm run lint
    - npm run test:unit
  coverage: '/All files[^|]*\|[^|]*\s+([\d\.]+)/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml

test:integration:
  stage: test
  image: node:${NODE_VERSION}
  before_script:
    - npm ci
  script:
    - npm run test:integration
  dependencies:
    - test:unit

test:e2e:
  stage: test
  image: mcr.microsoft.com/playwright:latest
  before_script:
    - npm ci
  script:
    - npm run test:e2e
  artifacts:
    when: on_failure
    paths:
      - test-results/
    expire_in: 1 week
```

---

## Worked Examples

### Example 1: Complete API Test Suite

```javascript
/**
 * Comprehensive API testing example
 */

import { describe, it, expect, beforeAll, afterAll, beforeEach } from 'vitest';
import request from 'supertest';
import mongoose from 'mongoose';
import app from '../app.js';
import User from '../models/User.js';
import Post from '../models/Post.js';

describe('Blog API', () => {
  let authToken;
  let userId;

  beforeAll(async () => {
    await mongoose.connect(process.env.TEST_MONGO_URI);
  });

  afterAll(async () => {
    await mongoose.connection.close();
  });

  beforeEach(async () => {
    await User.deleteMany({});
    await Post.deleteMany({});
  });

  describe('Authentication', () => {
    it('should register new user', async () => {
      const response = await request(app)
        .post('/api/auth/register')
        .send({
          username: 'testuser',
          email: 'test@example.com',
          password: 'SecurePass123!'
        })
        .expect(201);

      expect(response.body).toHaveProperty('token');
      expect(response.body.user).toMatchObject({
        username: 'testuser',
        email: 'test@example.com'
      });

      authToken = response.body.token;
      userId = response.body.user.id;
    });

    it('should login', async () => {
      // Create user first
      await request(app)
        .post('/api/auth/register')
        .send({
          username: 'testuser',
          email: 'test@example.com',
          password: 'SecurePass123!'
        });

      const response = await request(app)
        .post('/api/auth/login')
        .send({
          email: 'test@example.com',
          password: 'SecurePass123!'
        })
        .expect(200);

      expect(response.body).toHaveProperty('token');
    });
  });

  describe('Posts', () => {
    beforeEach(async () => {
      // Register and login
      const response = await request(app)
        .post('/api/auth/register')
        .send({
          username: 'testuser',
          email: 'test@example.com',
          password: 'SecurePass123!'
        });

      authToken = response.body.token;
      userId = response.body.user.id;
    });

    it('should create post', async () => {
      const postData = {
        title: 'Test Post',
        content: 'This is test content',
        tags: ['test', 'example']
      };

      const response = await request(app)
        .post('/api/posts')
        .set('Authorization', `Bearer ${authToken}`)
        .send(postData)
        .expect(201);

      expect(response.body.post).toMatchObject({
        title: postData.title,
        content: postData.content,
        tags: postData.tags
      });
    });

    it('should list posts', async () => {
      // Create test posts
      await Post.create([
        {
          title: 'Post 1',
          content: 'Content 1',
          author: userId
        },
        {
          title: 'Post 2',
          content: 'Content 2',
          author: userId
        }
      ]);

      const response = await request(app)
        .get('/api/posts')
        .expect(200);

      expect(response.body.posts).toHaveLength(2);
      expect(response.body.pagination).toMatchObject({
        page: 1,
        total: 2
      });
    });

    it('should update own post', async () => {
      const post = await Post.create({
        title: 'Original',
        content: 'Original content',
        author: userId
      });

      const response = await request(app)
        .put(`/api/posts/${post._id}`)
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          title: 'Updated',
          content: 'Updated content'
        })
        .expect(200);

      expect(response.body.post.title).toBe('Updated');
    });

    it('should not update other users post', async () => {
      const otherUserId = new mongoose.Types.ObjectId();
      const post = await Post.create({
        title: 'Other users post',
        content: 'Content',
        author: otherUserId
      });

      await request(app)
        .put(`/api/posts/${post._id}`)
        .set('Authorization', `Bearer ${authToken}`)
        .send({ title: 'Hacked' })
        .expect(403);
    });

    it('should delete post', async () => {
      const post = await Post.create({
        title: 'To Delete',
        content: 'Content',
        author: userId
      });

      await request(app)
        .delete(`/api/posts/${post._id}`)
        .set('Authorization', `Bearer ${authToken}`)
        .expect(200);

      const deleted = await Post.findById(post._id);
      expect(deleted).toBeNull();
    });
  });
});
```

### Example 2: TDD Shopping Cart

```javascript
/**
 * Build shopping cart using TDD
 */

// Tests first
describe('ShoppingCart', () => {
  let cart;

  beforeEach(() => {
    cart = new ShoppingCart();
  });

  describe('Adding items', () => {
    it('should add item to cart', () => {
      cart.addItem({ id: 1, name: 'Product', price: 10 });

      expect(cart.getItems()).toHaveLength(1);
    });

    it('should increase quantity for same item', () => {
      const product = { id: 1, name: 'Product', price: 10 };

      cart.addItem(product);
      cart.addItem(product);

      expect(cart.getItems()).toHaveLength(1);
      expect(cart.getItems()[0].quantity).toBe(2);
    });

    it('should add different items separately', () => {
      cart.addItem({ id: 1, name: 'Product 1', price: 10 });
      cart.addItem({ id: 2, name: 'Product 2', price: 20 });

      expect(cart.getItems()).toHaveLength(2);
    });
  });

  describe('Removing items', () => {
    it('should remove item completely', () => {
      cart.addItem({ id: 1, name: 'Product', price: 10 });
      cart.removeItem(1);

      expect(cart.getItems()).toHaveLength(0);
    });

    it('should decrease quantity', () => {
      const product = { id: 1, name: 'Product', price: 10 };
      cart.addItem(product, 3);
      cart.removeItem(1, 1);

      expect(cart.getItems()[0].quantity).toBe(2);
    });
  });

  describe('Calculations', () => {
    it('should calculate total', () => {
      cart.addItem({ id: 1, name: 'Product 1', price: 10 }, 2);
      cart.addItem({ id: 2, name: 'Product 2', price: 20 }, 1);

      expect(cart.getTotal()).toBe(40);
    });

    it('should apply discount', () => {
      cart.addItem({ id: 1, name: 'Product', price: 100 });
      cart.applyDiscount(10); // 10% off

      expect(cart.getTotal()).toBe(90);
    });

    it('should calculate tax', () => {
      cart.addItem({ id: 1, name: 'Product', price: 100 });

      expect(cart.getTax(0.1)).toBe(10); // 10% tax
      expect(cart.getTotalWithTax(0.1)).toBe(110);
    });
  });
});

// Implementation
export class ShoppingCart {
  constructor() {
    this.items = [];
    this.discount = 0;
  }

  addItem(product, quantity = 1) {
    const existing = this.items.find(item => item.id === product.id);

    if (existing) {
      existing.quantity += quantity;
    } else {
      this.items.push({
        ...product,
        quantity
      });
    }
  }

  removeItem(productId, quantity = null) {
    const index = this.items.findIndex(item => item.id === productId);

    if (index === -1) return;

    if (quantity === null || this.items[index].quantity <= quantity) {
      this.items.splice(index, 1);
    } else {
      this.items[index].quantity -= quantity;
    }
  }

  getItems() {
    return this.items;
  }

  getSubtotal() {
    return this.items.reduce((sum, item) => {
      return sum + (item.price * item.quantity);
    }, 0);
  }

  applyDiscount(percentage) {
    this.discount = percentage;
  }

  getTotal() {
    const subtotal = this.getSubtotal();
    const discountAmount = subtotal * (this.discount / 100);
    return subtotal - discountAmount;
  }

  getTax(rate) {
    return this.getTotal() * rate;
  }

  getTotalWithTax(rate) {
    return this.getTotal() + this.getTax(rate);
  }

  clear() {
    this.items = [];
    this.discount = 0;
  }
}
```

---

## Exercises

### Exercise 1: Test User Service (Easy)

**Problem:** Write comprehensive tests for a user service.

```javascript
/**
 * Test this user service
 */

class UserService {
  async createUser(userData) {
    // Validate
    // Hash password
    // Save to database
    // Send welcome email
    return user;
  }

  async findByEmail(email) {
    // Find user
  }

  async updatePassword(userId, oldPassword, newPassword) {
    // Verify old password
    // Hash new password
    // Update
  }
}

// Write tests for all methods
```

**Solution:** See `solutions/exercise1_testing.js`

---

### Exercise 2: API Integration Tests (Medium)

**Problem:** Write integration tests for a RESTful API.

```javascript
/**
 * Test all CRUD operations for a resource
 */

// Create, Read, Update, Delete
// Authentication
// Validation
// Error handling
```

**Solution:** See `solutions/exercise2_testing.js`

---

### Exercise 3: Mock External API (Medium)

**Problem:** Test a service that calls external APIs.

```javascript
/**
 * Mock external weather API
 */

class WeatherService {
  async getCurrentWeather(city) {
    const response = await fetch(
      `https://api.weather.com/current?city=${city}`
    );
    return response.json();
  }
}

// Write tests with mocked fetch
```

**Solution:** See `solutions/exercise3_testing.js`

---

### Exercise 4: TDD Payment Processing (Hard)

**Problem:** Build a payment processor using TDD.

```javascript
/**
 * Requirements:
 * - Process credit card payments
 * - Validate card numbers
 * - Handle different card types
 * - Calculate fees
 * - Refund processing
 */

// Write tests first, then implementation
```

**Solution:** See `solutions/exercise4_testing.js`

---

### Exercise 5: E2E User Journey (Hard)

**Problem:** Write E2E tests for complete user journey.

```javascript
/**
 * User flow:
 * 1. Register
 * 2. Login
 * 3. Create content
 * 4. Edit content
 * 5. Share with others
 * 6. Logout
 */

// Write Playwright tests
```

**Solution:** See `solutions/exercise5_testing.js`

---

## Testing & Verification

```javascript
// Run all tests
npm test

// Run with coverage
npm run test:coverage

// Run specific file
npm test user.test.js

// Run in watch mode
npm test -- --watch

// Run with UI
npm run test:ui
```

---

## Best Practices

1. **Follow the testing pyramid** - More unit tests, fewer E2E
2. **Write tests first** when possible (TDD)
3. **Test behavior, not implementation**
4. **Keep tests independent** - No shared state
5. **Use descriptive test names** - Explain what's being tested
6. **One assertion per test** when practical
7. **Mock external dependencies** for unit tests
8. **Use real dependencies** for integration tests
9. **Clean up after tests** - Remove test data
10. **Run tests in CI/CD** - Automate testing

---

## Common Pitfalls

1. **Testing implementation details** instead of behavior
2. **Shared state between tests** causing flaky tests
3. **Not cleaning up** test data
4. **Over-mocking** making tests meaningless
5. **Writing tests after code** instead of TDD
6. **Ignoring edge cases** and error scenarios
7. **Too many E2E tests** making suite slow
8. **Not running tests** before committing
9. **No coverage measurement** to find gaps
10. **Flaky tests** that sometimes pass/fail

---

## Performance Considerations

```javascript
/**
 * Speed up tests
 */

// 1. Run in parallel
// vitest.config.js
export default defineConfig({
  test: {
    pool: 'threads',
    poolOptions: {
      threads: {
        maxThreads: 4
      }
    }
  }
});

// 2. Use in-memory database
import { MongoMemoryServer } from 'mongodb-memory-server';

let mongod;

beforeAll(async () => {
  mongod = await MongoMemoryServer.create();
  const uri = mongod.getUri();
  await mongoose.connect(uri);
});

// 3. Reuse database connection
let dbConnection;

beforeAll(async () => {
  dbConnection = await connectToDatabase();
});

// 4. Mock slow operations
vi.mock('./slowService', () => ({
  process: vi.fn().mockResolvedValue('result')
}));
```

---

## Summary & Next Steps

### Key Takeaways

- Testing catches bugs early and enables confident refactoring
- Follow the testing pyramid for optimal test distribution
- Use Vitest for unit tests, Supertest for API tests
- Mock external dependencies in unit tests
- TDD leads to better design and comprehensive tests
- Automate testing in CI/CD pipelines

### Related Topics

- [Database Integration](./36.Database_Integration.md)
- [Performance and Optimization](./40.Performance_And_Optimization.md)
- [Deployment and DevOps](./42.Deployment_And_DevOps.md)

### Further Reading

- [Vitest Documentation](https://vitest.dev/)
- [Testing Best Practices](https://kentcdodds.com/blog/common-mistakes-with-react-testing-library)
- [TDD Guide](https://martinfowler.com/bliki/TestDrivenDevelopment.html)

---

## References

- Vitest: https://vitest.dev/
- Supertest: https://github.com/visionmedia/supertest
- Playwright: https://playwright.dev/
- Testing Library: https://testing-library.com/

---

**Next Lesson:** [Performance and Optimization](./40.Performance_And_Optimization.md)
