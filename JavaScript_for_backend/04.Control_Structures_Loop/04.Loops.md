# JavaScript Control Structures: Loops

**Difficulty:** Introductory to Intermediate
**Estimated Time:** 50-70 minutes
**Prerequisites:** Variables, data types, operators, conditionals
**Node.js Version:** 18.0.0+ LTS
**Browser Targets:** Chrome 90+, Firefox 88+, Safari 14+, Edge 90+

---

## Learning Objectives

By the end of this lesson, you will be able to:

1. **Implement** all loop types (for, while, do-while, for...in, for...of) appropriately
2. **Control** loop execution using break, continue, and labels
3. **Understand** when to use each loop type for optimal code clarity
4. **Apply** common loop patterns (accumulation, search, filtering, mapping)
5. **Avoid** infinite loops and performance pitfalls
6. **Compare** traditional loops with modern array methods
7. **Debug** loop logic and identify off-by-one errors
8. **Write** efficient, readable loop code following best practices

---

## Table of Contents

1. [Introduction to Loops](#introduction-to-loops)
2. [For Loops](#for-loops)
3. [While Loops](#while-loops)
4. [Do-While Loops](#do-while-loops)
5. [For...in Loops](#forin-loops)
6. [For...of Loops](#forof-loops)
7. [Loop Control Statements](#loop-control-statements)
8. [Nested Loops](#nested-loops)
9. [Loop Patterns](#loop-patterns)
10. [Worked Examples](#worked-examples)
11. [Hands-on Exercises](#hands-on-exercises)
12. [Infinite Loops and Prevention](#infinite-loops-and-prevention)
13. [Performance Considerations](#performance-considerations)
14. [Loops vs Array Methods](#loops-vs-array-methods)
15. [Common Pitfalls & Debugging](#common-pitfalls--debugging)
16. [Testing & Verification](#testing--verification)
17. [Summary & Next Steps](#summary--next-steps)
18. [References](#references)

---

## Introduction to Loops

### What Are Loops?

**Loops** are control structures that repeatedly execute a block of code until a specified condition becomes false. They eliminate code repetition and enable processing of collections and sequences.

### Why Loops Matter

Loops allow you to:
- **Automate repetitive tasks** without code duplication
- **Process collections** (arrays, objects, strings)
- **Generate sequences** and patterns
- **Search and filter** data sets
- **Implement algorithms** efficiently

### Mental Model

Think of a loop as an instruction to repeat an action:

```
Instead of:
  console.log(1);
  console.log(2);
  console.log(3);
  // ... 100 more lines

Use a loop:
  for (let i = 1; i <= 100; i++) {
    console.log(i);
  }
```

---

## For Loops

### Classic For Loop

The most common loop type, ideal when you know **how many iterations** you need.

**Syntax:**
```javascript
for (initialization; condition; increment) {
  // Code to execute each iteration
}
```

**Components:**
1. **Initialization:** Runs once before loop starts (usually declares counter)
2. **Condition:** Checked before each iteration (loop continues if true)
3. **Increment:** Runs after each iteration (usually updates counter)

**Example:**
```javascript
for (let i = 0; i < 5; i++) {
  console.log(`Iteration ${i}`);
}

// Output:
// Iteration 0
// Iteration 1
// Iteration 2
// Iteration 3
// Iteration 4
```

**Execution Flow:**
```
1. let i = 0          (initialize)
2. Is i < 5? Yes      (check condition)
3. Execute body       (console.log)
4. i++                (increment: i becomes 1)
5. Is i < 5? Yes      (check condition)
6. Execute body
7. i++                (increment: i becomes 2)
... repeat until i < 5 is false
```

---

### Counting Patterns

**Count up:**
```javascript
for (let i = 0; i < 10; i++) {
  console.log(i); // 0, 1, 2, ..., 9
}
```

**Count down:**
```javascript
for (let i = 10; i > 0; i--) {
  console.log(i); // 10, 9, 8, ..., 1
}
```

**Step by 2:**
```javascript
for (let i = 0; i < 10; i += 2) {
  console.log(i); // 0, 2, 4, 6, 8
}
```

**Iterate array:**
```javascript
const fruits = ['apple', 'banana', 'cherry'];

for (let i = 0; i < fruits.length; i++) {
  console.log(fruits[i]);
}
// Output: apple, banana, cherry
```

---

### Advanced For Loop Features

**Multiple variables:**
```javascript
for (let i = 0, j = 10; i < j; i++, j--) {
  console.log(`i: ${i}, j: ${j}`);
}
// Output:
// i: 0, j: 10
// i: 1, j: 9
// i: 2, j: 8
// ...
```

**Empty sections (rare):**
```javascript
let i = 0;
for (; i < 5; ) {
  console.log(i);
  i++;
}
```

**Reverse iteration:**
```javascript
const arr = ['a', 'b', 'c', 'd'];

// More efficient: avoids length lookup each iteration
for (let i = arr.length - 1; i >= 0; i--) {
  console.log(arr[i]); // d, c, b, a
}
```

---

## While Loops

### Basic While Loop

Executes code **while** a condition is true. Best when the **number of iterations is unknown**.

**Syntax:**
```javascript
while (condition) {
  // Code to execute
  // Must eventually make condition false!
}
```

**Example:**
```javascript
let count = 0;

while (count < 5) {
  console.log(`Count: ${count}`);
  count++; // Essential to avoid infinite loop!
}

// Output:
// Count: 0
// Count: 1
// Count: 2
// Count: 3
// Count: 4
```

---

### When to Use While Loops

**Condition-based iteration:**
```javascript
let userInput = '';

while (userInput !== 'quit') {
  userInput = prompt('Enter command (or "quit" to exit):');
  processCommand(userInput);
}
```

**Unknown iterations:**
```javascript
let attempts = 0;
let success = false;

while (!success && attempts < 3) {
  success = tryOperation();
  attempts++;
}

if (success) {
  console.log('Operation succeeded');
} else {
  console.log('Failed after 3 attempts');
}
```

**Reading data until end:**
```javascript
let data;

while ((data = readNextChunk()) !== null) {
  processData(data);
}
```

---

## Do-While Loops

### Basic Do-While Loop

Similar to while, but **executes at least once** before checking the condition.

**Syntax:**
```javascript
do {
  // Code executes at least once
} while (condition);
```

**Example:**
```javascript
let input;

do {
  input = prompt('Enter a number between 1-10:');
} while (input < 1 || input > 10);

console.log(`Valid input: ${input}`);
```

**Key Difference:**
```javascript
// While: May not execute at all
let x = 10;
while (x < 5) {
  console.log('This never runs');
}

// Do-While: Always executes once
let y = 10;
do {
  console.log('This runs once even though condition is false');
} while (y < 5);
```

---

### Use Cases

**Menu systems:**
```javascript
let choice;

do {
  console.log('1. New Game');
  console.log('2. Load Game');
  console.log('3. Settings');
  console.log('4. Exit');

  choice = getUserChoice();
  handleChoice(choice);
} while (choice !== 4);
```

**Validation loops:**
```javascript
let password;

do {
  password = getPasswordInput();

  if (password.length < 8) {
    console.log('Password too short. Try again.');
  }
} while (password.length < 8);
```

---

## For...in Loops

### Iterating Object Properties

The `for...in` loop iterates over **enumerable properties** of an object.

**Syntax:**
```javascript
for (const key in object) {
  // Access key and object[key]
}
```

**Example:**
```javascript
const person = {
  name: 'Alice',
  age: 30,
  city: 'New York',
};

for (const key in person) {
  console.log(`${key}: ${person[key]}`);
}

// Output:
// name: Alice
// age: 30
// city: New York
```

---

### Important Considerations

**1. Iterates inherited properties:**
```javascript
const parent = { inherited: true };
const child = Object.create(parent);
child.own = 'value';

for (const key in child) {
  console.log(key); // Prints both 'own' and 'inherited'
}

// Solution: Check hasOwnProperty
for (const key in child) {
  if (child.hasOwnProperty(key)) {
    console.log(key); // Only prints 'own'
  }
}

// Modern alternative:
for (const key in child) {
  if (Object.hasOwn(child, key)) {
    console.log(key); // Only prints 'own'
  }
}
```

**2. Order not guaranteed (historically):**
```javascript
// Modern engines maintain insertion order,
// but for...in is not guaranteed by spec
const obj = { z: 1, a: 2, m: 3 };

for (const key in obj) {
  console.log(key); // May not be z, a, m in older environments
}
```

**3. Don't use for arrays:**
```javascript
const arr = ['a', 'b', 'c'];
arr.customProperty = 'custom';

// ❌ WRONG: for...in on arrays
for (const index in arr) {
  console.log(index); // Prints: 0, 1, 2, customProperty (Bad!)
}

// ✅ CORRECT: Use for...of for arrays
for (const value of arr) {
  console.log(value); // Prints: a, b, c (Good!)
}
```

---

### Practical Usage

**Extract object data:**
```javascript
const config = {
  host: 'localhost',
  port: 3000,
  debug: true,
};

const entries = [];
for (const key in config) {
  if (Object.hasOwn(config, key)) {
    entries.push(`${key}=${config[key]}`);
  }
}

console.log(entries.join('&'));
// Output: host=localhost&port=3000&debug=true
```

---

## For...of Loops

### Iterating Iterables

The `for...of` loop iterates over **iterable objects** (arrays, strings, maps, sets, etc.).

**Syntax:**
```javascript
for (const element of iterable) {
  // Access element directly
}
```

**Example:**
```javascript
const fruits = ['apple', 'banana', 'cherry'];

for (const fruit of fruits) {
  console.log(fruit);
}

// Output:
// apple
// banana
// cherry
```

---

### Works with Many Types

**Arrays:**
```javascript
const numbers = [1, 2, 3, 4, 5];

for (const num of numbers) {
  console.log(num * 2); // 2, 4, 6, 8, 10
}
```

**Strings:**
```javascript
const message = 'Hello';

for (const char of message) {
  console.log(char); // H, e, l, l, o
}
```

**Sets:**
```javascript
const uniqueValues = new Set([1, 2, 2, 3, 3, 3]);

for (const value of uniqueValues) {
  console.log(value); // 1, 2, 3
}
```

**Maps:**
```javascript
const userRoles = new Map([
  ['alice', 'admin'],
  ['bob', 'editor'],
]);

for (const [username, role] of userRoles) {
  console.log(`${username}: ${role}`);
}
// Output:
// alice: admin
// bob: editor
```

**Array entries (index + value):**
```javascript
const fruits = ['apple', 'banana', 'cherry'];

for (const [index, fruit] of fruits.entries()) {
  console.log(`${index}: ${fruit}`);
}
// Output:
// 0: apple
// 1: banana
// 2: cherry
```

---

### For...of vs For...in

| Feature | `for...of` | `for...in` |
|---------|------------|------------|
| **Purpose** | Iterate over values | Iterate over keys |
| **Works with** | Iterables (arrays, strings, sets, maps) | Objects |
| **Array usage** | ✅ Recommended | ❌ Not recommended |
| **Gets** | Element values | Property names/indices |
| **Order** | Guaranteed iteration order | Not guaranteed (spec) |

**Example:**
```javascript
const arr = ['a', 'b', 'c'];

// for...of: Gets values
for (const value of arr) {
  console.log(value); // a, b, c
}

// for...in: Gets indices (as strings!)
for (const index in arr) {
  console.log(index); // "0", "1", "2"
}
```

---

## Loop Control Statements

### Break Statement

**Exits the loop immediately**, skipping remaining iterations.

**Syntax:**
```javascript
break;
```

**Example:**
```javascript
// Find first even number
const numbers = [1, 3, 5, 8, 9, 11];
let firstEven;

for (const num of numbers) {
  if (num % 2 === 0) {
    firstEven = num;
    break; // Stop searching once found
  }
}

console.log(firstEven); // 8
```

**Search with break:**
```javascript
const users = [
  { id: 1, name: 'Alice' },
  { id: 2, name: 'Bob' },
  { id: 3, name: 'Charlie' },
];

const findUserById = (id) => {
  for (const user of users) {
    if (user.id === id) {
      return user; // Exits function (and loop)
    }
  }
  return null; // Not found
};
```

---

### Continue Statement

**Skips the current iteration** and continues with the next one.

**Syntax:**
```javascript
continue;
```

**Example:**
```javascript
// Print only odd numbers
for (let i = 1; i <= 10; i++) {
  if (i % 2 === 0) {
    continue; // Skip even numbers
  }
  console.log(i); // 1, 3, 5, 7, 9
}
```

**Filter with continue:**
```javascript
const scores = [45, 82, 91, 67, 55, 88, 73];

console.log('Scores above 70:');
for (const score of scores) {
  if (score <= 70) {
    continue; // Skip scores 70 or below
  }
  console.log(score); // 82, 91, 88, 73
}
```

---

### Labels (Advanced)

**Labels** allow breaking/continuing outer loops from nested loops.

**Syntax:**
```javascript
labelName: for (...) {
  for (...) {
    break labelName; // Breaks outer loop
  }
}
```

**Example:**
```javascript
// Find position in 2D array
const matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9],
];

const target = 5;
let found = false;

outerLoop: for (let row = 0; row < matrix.length; row++) {
  for (let col = 0; col < matrix[row].length; col++) {
    if (matrix[row][col] === target) {
      console.log(`Found ${target} at [${row}][${col}]`);
      found = true;
      break outerLoop; // Exits both loops
    }
  }
}

if (!found) {
  console.log('Not found');
}
```

**Without label (wrong):**
```javascript
// ❌ WRONG: Only breaks inner loop
for (let row = 0; row < matrix.length; row++) {
  for (let col = 0; col < matrix[row].length; col++) {
    if (matrix[row][col] === target) {
      console.log('Found');
      break; // Only exits inner loop!
    }
  }
  // Outer loop continues...
}
```

---

## Nested Loops

### Basic Nested Loops

Loops inside loops, creating a **Cartesian product** of iterations.

**Example:**
```javascript
for (let i = 1; i <= 3; i++) {
  for (let j = 1; j <= 3; j++) {
    console.log(`i=${i}, j=${j}`);
  }
}

// Output:
// i=1, j=1
// i=1, j=2
// i=1, j=3
// i=2, j=1
// i=2, j=2
// i=2, j=3
// i=3, j=1
// i=3, j=2
// i=3, j=3
```

**Total iterations:** Outer × Inner = 3 × 3 = 9

---

### Common Patterns

**Multiplication table:**
```javascript
for (let i = 1; i <= 10; i++) {
  for (let j = 1; j <= 10; j++) {
    console.log(`${i} × ${j} = ${i * j}`);
  }
}
```

**Triangle pattern:**
```javascript
for (let row = 1; row <= 5; row++) {
  let stars = '';
  for (let col = 1; col <= row; col++) {
    stars += '* ';
  }
  console.log(stars);
}

// Output:
// *
// * *
// * * *
// * * * *
// * * * * *
```

**2D array processing:**
```javascript
const grid = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9],
];

let sum = 0;

for (let row = 0; row < grid.length; row++) {
  for (let col = 0; col < grid[row].length; col++) {
    sum += grid[row][col];
  }
}

console.log(`Sum: ${sum}`); // 45
```

---

### Performance Warning

**Time complexity multiplies:**
```javascript
// O(n²) - Quadratic time
for (let i = 0; i < n; i++) {           // n iterations
  for (let j = 0; j < n; j++) {         // n iterations each
    // Total: n × n = n² operations
  }
}

// O(n³) - Cubic time
for (let i = 0; i < n; i++) {
  for (let j = 0; j < n; j++) {
    for (let k = 0; k < n; k++) {
      // Total: n × n × n = n³ operations
    }
  }
}
```

**Example:**
- n = 10: 100 operations (fast)
- n = 100: 10,000 operations (noticeable)
- n = 1,000: 1,000,000 operations (slow!)

**Avoid deep nesting** when possible. Consider algorithms with better complexity.

---

## Loop Patterns

### 1. Accumulation Pattern

**Sum elements:**
```javascript
const numbers = [1, 2, 3, 4, 5];
let sum = 0;

for (const num of numbers) {
  sum += num;
}

console.log(sum); // 15
```

**Product:**
```javascript
const factors = [2, 3, 4];
let product = 1;

for (const factor of factors) {
  product *= factor;
}

console.log(product); // 24
```

**Concatenation:**
```javascript
const words = ['Hello', 'world', '!'];
let sentence = '';

for (const word of words) {
  sentence += word + ' ';
}

console.log(sentence.trim()); // "Hello world !"
```

---

### 2. Search Pattern

**Linear search:**
```javascript
const findElement = (arr, target) => {
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] === target) {
      return i; // Return index
    }
  }
  return -1; // Not found
};

const index = findElement([10, 20, 30, 40], 30);
console.log(index); // 2
```

**Find object:**
```javascript
const users = [
  { id: 1, name: 'Alice' },
  { id: 2, name: 'Bob' },
];

const findUser = (id) => {
  for (const user of users) {
    if (user.id === id) {
      return user;
    }
  }
  return null;
};
```

---

### 3. Filtering Pattern

**Collect matching elements:**
```javascript
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const evens = [];

for (const num of numbers) {
  if (num % 2 === 0) {
    evens.push(num);
  }
}

console.log(evens); // [2, 4, 6, 8, 10]
```

**Filter objects:**
```javascript
const products = [
  { name: 'Laptop', price: 1000 },
  { name: 'Mouse', price: 20 },
  { name: 'Keyboard', price: 50 },
];

const affordable = [];

for (const product of products) {
  if (product.price <= 50) {
    affordable.push(product);
  }
}

console.log(affordable); // Mouse, Keyboard
```

---

### 4. Transformation Pattern

**Map values:**
```javascript
const numbers = [1, 2, 3, 4, 5];
const doubled = [];

for (const num of numbers) {
  doubled.push(num * 2);
}

console.log(doubled); // [2, 4, 6, 8, 10]
```

**Transform objects:**
```javascript
const users = [
  { firstName: 'Alice', lastName: 'Smith' },
  { firstName: 'Bob', lastName: 'Jones' },
];

const fullNames = [];

for (const user of users) {
  fullNames.push(`${user.firstName} ${user.lastName}`);
}

console.log(fullNames); // ["Alice Smith", "Bob Jones"]
```

---

### 5. Validation Pattern

**Check all elements:**
```javascript
const allPositive = (numbers) => {
  for (const num of numbers) {
    if (num <= 0) {
      return false; // Early exit on first failure
    }
  }
  return true; // All passed
};

console.log(allPositive([1, 2, 3]));    // true
console.log(allPositive([1, -2, 3]));   // false
```

**Check any element:**
```javascript
const hasEven = (numbers) => {
  for (const num of numbers) {
    if (num % 2 === 0) {
      return true; // Early exit on first match
    }
  }
  return false; // None found
};

console.log(hasEven([1, 3, 5]));    // false
console.log(hasEven([1, 2, 3]));    // true
```

---

## Worked Examples

### Example 1: Prime Number Checker (Simple - 30 lines)

**Objective:** Determine if a number is prime using loops.

```javascript
/**
 * Example: Prime Number Checker
 *
 * Demonstrates:
 * - While loop for unknown iterations
 * - Early return optimization
 * - Mathematical algorithm implementation
 */

const isPrime = (num) => {
  // Guard clauses
  if (num < 2) {
    return false; // 0, 1, negatives not prime
  }

  if (num === 2) {
    return true; // 2 is prime
  }

  if (num % 2 === 0) {
    return false; // Even numbers (except 2) not prime
  }

  // Check odd divisors up to sqrt(num)
  let divisor = 3;
  const maxDivisor = Math.sqrt(num);

  while (divisor <= maxDivisor) {
    if (num % divisor === 0) {
      return false; // Found a divisor
    }
    divisor += 2; // Skip even numbers
  }

  return true; // No divisors found
};

// --- Tests ---
import { expect } from 'vitest';

expect(isPrime(2)).toBe(true);
expect(isPrime(3)).toBe(true);
expect(isPrime(17)).toBe(true);
expect(isPrime(97)).toBe(true);

expect(isPrime(0)).toBe(false);
expect(isPrime(1)).toBe(false);
expect(isPrime(4)).toBe(false);
expect(isPrime(100)).toBe(false);

console.log('✓ All prime checker tests passed');
```

---

### Example 2: Text Analyzer (Intermediate - 60 lines)

**Objective:** Analyze text statistics using multiple loop patterns.

```javascript
/**
 * Example: Text Analyzer
 *
 * Demonstrates:
 * - For...of for string iteration
 * - Object as accumulator
 * - Multiple loop patterns
 * - Character classification
 */

const analyzeText = (text) => {
  if (typeof text !== 'string') {
    throw new TypeError('Input must be a string');
  }

  const stats = {
    characters: text.length,
    letters: 0,
    digits: 0,
    spaces: 0,
    punctuation: 0,
    words: 0,
    lines: 0,
    characterFrequency: {},
  };

  // Character analysis
  for (const char of text) {
    // Count character types
    if (/[a-zA-Z]/.test(char)) {
      stats.letters++;
    } else if (/[0-9]/.test(char)) {
      stats.digits++;
    } else if (char === ' ') {
      stats.spaces++;
    } else if (/[.,!?;:]/.test(char)) {
      stats.punctuation++;
    }

    // Character frequency (case-insensitive)
    const lowerChar = char.toLowerCase();
    if (/[a-z]/.test(lowerChar)) {
      stats.characterFrequency[lowerChar] =
        (stats.characterFrequency[lowerChar] || 0) + 1;
    }
  }

  // Count words (split on whitespace)
  const words = text.trim().split(/\s+/);
  stats.words = text.trim() ? words.length : 0;

  // Count lines
  stats.lines = text.split('\n').length;

  // Find most common character
  let maxChar = '';
  let maxCount = 0;

  for (const char in stats.characterFrequency) {
    if (stats.characterFrequency[char] > maxCount) {
      maxCount = stats.characterFrequency[char];
      maxChar = char;
    }
  }

  stats.mostCommon = maxChar ? { char: maxChar, count: maxCount } : null;

  return stats;
};

// --- Tests ---
const sampleText = 'Hello, World!\nThis is a test.';
const result = analyzeText(sampleText);

expect(result.characters).toBe(30);
expect(result.letters).toBe(20);
expect(result.words).toBe(6);
expect(result.lines).toBe(2);
expect(result.mostCommon.char).toBe('t');

console.log('✓ All text analyzer tests passed');
console.log('Sample analysis:', result);
```

---

### Example 3: Matrix Operations (Advanced - 80 lines)

**Objective:** Implement matrix operations using nested loops.

```javascript
/**
 * Example: Matrix Operations
 *
 * Demonstrates:
 * - Nested loops for 2D arrays
 * - Matrix algorithms
 * - Performance considerations
 * - Error handling
 */

class Matrix {
  static add(matrixA, matrixB) {
    // Validate dimensions
    if (matrixA.length !== matrixB.length ||
        matrixA[0].length !== matrixB[0].length) {
      throw new Error('Matrices must have same dimensions');
    }

    const rows = matrixA.length;
    const cols = matrixA[0].length;
    const result = [];

    for (let i = 0; i < rows; i++) {
      result[i] = [];
      for (let j = 0; j < cols; j++) {
        result[i][j] = matrixA[i][j] + matrixB[i][j];
      }
    }

    return result;
  }

  static multiply(matrixA, matrixB) {
    // Validate: cols of A must equal rows of B
    const rowsA = matrixA.length;
    const colsA = matrixA[0].length;
    const rowsB = matrixB.length;
    const colsB = matrixB[0].length;

    if (colsA !== rowsB) {
      throw new Error('Invalid dimensions for multiplication');
    }

    const result = [];

    for (let i = 0; i < rowsA; i++) {
      result[i] = [];
      for (let j = 0; j < colsB; j++) {
        let sum = 0;
        for (let k = 0; k < colsA; k++) {
          sum += matrixA[i][k] * matrixB[k][j];
        }
        result[i][j] = sum;
      }
    }

    return result;
  }

  static transpose(matrix) {
    const rows = matrix.length;
    const cols = matrix[0].length;
    const result = [];

    for (let j = 0; j < cols; j++) {
      result[j] = [];
      for (let i = 0; i < rows; i++) {
        result[j][i] = matrix[i][j];
      }
    }

    return result;
  }

  static equals(matrixA, matrixB) {
    if (matrixA.length !== matrixB.length ||
        matrixA[0].length !== matrixB[0].length) {
      return false;
    }

    for (let i = 0; i < matrixA.length; i++) {
      for (let j = 0; j < matrixA[0].length; j++) {
        if (matrixA[i][j] !== matrixB[i][j]) {
          return false;
        }
      }
    }

    return true;
  }
}

// --- Tests ---
const A = [[1, 2], [3, 4]];
const B = [[5, 6], [7, 8]];

const sum = Matrix.add(A, B);
expect(sum).toEqual([[6, 8], [10, 12]]);

const product = Matrix.multiply(A, B);
expect(product).toEqual([[19, 22], [43, 50]]);

const transposed = Matrix.transpose(A);
expect(transposed).toEqual([[1, 3], [2, 4]]);

expect(Matrix.equals(A, A)).toBe(true);
expect(Matrix.equals(A, B)).toBe(false);

console.log('✓ All matrix operation tests passed');
```

---

## Hands-on Exercises

### Exercise 1: FizzBuzz (Easy)

**Task:** Print numbers 1-100, but replace multiples of 3 with "Fizz", multiples of 5 with "Buzz", and multiples of both with "FizzBuzz".

**Requirements:**
- Use a for loop
- Handle all three cases correctly
- Return array of results

**Example:**
```javascript
fizzBuzz(15);
// [1, 2, "Fizz", 4, "Buzz", "Fizz", 7, 8, "Fizz", "Buzz", 11, "Fizz", 13, 14, "FizzBuzz"]
```

**Solution:** See `/home/user/CG/JavaScript_for_backend/04.Control_Structures_Loop/solutions/01-fizzbuzz.js`

---

### Exercise 2: Fibonacci Sequence Generator (Medium)

**Task:** Generate the first n numbers of the Fibonacci sequence.

**Requirements:**
- Support n from 0 to any reasonable number
- Use efficient iteration (not recursion)
- Return array of numbers

**Example:**
```javascript
fibonacci(10);
// [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
```

**Solution:** See `/home/user/CG/JavaScript_for_backend/04.Control_Structures_Loop/solutions/02-fibonacci.js`

---

### Exercise 3: Array Chunk (Medium)

**Task:** Split an array into chunks of specified size.

**Requirements:**
- Handle edge cases (empty array, size larger than array)
- Last chunk may be smaller than size
- Don't modify original array

**Example:**
```javascript
chunk([1, 2, 3, 4, 5, 6, 7], 3);
// [[1, 2, 3], [4, 5, 6], [7]]
```

**Solution:** See `/home/user/CG/JavaScript_for_backend/04.Control_Structures_Loop/solutions/03-array-chunk.js`

---

### Exercise 4: Spiral Matrix Generator (Medium-Hard)

**Task:** Generate an n×n matrix filled with numbers 1 to n² in spiral order.

**Requirements:**
- Start from top-left, spiral clockwise
- Handle any size n
- Return 2D array

**Example:**
```javascript
spiralMatrix(3);
// [
//   [1, 2, 3],
//   [8, 9, 4],
//   [7, 6, 5]
// ]
```

**Solution:** See `/home/user/CG/JavaScript_for_backend/04.Control_Structures_Loop/solutions/04-spiral-matrix.js`

---

### Exercise 5: Sieve of Eratosthenes (Hard)

**Task:** Find all prime numbers up to n using the Sieve of Eratosthenes algorithm.

**Requirements:**
- Implement the classic algorithm
- Return array of primes
- Optimize for performance

**Algorithm:**
1. Create array of true values from 2 to n
2. For each number i from 2 to √n:
   - If i is marked true (prime):
     - Mark all multiples of i as false
3. Return all numbers still marked true

**Example:**
```javascript
sieveOfEratosthenes(20);
// [2, 3, 5, 7, 11, 13, 17, 19]
```

**Solution:** See `/home/user/CG/JavaScript_for_backend/04.Control_Structures_Loop/solutions/05-sieve-eratosthenes.js`

---

### Exercise 6: Pattern Printer (Advanced)

**Task:** Create a function that prints various ASCII patterns.

**Requirements:**
- Support multiple pattern types: pyramid, diamond, hollow square
- Parameterized size
- Return string (with newlines)

**Examples:**
```javascript
printPattern('pyramid', 5);
//     *
//    ***
//   *****
//  *******
// *********

printPattern('diamond', 3);
//   *
//  ***
// *****
//  ***
//   *
```

**Solution:** See `/home/user/CG/JavaScript_for_backend/04.Control_Structures_Loop/solutions/06-pattern-printer.js`

---

## Infinite Loops and Prevention

### What Is an Infinite Loop?

An **infinite loop** is a loop that never terminates because its condition never becomes false.

**Example:**
```javascript
// ❌ INFINITE LOOP: Condition always true
let i = 0;
while (i < 10) {
  console.log(i);
  // Forgot to increment i!
}
```

**Symptoms:**
- Browser tab becomes unresponsive
- CPU usage spikes to 100%
- Process must be forcibly terminated

---

### Common Causes

**1. Missing increment:**
```javascript
// ❌ WRONG
for (let i = 0; i < 10; ) { // No increment!
  console.log(i);
}

// ✅ CORRECT
for (let i = 0; i < 10; i++) {
  console.log(i);
}
```

**2. Wrong increment direction:**
```javascript
// ❌ WRONG: Counting up when should count down
for (let i = 10; i > 0; i++) { // i increases forever!
  console.log(i);
}

// ✅ CORRECT
for (let i = 10; i > 0; i--) {
  console.log(i);
}
```

**3. Condition never false:**
```javascript
// ❌ WRONG
while (true) {
  console.log('Forever!');
  // No break statement!
}

// ✅ CORRECT
while (true) {
  const input = getUserInput();
  if (input === 'quit') {
    break; // Exit condition
  }
}
```

**4. Off-by-one with while:**
```javascript
// ❌ WRONG: Resets counter
let count = 0;
while (count < 5) {
  console.log(count);
  count = 0; // Bug! Resets instead of incrementing
}

// ✅ CORRECT
let count = 0;
while (count < 5) {
  console.log(count);
  count++; // Increment
}
```

---

### Prevention Strategies

**1. Add safety counter:**
```javascript
let iterations = 0;
const MAX_ITERATIONS = 1000;

while (condition) {
  // Loop body

  iterations++;
  if (iterations > MAX_ITERATIONS) {
    console.error('Maximum iterations exceeded');
    break;
  }
}
```

**2. Use debugger:**
```javascript
let i = 0;
while (i < 10) {
  debugger; // Pauses here; inspect i in DevTools
  console.log(i);
  i++;
}
```

**3. Prefer for loops when possible:**
```javascript
// ✅ For loop: Hard to forget increment
for (let i = 0; i < 10; i++) {
  console.log(i);
}

// ⚠️ While loop: Easy to forget increment
let i = 0;
while (i < 10) {
  console.log(i);
  i++; // Must remember this!
}
```

---

### Emergency Exit

**Browser:**
- Close the tab
- Kill browser process (Task Manager / Activity Monitor)

**Node.js:**
- Press `Ctrl+C` in terminal
- Kill process: `kill -9 <pid>`

---

## Performance Considerations

### 1. Cache Length in Loops

**❌ SLOW: Recalculates length each iteration**
```javascript
for (let i = 0; i < array.length; i++) {
  // array.length evaluated 1,000,000 times
}
```

**✅ FAST: Cache length**
```javascript
const length = array.length;
for (let i = 0; i < length; i++) {
  // length evaluated once
}
```

**Benchmark:**
- Array with 1,000,000 elements
- Cached: ~2ms
- Uncached: ~3ms (50% slower)

---

### 2. Minimize Work Inside Loop

**❌ SLOW: Expensive operation every iteration**
```javascript
for (let i = 0; i < 1000; i++) {
  const result = expensiveCalculation(); // Recalculated 1000 times
  processData(i, result);
}
```

**✅ FAST: Move constant work outside**
```javascript
const result = expensiveCalculation(); // Calculated once
for (let i = 0; i < 1000; i++) {
  processData(i, result);
}
```

---

### 3. Use Appropriate Loop Type

**For...of vs For loop:**
```javascript
// For...of: Cleaner but slightly slower
for (const item of array) {
  process(item);
}

// For loop: Faster for large arrays
for (let i = 0; i < array.length; i++) {
  process(array[i]);
}
```

**When to optimize:**
- Arrays with 100,000+ elements
- Performance-critical code (games, real-time apps)
- Otherwise, prefer readability

---

### 4. Early Exit

**❌ SLOW: Checks all elements**
```javascript
let found = false;
for (const item of array) {
  if (item === target) {
    found = true;
    // Continues checking remaining elements!
  }
}
```

**✅ FAST: Exit early**
```javascript
let found = false;
for (const item of array) {
  if (item === target) {
    found = true;
    break; // Stop immediately
  }
}
```

---

## Loops vs Array Methods

### Modern Alternatives

JavaScript provides higher-order array methods that are often clearer than loops.

**Loop vs Method Comparison:**

| Operation | Loop | Array Method |
|-----------|------|--------------|
| Transform | `for` + `push` | `map()` |
| Filter | `for` + `if` + `push` | `filter()` |
| Aggregate | `for` + accumulator | `reduce()` |
| Search | `for` + `if` + `break` | `find()` |
| Test all | `for` + `if` + `return false` | `every()` |
| Test any | `for` + `if` + `return true` | `some()` |

---

### Example Comparisons

**Transform (map):**
```javascript
const numbers = [1, 2, 3, 4, 5];

// ❌ With loop (verbose)
const doubled = [];
for (const num of numbers) {
  doubled.push(num * 2);
}

// ✅ With map (concise)
const doubled = numbers.map(num => num * 2);
```

**Filter:**
```javascript
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// ❌ With loop
const evens = [];
for (const num of numbers) {
  if (num % 2 === 0) {
    evens.push(num);
  }
}

// ✅ With filter
const evens = numbers.filter(num => num % 2 === 0);
```

**Aggregate (reduce):**
```javascript
const numbers = [1, 2, 3, 4, 5];

// ❌ With loop
let sum = 0;
for (const num of numbers) {
  sum += num;
}

// ✅ With reduce
const sum = numbers.reduce((acc, num) => acc + num, 0);
```

**Search (find):**
```javascript
const users = [
  { id: 1, name: 'Alice' },
  { id: 2, name: 'Bob' },
];

// ❌ With loop
let user = null;
for (const u of users) {
  if (u.id === 2) {
    user = u;
    break;
  }
}

// ✅ With find
const user = users.find(u => u.id === 2);
```

---

### When to Use Loops vs Methods

**Use loops when:**
- Need to break/continue early
- Modifying array in place
- Performance-critical (very large arrays)
- Complex control flow

**Use array methods when:**
- Simple transformations
- Functional programming style
- Chainable operations
- Readability is priority

**Example of chaining:**
```javascript
const result = numbers
  .filter(n => n > 0)          // Keep positive
  .map(n => n * 2)              // Double
  .reduce((sum, n) => sum + n); // Sum

// Equivalent loop (much more verbose)
let result = 0;
for (const n of numbers) {
  if (n > 0) {
    result += n * 2;
  }
}
```

---

## Common Pitfalls & Debugging

### Pitfall 1: Off-by-One Errors

**Problem:**
```javascript
// ❌ WRONG: Skips last element
for (let i = 0; i < array.length - 1; i++) {
  console.log(array[i]);
}

// ❌ WRONG: Causes undefined
for (let i = 0; i <= array.length; i++) {
  console.log(array[i]); // undefined on last iteration
}

// ✅ CORRECT
for (let i = 0; i < array.length; i++) {
  console.log(array[i]);
}
```

---

### Pitfall 2: Modifying Array While Iterating

**Problem:**
```javascript
const numbers = [1, 2, 3, 4, 5];

// ❌ WRONG: Skips elements!
for (let i = 0; i < numbers.length; i++) {
  if (numbers[i] % 2 === 0) {
    numbers.splice(i, 1); // Removes element, shifts indices!
  }
}
// Result: [1, 3, 5] but 4 was skipped!

// ✅ CORRECT: Iterate backwards
for (let i = numbers.length - 1; i >= 0; i--) {
  if (numbers[i] % 2 === 0) {
    numbers.splice(i, 1);
  }
}

// ✅ BETTER: Use filter (creates new array)
const odds = numbers.filter(n => n % 2 !== 0);
```

---

### Pitfall 3: Variable Scope in Loops

**Problem with `var`:**
```javascript
// ❌ WRONG: All functions reference same i
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);
}
// Output: 3, 3, 3 (not 0, 1, 2!)

// ✅ CORRECT: Use let (block scope)
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);
}
// Output: 0, 1, 2
```

---

### Debugging Techniques

**1. Console logging:**
```javascript
for (let i = 0; i < array.length; i++) {
  console.log(`Iteration ${i}, value: ${array[i]}`);
  processData(array[i]);
}
```

**2. Debugger statement:**
```javascript
for (let i = 0; i < array.length; i++) {
  if (i === suspiciousIndex) {
    debugger; // Pauses here
  }
  processData(array[i]);
}
```

**3. Limit iterations during debugging:**
```javascript
// Debug mode: Only run 10 iterations
const maxIterations = DEBUG_MODE ? 10 : array.length;

for (let i = 0; i < maxIterations; i++) {
  processData(array[i]);
}
```

---

## Testing & Verification

### Unit Testing Loop Functions

```javascript
// loop-functions.test.js
import { describe, it, expect } from 'vitest';
import { sum, findMax, reverseString } from './loop-functions.js';

describe('Loop-based Functions', () => {
  describe('sum()', () => {
    it('should sum array of numbers', () => {
      expect(sum([1, 2, 3, 4, 5])).toBe(15);
    });

    it('should return 0 for empty array', () => {
      expect(sum([])).toBe(0);
    });

    it('should handle negative numbers', () => {
      expect(sum([-1, -2, -3])).toBe(-6);
    });
  });

  describe('findMax()', () => {
    it('should find maximum value', () => {
      expect(findMax([1, 5, 3, 9, 2])).toBe(9);
    });

    it('should handle single element', () => {
      expect(findMax([42])).toBe(42);
    });

    it('should throw for empty array', () => {
      expect(() => findMax([])).toThrow('Array cannot be empty');
    });
  });

  describe('reverseString()', () => {
    it('should reverse string', () => {
      expect(reverseString('hello')).toBe('olleh');
    });

    it('should handle empty string', () => {
      expect(reverseString('')).toBe('');
    });

    it('should handle palindrome', () => {
      expect(reverseString('racecar')).toBe('racecar');
    });
  });
});
```

---

## Summary & Next Steps

### Key Takeaways

1. **Choose the right loop:**
   - `for`: Known iterations
   - `while`: Condition-based
   - `for...of`: Iterate values
   - `for...in`: Iterate keys

2. **Control execution:** Use `break` and `continue` appropriately

3. **Avoid infinite loops:** Always ensure loop condition can become false

4. **Consider array methods:** Often clearer than loops for common operations

5. **Watch performance:** Cache lengths, minimize work inside loops

6. **Test thoroughly:** Cover edge cases, empty collections, single elements

### What You've Accomplished

- ✅ Mastered all JavaScript loop types
- ✅ Implemented common loop patterns (search, filter, accumulate)
- ✅ Understood performance implications of loops
- ✅ Learned to debug loop-related issues
- ✅ Compared loops with modern array methods
- ✅ Built complex algorithms using nested loops

### Next Topics to Study

1. **Functions** → [05.Functions.md](../05.Functions/05.Functions.md)
2. **Arrays** → [06.Arrays.md](../06.Arrays/06.Arrays.md)
3. **Objects** → [07.Objects.md](../07.Objects/07.Objects.md)

### Practice Projects

1. Build a Sudoku validator (nested loops, validation)
2. Create a text-based game with game loop
3. Implement sorting algorithms (bubble, selection, insertion)
4. Build a CSV parser and analyzer

---

## References

### Official Documentation

- [MDN: for](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for)
- [MDN: while](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/while)
- [MDN: do...while](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/do...while)
- [MDN: for...of](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of)
- [MDN: for...in](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in)
- [MDN: break](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/break)
- [MDN: continue](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/continue)

### Array Methods (Alternatives)

- [MDN: Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
- [MDN: Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)
- [MDN: Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)
- [MDN: Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find)

### Performance

- [V8 Blog: Fast for...of loops](https://v8.dev/blog/fast-for-in)
- [JavaScript.info: Loops](https://javascript.info/while-for)

---

**Last Updated:** 2025-11-22
**Curriculum Version:** 2.0.0
**Maintainer:** Code Galaxy Contributors

**Next Lesson:** [Functions](../05.Functions/05.Functions.md) →
