# Let, Const, and Block Scope in JavaScript

**Difficulty:** Intermediate
**Estimated Time:** 45-60 minutes
**Prerequisites:** Basic JavaScript knowledge, functions, variables
**Target:** Node.js 18+ LTS, Modern Browsers (ES2021+)

---

## Learning Objectives

By the end of this lesson, you will be able to:

1. **Understand** the fundamental differences between `var`, `let`, and `const` declarations and their scoping behavior
2. **Master** block scope vs function scope and apply appropriate scoping strategies
3. **Explain** the Temporal Dead Zone (TDZ) and its role in preventing errors
4. **Identify** hoisting behavior differences between var, let, const, functions, and classes
5. **Apply** block scope with if, for, while, and other control structures
6. **Compare** IIFE patterns vs modern block scope solutions
7. **Implement** best practices for choosing const vs let (and avoiding var)
8. **Debug** common scoping and declaration issues in real-world code

---

## Table of Contents

1. [Introduction](#introduction)
2. [The Evolution: From var to let/const](#the-evolution-from-var-to-letconst)
3. [Block Scope vs Function Scope](#block-scope-vs-function-scope)
4. [let: Block-Scoped Variables](#let-block-scoped-variables)
5. [const: Immutable Bindings](#const-immutable-bindings)
6. [Temporal Dead Zone Explained](#temporal-dead-zone-explained)
7. [Hoisting Behavior Comparison](#hoisting-behavior-comparison)
8. [Block Scope in Control Structures](#block-scope-in-control-structures)
9. [IIFE vs Block Scope](#iife-vs-block-scope)
10. [Best Practices and Conventions](#best-practices-and-conventions)
11. [Worked Examples](#worked-examples)
12. [Exercises](#exercises)
13. [Common Pitfalls](#common-pitfalls)
14. [Testing & Verification](#testing--verification)
15. [Summary & Next Steps](#summary--next-steps)
16. [References](#references)

---

## Introduction

Prior to ES6 (ECMAScript 2015), JavaScript only had **function scope** through the `var` keyword. This caused numerous issues: variable leaking, closure problems in loops, and confusing hoisting behavior. ES6 introduced `let` and `const` with **block scope**, fundamentally changing how we write JavaScript.

### Why This Matters

Understanding variable declarations and scope is critical because:

- **Prevents bugs:** Block scope eliminates variable leaking and unintended mutations
- **Improves readability:** Clear intent when using `const` vs `let`
- **Enables patterns:** Closures, modules, and functional programming rely on proper scoping
- **Modern standard:** All modern JavaScript (React, Node.js, Vue) uses `let`/`const` exclusively

### Key Concepts

- **Block scope:** Variables exist only within `{}` blocks
- **Function scope:** Variables exist throughout the entire function (legacy `var`)
- **Temporal Dead Zone:** The period where `let`/`const` variables exist but are uninitialized
- **Hoisting:** JavaScript's behavior of registering declarations before code execution
- **Immutable binding:** `const` prevents reassignment (not value mutation)

---

## The Evolution: From var to let/const

### The Problems with var

Before ES6, JavaScript only had `var`, which created several issues:

```javascript
// Problem 1: Function scope (not block scope)
function testVar() {
  if (true) {
    var x = 10;
  }
  console.log(x); // 10 (leaked outside if block!)
}

// Problem 2: Hoisting with undefined initialization
function hoistingIssue() {
  console.log(message); // undefined (not ReferenceError)
  var message = 'Hello';
}

// Problem 3: Redeclaration allowed (confusing)
var count = 10;
var count = 20; // No error
console.log(count); // 20

// Problem 4: Loop closure issues
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);
}
// Prints: 3, 3, 3 (expected 0, 1, 2)

// Problem 5: Global object pollution
var globalVar = 'I pollute window/global';
console.log(window.globalVar); // Available on global object (browser)
```

### The ES6 Solution: let and const

ES6 introduced block-scoped declarations:

```javascript
// Solution 1: Block scope with let
function testLet() {
  if (true) {
    let x = 10;
  }
  // console.log(x); // ReferenceError: x is not defined
}

// Solution 2: Temporal Dead Zone (TDZ)
function noTDZ() {
  // console.log(message); // ReferenceError: Cannot access before initialization
  let message = 'Hello';
}

// Solution 3: No redeclaration
let count = 10;
// let count = 20; // SyntaxError: Identifier 'count' has already been declared

// Solution 4: Loop closures work correctly
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);
}
// Prints: 0, 1, 2 (correct!)

// Solution 5: No global object pollution
let modernVar = 'Clean scope';
console.log(window.modernVar); // undefined
```

---

## Block Scope vs Function Scope

### What is a Block?

A **block** is any code within curly braces `{}`:

```javascript
// Standalone block
{
  let blockScoped = 'Only here';
  console.log(blockScoped); // Works
}
// console.log(blockScoped); // ReferenceError

// if block
if (true) {
  let condition = 'true branch';
}

// for loop block
for (let i = 0; i < 5; i++) {
  let iteration = i;
}

// while block
while (false) {
  let never = 'executed';
}

// Function block
function myFunction() {
  let functionBlock = 'function scoped';
}

// try-catch blocks
try {
  let tryBlock = 'error handling';
} catch (e) {
  let catchBlock = 'caught';
}
```

### Block Scope Behavior

Variables declared with `let` and `const` are **confined to their block**:

```javascript
function demonstrateBlockScope() {
  let outer = 'outer scope';

  {
    let inner = 'inner scope';
    console.log(outer); // 'outer scope' (accessible)
    console.log(inner); // 'inner scope' (accessible)
  }

  console.log(outer); // 'outer scope' (still accessible)
  // console.log(inner); // ReferenceError: inner is not defined
}
```

### Function Scope Behavior (var)

Variables declared with `var` are scoped to the **entire function**:

```javascript
function demonstrateFunctionScope() {
  var outer = 'outer scope';

  {
    var inner = 'inner scope'; // Still function-scoped!
    console.log(outer); // 'outer scope'
    console.log(inner); // 'inner scope'
  }

  console.log(outer); // 'outer scope'
  console.log(inner); // 'inner scope' (leaked from block!)
}
```

### Visual Comparison

```javascript
// Block Scope (let/const)
{
  let a = 1;
  {
    let b = 2;
    {
      let c = 3;
      console.log(a, b, c); // 1 2 3
    }
    console.log(a, b); // 1 2
    // console.log(c); // Error
  }
  console.log(a); // 1
  // console.log(b); // Error
}

// Function Scope (var)
function outer() {
  var a = 1;
  {
    var b = 2; // Same function scope as 'a'
    {
      var c = 3; // Same function scope as 'a' and 'b'
      console.log(a, b, c); // 1 2 3
    }
    console.log(a, b, c); // 1 2 3 (all accessible)
  }
  console.log(a, b, c); // 1 2 3 (all accessible)
}
```

---

## let: Block-Scoped Variables

### Basic Usage

`let` declares a block-scoped variable that can be reassigned:

```javascript
let userName = 'Alice';
userName = 'Bob'; // Reassignment allowed

let score; // Declaration without initialization
score = 100; // Initialization later

// Block-scoped
{
  let temporary = 'exists only here';
}
// console.log(temporary); // ReferenceError
```

### No Redeclaration

`let` prevents redeclaration in the same scope:

```javascript
let count = 10;
// let count = 20; // SyntaxError: Identifier 'count' has already been declared

// Different scopes allow same names
let name = 'outer';
{
  let name = 'inner'; // Different variable (shadowing)
  console.log(name); // 'inner'
}
console.log(name); // 'outer'
```

### Loop-Scoped Variables

`let` creates a new binding for each loop iteration:

```javascript
// Each iteration gets its own 'i'
for (let i = 0; i < 3; i++) {
  setTimeout(() => {
    console.log(i); // 0, 1, 2 (correct!)
  }, i * 100);
}

// Compare with var
for (var j = 0; j < 3; j++) {
  setTimeout(() => {
    console.log(j); // 3, 3, 3 (all share same 'j')
  }, j * 100);
}
```

### Practical Example: Event Listeners

```javascript
// ❌ Problem with var
const buttons = document.querySelectorAll('.button');

for (var i = 0; i < buttons.length; i++) {
  buttons[i].addEventListener('click', function() {
    console.log('Button ' + i); // Always logs buttons.length
  });
}

// ✅ Solution with let
for (let i = 0; i < buttons.length; i++) {
  buttons[i].addEventListener('click', function() {
    console.log('Button ' + i); // Logs correct index
  });
}
```

---

## const: Immutable Bindings

### Basic Usage

`const` declares a block-scoped constant (immutable binding):

```javascript
const PI = 3.14159;
// PI = 3.14; // TypeError: Assignment to constant variable

const API_URL = 'https://api.example.com';
// API_URL = 'https://other.com'; // TypeError

// Must initialize at declaration
// const value; // SyntaxError: Missing initializer in const declaration
const value = 42; // ✅ Correct
```

### const with Objects and Arrays

**Important:** `const` prevents reassignment, not mutation:

```javascript
// Arrays
const numbers = [1, 2, 3];

// ✅ Mutation allowed
numbers.push(4);
numbers[0] = 10;
console.log(numbers); // [10, 2, 3, 4]

// ❌ Reassignment not allowed
// numbers = [5, 6, 7]; // TypeError

// Objects
const user = {
  name: 'Alice',
  age: 30
};

// ✅ Mutation allowed
user.age = 31;
user.email = 'alice@example.com';
console.log(user); // { name: 'Alice', age: 31, email: 'alice@example.com' }

// ❌ Reassignment not allowed
// user = { name: 'Bob' }; // TypeError
```

### Preventing Mutation with Object.freeze()

To make objects truly immutable, use `Object.freeze()`:

```javascript
const config = Object.freeze({
  apiKey: 'secret123',
  timeout: 5000
});

config.apiKey = 'hacked'; // Silently fails in non-strict mode
console.log(config.apiKey); // 'secret123' (unchanged)

// In strict mode
'use strict';
const strictConfig = Object.freeze({ value: 42 });
// strictConfig.value = 100; // TypeError: Cannot assign to read only property
```

### Deep Freezing Nested Objects

`Object.freeze()` is shallow. For deep immutability:

```javascript
function deepFreeze(obj) {
  Object.freeze(obj);

  Object.getOwnPropertyNames(obj).forEach(prop => {
    if (obj[prop] !== null &&
        typeof obj[prop] === 'object' &&
        !Object.isFrozen(obj[prop])) {
      deepFreeze(obj[prop]);
    }
  });

  return obj;
}

const config = deepFreeze({
  database: {
    host: 'localhost',
    credentials: {
      user: 'admin',
      pass: 'secret'
    }
  }
});

// None of these work
// config.database.host = 'remote'; // Error
// config.database.credentials.pass = 'hacked'; // Error
```

---

## Temporal Dead Zone Explained

### What is TDZ?

The **Temporal Dead Zone** is the period between entering scope and variable initialization where accessing the variable throws a ReferenceError:

```javascript
{
  // TDZ starts
  // console.log(value); // ReferenceError: Cannot access 'value' before initialization

  let value = 42; // TDZ ends, variable initialized
  console.log(value); // 42
}
```

### Why TDZ Exists

TDZ prevents accessing variables before they're properly initialized, catching bugs:

```javascript
// ❌ Bug hidden with var
function buggyCode() {
  console.log(score); // undefined (should be error!)
  // ... many lines of code ...
  var score = calculateScore(); // Initialized much later
}

// ✅ Bug caught with let
function safecode() {
  // console.log(score); // ReferenceError (immediate error!)
  // ... many lines of code ...
  let score = calculateScore();
}
```

### TDZ in Different Contexts

```javascript
// Function parameters
function example(a = b, b = 2) {
  return a + b;
}
// example(); // ReferenceError: Cannot access 'b' before initialization

// Fixed version
function exampleFixed(a = 1, b = 2) {
  return a + b;
}

// Destructuring
const { x = y, y = 2 } = {}; // ReferenceError

// Class fields
class MyClass {
  // field = this.otherField; // ReferenceError
  otherField = 42;
}
```

### TDZ vs Hoisting

Both `let` and `const` are hoisted, but remain uninitialized:

```javascript
// What happens internally
{
  // Memory Phase: 'value' is registered but uninitialized

  // Execution Phase:
  // console.log(value); // TDZ - variable exists but uninitialized
  let value = 10; // Initialization
  console.log(value); // 10
}

// Compare with var
{
  // Memory Phase: 'value' is registered AND initialized to undefined

  // Execution Phase:
  console.log(value); // undefined (hoisted and initialized)
  var value = 10;
  console.log(value); // 10
}
```

---

## Hoisting Behavior Comparison

### Variable Hoisting Summary

```javascript
// var: Hoisted and initialized to undefined
console.log(varVariable); // undefined
var varVariable = 'var';

// let: Hoisted but NOT initialized (TDZ)
// console.log(letVariable); // ReferenceError
let letVariable = 'let';

// const: Hoisted but NOT initialized (TDZ)
// console.log(constVariable); // ReferenceError
const constVariable = 'const';
```

### Function Declaration Hoisting

Function declarations are fully hoisted:

```javascript
greet(); // 'Hello!' (works before declaration)

function greet() {
  console.log('Hello!');
}
```

### Function Expression Hoisting

Function expressions follow the variable hoisting rules:

```javascript
// ❌ var function expression
// greetVar(); // TypeError: greetVar is not a function
var greetVar = function() {
  console.log('Hello!');
};

// ❌ let/const function expression
// greetLet(); // ReferenceError: Cannot access before initialization
const greetLet = function() {
  console.log('Hello!');
};
```

### Arrow Function Hoisting

Arrow functions behave like function expressions:

```javascript
// ❌ Cannot call before declaration
// sayHi(); // ReferenceError
const sayHi = () => console.log('Hi!');

sayHi(); // ✅ Works after declaration
```

### Class Hoisting

Classes are hoisted but remain in TDZ:

```javascript
// ❌ Cannot use before declaration
// const instance = new MyClass(); // ReferenceError

class MyClass {
  constructor() {
    this.value = 42;
  }
}

const instance = new MyClass(); // ✅ Works
```

---

## Block Scope in Control Structures

### if/else Statements

```javascript
const score = 85;

if (score >= 60) {
  const grade = 'Pass';
  let message = 'Congratulations!';
  console.log(grade, message); // Works
}

// console.log(grade); // ReferenceError
// console.log(message); // ReferenceError

// Shadowing example
const status = 'global';

if (true) {
  const status = 'local'; // Different variable
  console.log(status); // 'local'
}

console.log(status); // 'global'
```

### for Loops

```javascript
// Classic for loop
for (let i = 0; i < 3; i++) {
  const squared = i * i;
  console.log(squared); // 0, 1, 4
}
// console.log(i); // ReferenceError
// console.log(squared); // ReferenceError

// for...of loop
const fruits = ['apple', 'banana', 'orange'];

for (const fruit of fruits) {
  const upperFruit = fruit.toUpperCase();
  console.log(upperFruit);
}
// console.log(fruit); // ReferenceError
// console.log(upperFruit); // ReferenceError

// for...in loop
const user = { name: 'Alice', age: 30 };

for (const key in user) {
  const value = user[key];
  console.log(key, value);
}
// console.log(key); // ReferenceError
// console.log(value); // ReferenceError
```

### while/do-while Loops

```javascript
let count = 0;

while (count < 3) {
  const message = `Count: ${count}`;
  console.log(message);
  count++;
}
// console.log(message); // ReferenceError

// do-while
let num = 0;

do {
  const doubled = num * 2;
  console.log(doubled);
  num++;
} while (num < 3);
// console.log(doubled); // ReferenceError
```

### switch Statements

```javascript
const day = 'Monday';

switch (day) {
  case 'Monday': {
    const message = 'Start of week';
    console.log(message);
    break;
  }
  case 'Friday': {
    const message = 'End of week'; // Different 'message'
    console.log(message);
    break;
  }
  default: {
    const message = 'Mid week';
    console.log(message);
  }
}
// console.log(message); // ReferenceError
```

**Important:** Use block `{}` in switch cases to create separate scopes.

---

## IIFE vs Block Scope

### The Old Way: IIFE (Immediately Invoked Function Expression)

Before ES6, developers used IIFEs to create scope:

```javascript
// IIFE pattern (ES5)
(function() {
  var privateVar = 'secret';
  var helper = function() {
    return privateVar.toUpperCase();
  };

  console.log(helper()); // 'SECRET'
})();

// console.log(privateVar); // ReferenceError
// console.log(helper); // ReferenceError
```

### The Modern Way: Block Scope

With ES6, simple blocks achieve the same:

```javascript
// Modern block scope (ES6+)
{
  const privateVar = 'secret';
  const helper = () => privateVar.toUpperCase();

  console.log(helper()); // 'SECRET'
}

// console.log(privateVar); // ReferenceError
// console.log(helper); // ReferenceError
```

### When to Use Each

```javascript
// ❌ Don't use IIFE for simple scoping
(function() {
  const x = 10;
  console.log(x);
})();

// ✅ Use block scope
{
  const x = 10;
  console.log(x);
}

// ✅ IIFE still useful for async context
(async function() {
  const data = await fetchData();
  console.log(data);
})();

// ✅ Or use async block (if top-level await available)
{
  const data = await fetchData();
  console.log(data);
}
```

---

## Best Practices and Conventions

### 1. Prefer const by Default

```javascript
// ✅ Use const for values that won't be reassigned
const MAX_USERS = 100;
const API_URL = 'https://api.example.com';
const users = ['Alice', 'Bob'];

// ❌ Don't use let unnecessarily
let API_URL = 'https://api.example.com'; // Shouldn't change
```

### 2. Use let Only When Reassignment is Needed

```javascript
// ✅ Appropriate use of let
let count = 0;
count++;

let currentUser = null;
currentUser = loadUser();

// Loop variables
for (let i = 0; i < 10; i++) {
  // i needs to change
}
```

### 3. Never Use var

```javascript
// ❌ Don't use var (even if you see it in old code)
var oldStyle = 'avoid';

// ✅ Use const or let
const modernStyle = 'preferred';
```

### 4. Declare Variables at the Top of Their Scope

```javascript
// ✅ Good: Declarations at top
function processData(items) {
  const results = [];
  let total = 0;

  for (const item of items) {
    total += item.value;
    results.push(item.name);
  }

  return { results, total };
}

// ❌ Avoid: Scattered declarations
function processDataBad(items) {
  for (const item of items) {
    const results = []; // New array each iteration!
    let total = 0; // Reset each iteration!
  }
}
```

### 5. Use Descriptive Names

```javascript
// ✅ Clear intent
const MAX_LOGIN_ATTEMPTS = 3;
const userIsAuthenticated = true;
const shoppingCartItems = [];

// ❌ Unclear
const x = 3;
const flag = true;
const arr = [];
```

### 6. Minimize Scope

```javascript
// ✅ Tight scope
function calculateTotal(items) {
  let total = 0;

  for (const item of items) {
    const price = item.price;
    const quantity = item.quantity;
    total += price * quantity;
  }

  return total;
}

// ❌ Unnecessarily wide scope
function calculateTotalBad(items) {
  let total = 0;
  let price; // Declared too early
  let quantity;

  for (const item of items) {
    price = item.price;
    quantity = item.quantity;
    total += price * quantity;
  }

  return total;
}
```

### 7. One Variable Per Line

```javascript
// ✅ One per line
const firstName = 'Alice';
const lastName = 'Smith';
const age = 30;

// ❌ Multiple per line (hard to read)
const firstName = 'Alice', lastName = 'Smith', age = 30;
```

---

## Worked Examples

### Example 1: Counter with Closures (Intermediate)

**Problem:** Create a counter that uses block scope and closures.

```javascript
/**
 * Example 1: Counter Factory with Block Scope
 *
 * Demonstrates:
 * - const for immutable factory function
 * - let for mutable state
 * - Block scope for encapsulation
 * - Closures capturing block-scoped variables
 */

const createCounter = (initialValue = 0) => {
  let count = initialValue; // Private state

  return {
    increment() {
      count++;
      return count;
    },

    decrement() {
      count--;
      return count;
    },

    reset() {
      count = initialValue;
      return count;
    },

    getValue() {
      return count;
    }
  };
};

// Usage
const counter1 = createCounter(10);
const counter2 = createCounter(0);

console.log(counter1.increment()); // 11
console.log(counter1.increment()); // 12
console.log(counter1.getValue()); // 12

console.log(counter2.increment()); // 1
console.log(counter2.increment()); // 2

counter1.reset();
console.log(counter1.getValue()); // 10 (reset to initial)

// count is not accessible from outside
// console.log(counter1.count); // undefined
```

**Testing:**

```javascript
import { describe, it, expect } from 'vitest';

describe('Counter', () => {
  it('should increment correctly', () => {
    const counter = createCounter(0);
    expect(counter.increment()).toBe(1);
    expect(counter.increment()).toBe(2);
  });

  it('should maintain separate state', () => {
    const counter1 = createCounter(0);
    const counter2 = createCounter(0);

    counter1.increment();
    counter1.increment();

    expect(counter1.getValue()).toBe(2);
    expect(counter2.getValue()).toBe(0);
  });

  it('should reset to initial value', () => {
    const counter = createCounter(10);
    counter.increment();
    counter.increment();
    counter.reset();
    expect(counter.getValue()).toBe(10);
  });
});
```

---

### Example 2: Event Loop Simulator (Advanced)

**Problem:** Demonstrate block scope in asynchronous code.

```javascript
/**
 * Example 2: Event Loop Simulator
 *
 * Demonstrates:
 * - let in loops creating separate bindings
 * - Block scope with async operations
 * - Comparison with var behavior
 */

// ❌ Problem with var
function simulateEventsVar() {
  console.log('=== Using var (incorrect) ===');

  for (var i = 1; i <= 3; i++) {
    setTimeout(() => {
      console.log(`Event ${i} executed`);
    }, i * 100);
  }
  // All callbacks log "Event 4" because var is function-scoped
}

// ✅ Solution with let
function simulateEventsLet() {
  console.log('=== Using let (correct) ===');

  for (let i = 1; i <= 3; i++) {
    setTimeout(() => {
      console.log(`Event ${i} executed`);
    }, i * 100);
  }
  // Each callback captures its own i value
}

// ✅ Alternative: Block scope with forEach
function simulateEventsForEach() {
  console.log('=== Using forEach (alternative) ===');

  [1, 2, 3].forEach(i => {
    setTimeout(() => {
      console.log(`Event ${i} executed`);
    }, i * 100);
  });
}

// Execute demonstrations
simulateEventsVar(); // Logs: Event 4, Event 4, Event 4
simulateEventsLet(); // Logs: Event 1, Event 2, Event 3
simulateEventsForEach(); // Logs: Event 1, Event 2, Event 3
```

---

### Example 3: Configuration Manager (Advanced)

**Problem:** Build a configuration system using const and block scope.

```javascript
/**
 * Example 3: Configuration Manager
 *
 * Demonstrates:
 * - const for immutable configuration
 * - Object.freeze for deep immutability
 * - Block scope for validation
 * - Destructuring with const
 */

const createConfig = (userConfig = {}) => {
  // Default configuration (immutable)
  const DEFAULT_CONFIG = Object.freeze({
    api: {
      baseURL: 'https://api.example.com',
      timeout: 5000,
      retries: 3
    },
    features: {
      darkMode: false,
      notifications: true
    }
  });

  // Validate configuration
  {
    const validKeys = Object.keys(DEFAULT_CONFIG);
    const userKeys = Object.keys(userConfig);

    for (const key of userKeys) {
      if (!validKeys.includes(key)) {
        throw new Error(`Invalid config key: ${key}`);
      }
    }
  }

  // Merge configurations
  const config = {
    ...DEFAULT_CONFIG,
    ...userConfig,
    api: {
      ...DEFAULT_CONFIG.api,
      ...userConfig.api
    },
    features: {
      ...DEFAULT_CONFIG.features,
      ...userConfig.features
    }
  };

  // Freeze final configuration
  return Object.freeze(config);
};

// Usage
const config = createConfig({
  api: {
    baseURL: 'https://custom-api.com'
  },
  features: {
    darkMode: true
  }
});

console.log(config.api.baseURL); // 'https://custom-api.com'
console.log(config.api.timeout); // 5000 (default)
console.log(config.features.darkMode); // true

// ❌ Cannot modify frozen config
// config.api.baseURL = 'hacked'; // No effect
// config.newKey = 'value'; // No effect

// ❌ Invalid keys throw errors
try {
  createConfig({ invalidKey: 'value' });
} catch (error) {
  console.error(error.message); // 'Invalid config key: invalidKey'
}
```

---

## Exercises

### Exercise 1: Block Scope Explorer (Easy)

Create a function that demonstrates block scope with nested blocks.

**Requirements:**
- Use three nested block scopes
- Declare variables with the same name in each scope
- Log values at each level
- Demonstrate variable shadowing

**Starter Code:**
```javascript
function explorBlockScope() {
  const value = 'outer';

  // TODO: Create nested blocks with shadowing
}
```

**Solution:** See `solutions/exercise-01-block-scope.js`

---

### Exercise 2: Loop Closure Fix (Medium)

Fix the loop closure problem without using let.

**Broken Code:**
```javascript
const buttons = [1, 2, 3, 4, 5];
const handlers = [];

for (var i = 0; i < buttons.length; i++) {
  handlers.push(function() {
    console.log('Button ' + i + ' clicked');
  });
}

handlers.forEach(h => h()); // All log "Button 5 clicked"
```

**Requirements:**
- Fix using IIFE
- Fix using .forEach()
- Fix using .map()
- Compare all approaches

**Solution:** See `solutions/exercise-02-loop-closure.js`

---

### Exercise 3: Const Mutations (Medium)

Create utility functions to work with const objects safely.

**Requirements:**
- Function to update nested object properties
- Function to deep clone objects
- Function to deep freeze objects
- Write tests for each function

**Example:**
```javascript
const user = {
  name: 'Alice',
  settings: {
    theme: 'dark'
  }
};

updateNested(user, 'settings.theme', 'light');
const cloned = deepClone(user);
const frozen = deepFreeze(user);
```

**Solution:** See `solutions/exercise-03-const-mutations.js`

---

### Exercise 4: TDZ Demonstrator (Hard)

Create examples that demonstrate TDZ in various contexts.

**Requirements:**
- Function parameters with TDZ
- Destructuring with TDZ
- Class fields with TDZ
- Default values with TDZ
- Explain each example with comments

**Solution:** See `solutions/exercise-04-tdz-demo.js`

---

### Exercise 5: Refactor Legacy Code (Hard)

Refactor the following legacy code to modern standards.

**Legacy Code:**
```javascript
var app = (function() {
  var config = {
    apiURL: 'https://api.example.com'
  };

  var users = [];

  var addUser = function(name) {
    var user = { id: users.length + 1, name: name };
    users.push(user);
    return user;
  };

  var getUsers = function() {
    return users;
  };

  return {
    addUser: addUser,
    getUsers: getUsers
  };
})();
```

**Requirements:**
- Remove all var declarations
- Replace IIFE with block scope
- Use arrow functions
- Use const/let appropriately
- Add proper JSDoc comments
- Write tests

**Solution:** See `solutions/exercise-05-refactor.js`

---

## Common Pitfalls

### Pitfall 1: Temporal Dead Zone Confusion

```javascript
// ❌ Common mistake
function example() {
  console.log(value); // ReferenceError: Cannot access 'value' before initialization
  let value = 42;
}

// ✅ Solution: Declare before use
function exampleFixed() {
  let value = 42;
  console.log(value); // 42
}
```

### Pitfall 2: const Doesn't Make Objects Immutable

```javascript
// ❌ Misconception
const obj = { count: 0 };
obj.count = 10; // This works! const only prevents reassignment

// ✅ True immutability
const frozen = Object.freeze({ count: 0 });
frozen.count = 10; // Silently fails (or throws in strict mode)
```

### Pitfall 3: Block Scope in Switch Statements

```javascript
// ❌ No block scope
switch (value) {
  case 'a':
    const x = 1;
    break;
  case 'b':
    const x = 2; // SyntaxError: Identifier 'x' has already been declared
    break;
}

// ✅ Create blocks
switch (value) {
  case 'a': {
    const x = 1;
    break;
  }
  case 'b': {
    const x = 2; // Different scope, no error
    break;
  }
}
```

### Pitfall 4: Loop Variables with var

```javascript
// ❌ All closures share same variable
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100); // 3, 3, 3
}

// ✅ Each closure gets own variable
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100); // 0, 1, 2
}
```

---

## Testing & Verification

### Test Template

```javascript
import { describe, it, expect, beforeEach } from 'vitest';

describe('Block Scope', () => {
  it('should confine let to block', () => {
    let outer = 'outer';

    {
      let inner = 'inner';
      expect(inner).toBe('inner');
    }

    expect(outer).toBe('outer');
    expect(() => inner).toThrow(); // inner not accessible
  });

  it('should allow variable shadowing', () => {
    const name = 'outer';

    {
      const name = 'inner';
      expect(name).toBe('inner');
    }

    expect(name).toBe('outer');
  });
});

describe('const Behavior', () => {
  it('should prevent reassignment', () => {
    const value = 42;
    expect(() => {
      value = 100; // This will be caught at parse time, not runtime
    }).toThrow();
  });

  it('should allow object mutation', () => {
    const obj = { count: 0 };
    obj.count = 10;
    expect(obj.count).toBe(10);
  });
});
```

---

## Summary & Next Steps

### Key Takeaways

1. **Always prefer `const` by default**, use `let` only when reassignment is needed, never use `var`
2. **Block scope** (with let/const) is more predictable than function scope (with var)
3. **Temporal Dead Zone** prevents accessing variables before initialization
4. **Hoisting** happens for all declarations, but initialization differs
5. **const prevents reassignment**, not mutation (use Object.freeze for immutability)
6. **Block scope in loops** creates separate bindings for each iteration
7. **Modern JavaScript** replaces IIFE with simple block scope

### Related Topics

- [Hoisting and TDZ Deep Dive](./13.Hoisting_And_TDZ.md) - Advanced hoisting concepts
- [Scope and Closures](../05.functions_and_scope/06.Scope_And_Closures.md) - Closure patterns
- [Arrow Functions](../09.arrow_functions/) - Modern function syntax
- [ES6 Features](../10.major_es6_features/) - Destructuring, spread, etc.

### Further Reading

- [MDN: let](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let)
- [MDN: const](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const)
- [MDN: Block Statement](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block)
- [MDN: Temporal Dead Zone](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#temporal_dead_zone_tdz)

---

**Last Updated:** 2025-11-22
**Curriculum Version:** 2.0.0
