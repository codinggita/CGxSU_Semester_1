# Hoisting and Temporal Dead Zone: A Deep Dive

**Difficulty:** Advanced
**Estimated Time:** 50-70 minutes
**Prerequisites:** Let/const fundamentals, functions, scope, execution contexts
**Target:** Node.js 18+ LTS, Modern Browsers (ES2021+)

---

## Learning Objectives

By the end of this lesson, you will be able to:

1. **Understand** JavaScript's two-phase execution model (creation and execution phases)
2. **Explain** hoisting mechanics for variables, functions, classes, and imports
3. **Master** the Temporal Dead Zone (TDZ) and its purpose in preventing bugs
4. **Distinguish** between hoisting behavior of var, let, const, function declarations, and expressions
5. **Debug** hoisting-related errors using execution context mental models
6. **Apply** hoisting knowledge to optimize code and avoid common pitfalls
7. **Answer** interview questions about JavaScript hoisting with confidence
8. **Analyze** complex scenarios involving nested scopes, closures, and hoisting

---

## Table of Contents

1. [Introduction](#introduction)
2. [JavaScript Execution Context](#javascript-execution-context)
3. [The Two-Phase Execution Model](#the-two-phase-execution-model)
4. [Variable Hoisting Deep Dive](#variable-hoisting-deep-dive)
5. [Function Hoisting](#function-hoisting)
6. [Class Hoisting](#class-hoisting)
7. [Import/Export Hoisting](#importexport-hoisting)
8. [Temporal Dead Zone Explained](#temporal-dead-zone-explained)
9. [Hoisting in Different Scopes](#hoisting-in-different-scopes)
10. [Common Hoisting Pitfalls](#common-hoisting-pitfalls)
11. [Worked Examples](#worked-examples)
12. [Exercises](#exercises)
13. [Interview Questions](#interview-questions)
14. [Testing & Debugging](#testing--debugging)
15. [Summary & Next Steps](#summary--next-steps)
16. [References](#references)

---

## Introduction

**Hoisting** is one of JavaScript's most misunderstood features. Many developers think hoisting "moves code to the top," but the reality is more nuanced: JavaScript registers declarations in memory before executing code, creating different initialization behaviors for var, let, const, functions, and classes.

### Why Hoisting Matters

Understanding hoisting is essential because:

- **Prevents bugs:** Know why variables are `undefined` vs throwing `ReferenceError`
- **Interview readiness:** Hoisting is a common interview topic
- **Mental model:** Understanding execution contexts improves debugging skills
- **Legacy code:** Read and maintain older codebases that use var and hoisting patterns
- **Modern patterns:** Understand why let/const prevent certain bugs

### Key Concepts

- **Creation phase:** When JavaScript scans and registers declarations
- **Execution phase:** When code actually runs line-by-line
- **Temporal Dead Zone (TDZ):** Period where let/const exist but are uninitialized
- **Scope chain:** How JavaScript resolves variable lookups
- **Hoisting precedence:** Order of priority when different declaration types conflict

---

## JavaScript Execution Context

### What is an Execution Context?

An **execution context** is the environment in which JavaScript code is executed. Every time a function is called or the script starts, a new execution context is created.

```javascript
// Global Execution Context
const globalVar = 'global';

function outer() {
  // Function Execution Context (outer)
  const outerVar = 'outer';

  function inner() {
    // Function Execution Context (inner)
    const innerVar = 'inner';
    console.log(globalVar, outerVar, innerVar);
  }

  inner();
}

outer();
```

### Components of Execution Context

Every execution context has:

1. **Variable Environment:** Stores var declarations, function declarations
2. **Lexical Environment:** Stores let/const declarations, outer scope reference
3. **this Binding:** Reference to the current object
4. **Scope Chain:** Link to outer environments for variable resolution

```javascript
// Simplified visualization
const executionContext = {
  variableEnvironment: {
    varDeclarations: { /* var variables */ },
    functionDeclarations: { /* functions */ }
  },
  lexicalEnvironment: {
    letConstDeclarations: { /* let/const variables */ },
    outerReference: null // Reference to parent scope
  },
  thisBinding: globalThis
};
```

### Execution Context Stack

JavaScript maintains a **call stack** of execution contexts:

```javascript
function first() {
  console.log('In first');
  second();
}

function second() {
  console.log('In second');
  third();
}

function third() {
  console.log('In third');
}

first();

/*
Call Stack Visualization:
1. [Global]
2. [Global, first]
3. [Global, first, second]
4. [Global, first, second, third]  <- Top of stack
5. [Global, first, second]         <- third returns
6. [Global, first]                 <- second returns
7. [Global]                        <- first returns
*/
```

---

## The Two-Phase Execution Model

JavaScript executes code in **two distinct phases**:

### Phase 1: Creation Phase (Compilation/Memory Phase)

During this phase, JavaScript:

1. **Scans the entire scope** (global or function)
2. **Registers all declarations** (variables, functions, classes)
3. **Allocates memory** for declarations
4. **Sets up scope chain** and outer references
5. **Does NOT execute any code**

```javascript
// What JavaScript "sees" during creation phase
function example() {
  // Creation Phase Actions:
  // 1. Register 'a' → initialize to undefined (var)
  // 2. Register 'b' → leave uninitialized (let)
  // 3. Register 'greet' → store entire function
  // 4. Register 'sayHi' → leave uninitialized (const)

  console.log(a); // Execution phase begins here
  var a = 10;

  console.log(b);
  let b = 20;

  greet();
  function greet() {
    console.log('Hello!');
  }

  sayHi();
  const sayHi = () => console.log('Hi!');
}
```

### Phase 2: Execution Phase

During this phase, JavaScript:

1. **Executes code line-by-line**
2. **Assigns values** to variables
3. **Calls functions**
4. **Evaluates expressions**
5. **Uses the memory** created in phase 1

```javascript
function demonstratePhases() {
  // CREATION PHASE (before execution):
  // - 'x' registered → undefined
  // - 'y' registered → uninitialized (TDZ)
  // - 'calculate' registered → function stored

  // EXECUTION PHASE:
  console.log(x); // undefined (hoisted and initialized)
  // console.log(y); // ReferenceError (hoisted but in TDZ)

  var x = 5;
  let y = 10;

  calculate(); // Works! Function declaration hoisted

  function calculate() {
    return x + y;
  }
}
```

### Visual Timeline

```
Time →

┌─────────────────────────────────────────────────────────┐
│ CREATION PHASE                                          │
├─────────────────────────────────────────────────────────┤
│ • Scan entire scope                                     │
│ • var x → memory allocated, set to undefined           │
│ • let y → memory allocated, uninitialized (TDZ)        │
│ • function declarations → fully available              │
│ • const z → memory allocated, uninitialized (TDZ)      │
└─────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────┐
│ EXECUTION PHASE                                         │
├─────────────────────────────────────────────────────────┤
│ • Execute line 1                                        │
│ • Execute line 2                                        │
│ • Assign values when encountered                       │
│ • TDZ ends when let/const is initialized               │
│ • Call functions as encountered                        │
└─────────────────────────────────────────────────────────┘
```

---

## Variable Hoisting Deep Dive

### var Hoisting (Legacy)

`var` declarations are hoisted and **initialized to `undefined`**:

```javascript
console.log(x); // undefined (not ReferenceError!)
var x = 10;
console.log(x); // 10

// What JavaScript executes:
var x; // Hoisted to top, initialized to undefined
console.log(x); // undefined
x = 10;
console.log(x); // 10
```

### let Hoisting (Modern)

`let` declarations are hoisted but **NOT initialized** (enter TDZ):

```javascript
// console.log(y); // ReferenceError: Cannot access 'y' before initialization
let y = 20;
console.log(y); // 20

// What JavaScript does:
// let y; // Hoisted but uninitialized (TDZ)
// console.log(y); // TDZ error!
// y = 20; // TDZ ends here
// console.log(y); // 20
```

### const Hoisting (Modern)

`const` behaves like `let` but requires initialization:

```javascript
// console.log(z); // ReferenceError: Cannot access 'z' before initialization
const z = 30;
console.log(z); // 30

// const must be initialized immediately
// const uninitialized; // SyntaxError: Missing initializer
```

### Hoisting in Nested Scopes

```javascript
const outer = 'outer';

function test() {
  // CREATION PHASE for test():
  // - 'outer' → not hoisted (from parent scope)
  // - 'inner' → hoisted, uninitialized (TDZ)

  console.log(outer); // 'outer' (from parent scope)
  // console.log(inner); // ReferenceError (TDZ)

  let inner = 'inner';
  console.log(inner); // 'inner'
}

test();
```

### Variable Shadowing and Hoisting

```javascript
let x = 'global';

function shadow() {
  // CREATION PHASE:
  // - 'x' registered in local scope → TDZ

  // console.log(x); // ReferenceError: TDZ!
  // Even though global 'x' exists, local 'x' shadows it

  let x = 'local';
  console.log(x); // 'local'
}

shadow();
console.log(x); // 'global'
```

---

## Function Hoisting

### Function Declarations (Fully Hoisted)

Function declarations are **fully hoisted** with their implementation:

```javascript
greet(); // 'Hello!' (works before declaration)

function greet() {
  console.log('Hello!');
}

greet(); // 'Hello!' (works after declaration too)
```

**Internal behavior:**

```javascript
// CREATION PHASE:
// function greet() { ... } → Fully stored in memory

// EXECUTION PHASE:
greet(); // Works immediately
```

### Function Expressions (Variable Hoisting Rules)

Function expressions follow the hoisting rules of their variable declaration:

```javascript
// ❌ var function expression
console.log(typeof greetVar); // 'undefined'
// greetVar(); // TypeError: greetVar is not a function

var greetVar = function() {
  console.log('Hello from var');
};

// ✅ let/const function expression
// console.log(greetLet); // ReferenceError: TDZ
// greetLet(); // ReferenceError: TDZ

const greetLet = function() {
  console.log('Hello from let');
};
```

**Internal behavior:**

```javascript
// CREATION PHASE:
// var greetVar → undefined
// const greetLet → uninitialized (TDZ)

// EXECUTION PHASE:
// greetVar is undefined, cannot call
// greetLet is in TDZ, cannot access
```

### Arrow Functions (Same as Function Expressions)

```javascript
// ❌ Cannot use before declaration
// sayHi(); // ReferenceError: TDZ

const sayHi = () => {
  console.log('Hi!');
};

sayHi(); // ✅ Works after declaration
```

### Named vs Anonymous Function Expressions

```javascript
// Named function expression
const factorial = function fact(n) {
  if (n <= 1) return 1;
  return n * fact(n - 1); // Can reference itself
};

factorial(5); // 120
// fact(5); // ReferenceError: fact is not defined (only available inside)

// Anonymous function expression
const anonymous = function(n) {
  // Cannot reference itself by name
  return n * 2;
};
```

### Function Hoisting Priority

Function declarations take precedence over variable declarations:

```javascript
console.log(typeof foo); // 'function' (not 'undefined')

var foo = 'variable';

function foo() {
  return 'function';
}

console.log(typeof foo); // 'string' (variable assignment happened)

// What JavaScript executes:
function foo() { return 'function'; } // Hoisted first
var foo; // Hoisted but doesn't overwrite function
console.log(typeof foo); // 'function'
foo = 'variable'; // Assignment happens here
console.log(typeof foo); // 'string'
```

---

## Class Hoisting

### Classes Are Hoisted But In TDZ

Classes are hoisted like `let`/`const` (enter TDZ):

```javascript
// ❌ Cannot use before declaration
// const instance = new MyClass(); // ReferenceError: TDZ

class MyClass {
  constructor(value) {
    this.value = value;
  }

  getValue() {
    return this.value;
  }
}

const instance = new MyClass(42); // ✅ Works after declaration
console.log(instance.getValue()); // 42
```

### Class Expressions

```javascript
// ❌ TDZ applies
// const obj = new MyClass(); // ReferenceError

const MyClass = class {
  constructor() {
    this.created = new Date();
  }
};

const obj = new MyClass(); // ✅ Works
```

### Class vs Function Constructor Hoisting

```javascript
// ✅ Function constructor (fully hoisted)
const obj1 = new FunctionConstructor('value');

function FunctionConstructor(value) {
  this.value = value;
}

// ❌ Class (TDZ)
// const obj2 = new ClassConstructor('value'); // ReferenceError

class ClassConstructor {
  constructor(value) {
    this.value = value;
  }
}
```

---

## Import/Export Hoisting

### ES6 Module Imports Are Hoisted

Module imports are hoisted to the top and executed first:

```javascript
// ✅ This works! Imports are hoisted
greet();

import { greet } from './utils.js';

// What actually happens:
// 1. import { greet } from './utils.js'; // Hoisted to top
// 2. greet(); // Then executed
```

### Import Hoisting Behavior

```javascript
// All imports are processed before any code runs
console.log(add(2, 3)); // 5 (works!)

import { add } from './math.js';
import { subtract } from './math.js';
import * as utils from './utils.js';

// Imports are always hoisted to the very top
```

### Dynamic Imports Are NOT Hoisted

```javascript
// ❌ Dynamic imports are promises, not hoisted
// const result = add(2, 3); // ReferenceError

const math = await import('./math.js');
const result = math.add(2, 3); // ✅ Works after await
```

### Export Hoisting

```javascript
// exports.js

// ✅ Export hoisting works
export { greet }; // Can export before declaration

function greet() {
  console.log('Hello!');
}

// Also works
export function sayHi() {
  console.log('Hi!');
}
```

---

## Temporal Dead Zone Explained

### What Exactly Is TDZ?

The **Temporal Dead Zone** is the period from:
- **Start:** Beginning of the scope
- **End:** Line where variable is initialized

```javascript
{
  // TDZ starts for 'value'
  // ↓
  // console.log(value); // ReferenceError: TDZ
  // ↓
  let value = 42; // ← TDZ ends here
  // ↓
  console.log(value); // 42 (safe to access)
}
```

### Why TDZ Exists

TDZ prevents accessing variables before they're properly initialized:

```javascript
// ❌ Bug with var (no TDZ)
function calculateTotal() {
  console.log(total); // undefined (silent bug!)
  // ... 100 lines of code ...
  var total = items.reduce((sum, item) => sum + item.price, 0);
  return total;
}

// ✅ Bug caught with let (TDZ)
function calculateTotalSafe() {
  // console.log(total); // ReferenceError (caught immediately!)
  // ... 100 lines of code ...
  let total = items.reduce((sum, item) => sum + item.price, 0);
  return total;
}
```

### TDZ in Different Contexts

**1. Basic Block:**

```javascript
{
  // TDZ starts
  // console.log(x); // ReferenceError
  let x = 10; // TDZ ends
}
```

**2. Function Parameters:**

```javascript
function example(a = b, b = 2) {
  // TDZ: 'b' accessed before initialization
  return a + b;
}

// example(); // ReferenceError: Cannot access 'b' before initialization

// ✅ Fixed:
function exampleFixed(a = 1, b = 2) {
  return a + b;
}
```

**3. Destructuring:**

```javascript
// ❌ TDZ in destructuring
const { x = y, y = 2 } = {}; // ReferenceError

// ✅ Fixed:
const { y = 2, x = y } = {}; // Works: y initialized first
```

**4. Default Parameters:**

```javascript
// ❌ TDZ
function test(a = b, b = a) {} // ReferenceError

// ✅ Fixed:
function testFixed(a = 1, b = a) {} // Works
```

**5. Class Fields:**

```javascript
class MyClass {
  // ❌ TDZ
  // field1 = this.field2; // ReferenceError
  field2 = 42;

  constructor() {
    // ✅ Works in constructor (after creation phase)
    this.field1 = this.field2;
  }
}
```

### TDZ vs ReferenceError

**TDZ ReferenceError:**
- Variable exists in scope
- Variable accessed before initialization
- Message: "Cannot access 'x' before initialization"

```javascript
{
  // console.log(x); // TDZ ReferenceError
  let x = 10;
}
```

**Normal ReferenceError:**
- Variable doesn't exist in any scope
- Message: "x is not defined"

```javascript
console.log(nonExistent); // ReferenceError: nonExistent is not defined
```

### TDZ Duration

```javascript
function demonstrateTDZDuration() {
  // TDZ for 'result' starts here ←
  const x = 10;
  const y = 20;

  // Still in TDZ for 'result'
  if (x > 5) {
    console.log('x is large');
  }

  // Still in TDZ for 'result'
  for (let i = 0; i < 5; i++) {
    console.log(i);
  }

  // TDZ for 'result' ends here ↓
  let result = x + y;
  // Now safe to use 'result'
  console.log(result); // 30
}
```

---

## Hoisting in Different Scopes

### Global Scope Hoisting

```javascript
// CREATION PHASE:
// - 'globalVar' → undefined
// - 'globalLet' → TDZ
// - 'globalFunc' → fully hoisted

console.log(globalVar); // undefined
// console.log(globalLet); // ReferenceError: TDZ
globalFunc(); // 'Hello!' (works)

var globalVar = 'var';
let globalLet = 'let';

function globalFunc() {
  console.log('Hello!');
}
```

### Function Scope Hoisting

```javascript
function outer() {
  // CREATION PHASE for outer():
  // - 'outerVar' → undefined
  // - 'outerLet' → TDZ
  // - 'inner' → fully hoisted

  console.log(outerVar); // undefined
  // console.log(outerLet); // ReferenceError: TDZ
  inner(); // 'Inner called' (works)

  var outerVar = 'outer var';
  let outerLet = 'outer let';

  function inner() {
    console.log('Inner called');
  }
}
```

### Block Scope Hoisting

```javascript
{
  // CREATION PHASE for this block:
  // - 'blockVar' → hoisted to function scope (not block!)
  // - 'blockLet' → TDZ in this block
  // - 'blockConst' → TDZ in this block

  console.log(blockVar); // undefined
  // console.log(blockLet); // ReferenceError: TDZ

  var blockVar = 'leaks out';
  let blockLet = 'stays in block';
  const blockConst = 'stays in block';
}

console.log(blockVar); // 'leaks out' (var ignores block scope)
// console.log(blockLet); // ReferenceError: not defined
// console.log(blockConst); // ReferenceError: not defined
```

### Nested Scope Hoisting

```javascript
function level1() {
  // CREATION PHASE level1:
  // - 'a' → undefined

  console.log(a); // undefined

  var a = 1;

  function level2() {
    // CREATION PHASE level2:
    // - 'b' → undefined
    // - Can access 'a' from parent scope

    console.log(a); // 1 (from parent scope)
    console.log(b); // undefined

    var b = 2;

    function level3() {
      // CREATION PHASE level3:
      // - 'c' → TDZ
      // - Can access 'a' and 'b' from parent scopes

      console.log(a); // 1
      console.log(b); // 2
      // console.log(c); // ReferenceError: TDZ

      let c = 3;
    }

    level3();
  }

  level2();
}
```

---

## Common Hoisting Pitfalls

### Pitfall 1: Accidental Global Variables

```javascript
function createBug() {
  // ❌ Forgot 'let/const/var'
  count = 10; // Creates global variable!
}

createBug();
console.log(count); // 10 (leaked to global scope)

// ✅ Solution: Always use strict mode
'use strict';
function noGlobals() {
  // count = 10; // ReferenceError in strict mode
  let count = 10;
}
```

### Pitfall 2: Loop Variable Hoisting

```javascript
// ❌ var leaks loop variable
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);
}
// Prints: 3, 3, 3

console.log(i); // 3 (leaked outside loop!)

// ✅ let creates block scope
for (let j = 0; j < 3; j++) {
  setTimeout(() => console.log(j), 100);
}
// Prints: 0, 1, 2

// console.log(j); // ReferenceError
```

### Pitfall 3: Function vs Variable Hoisting Confusion

```javascript
// What gets logged?
console.log(typeof foo); // ???

var foo = 'variable';

function foo() {
  return 'function';
}

// Answer: 'function'
// Function declaration hoisted first, takes precedence
```

### Pitfall 4: Conditional Function Declarations

```javascript
// ❌ Inconsistent behavior across environments
if (true) {
  function conditionalFunc() {
    return 'declared in if';
  }
}

// conditionalFunc(); // May or may not work (non-standard)

// ✅ Use function expressions instead
let conditionalFunc;
if (true) {
  conditionalFunc = function() {
    return 'declared in if';
  };
}
```

### Pitfall 5: Hoisting with Same Names

```javascript
var value = 1;

function test() {
  console.log(value); // ???
  var value = 2;
  console.log(value); // ???
}

test();

// Answer:
// undefined (local 'value' hoisted, shadows global)
// 2 (assigned)
```

---

## Worked Examples

### Example 1: Hoisting Analyzer (Intermediate)

**Problem:** Create a function that demonstrates all hoisting behaviors.

```javascript
/**
 * Example 1: Comprehensive Hoisting Demonstration
 *
 * Demonstrates:
 * - var hoisting with undefined initialization
 * - let/const TDZ
 * - Function declaration hoisting
 * - Function expression hoisting
 * - Execution phase behavior
 */

function demonstrateHoisting() {
  console.log('=== HOISTING DEMONSTRATION ===\n');

  // 1. var hoisting
  console.log('1. var variable:', varVariable); // undefined
  var varVariable = 'var value';
  console.log('   After init:', varVariable); // 'var value'

  // 2. let TDZ
  console.log('\n2. let variable:');
  try {
    console.log(letVariable);
  } catch (e) {
    console.log('   TDZ Error:', e.message);
  }
  let letVariable = 'let value';
  console.log('   After init:', letVariable); // 'let value'

  // 3. const TDZ
  console.log('\n3. const variable:');
  try {
    console.log(constVariable);
  } catch (e) {
    console.log('   TDZ Error:', e.message);
  }
  const constVariable = 'const value';
  console.log('   After init:', constVariable); // 'const value'

  // 4. Function declaration (fully hoisted)
  console.log('\n4. Function declaration:');
  console.log('   Before declaration:', declaredFunc()); // Works!

  function declaredFunc() {
    return 'I am hoisted!';
  }

  // 5. Function expression (follows var rules)
  console.log('\n5. Function expression (var):');
  console.log('   Type before init:', typeof varFunc); // 'undefined'
  var varFunc = function() {
    return 'var function';
  };
  console.log('   After init:', varFunc()); // Works

  // 6. Arrow function (follows const rules)
  console.log('\n6. Arrow function (const):');
  try {
    constFunc();
  } catch (e) {
    console.log('   TDZ Error:', e.message);
  }
  const constFunc = () => 'arrow function';
  console.log('   After init:', constFunc()); // Works
}

demonstrateHoisting();
```

---

### Example 2: TDZ Visualizer (Advanced)

**Problem:** Create a visualization tool that shows TDZ duration.

```javascript
/**
 * Example 2: TDZ Timeline Visualizer
 *
 * Demonstrates:
 * - TDZ start and end points
 * - Multiple variables with different TDZ durations
 * - Safe access points
 */

function visualizeTDZ() {
  const timeline = [];

  function log(message, access = null) {
    timeline.push({ message, access, line: new Error().stack.split('\n')[2] });
  }

  log('=== TDZ TIMELINE ===');

  // TDZ starts for 'early', 'middle', 'late'
  log('Scope entered - TDZ starts for all let/const variables');

  log('\nTrying to access "early" (should fail):');
  try {
    log('early =', early);
  } catch (e) {
    log(`✗ ${e.message}`);
  }

  // First variable initialized
  log('\nInitializing "early":');
  let early = 'early value';
  log(`✓ early = "${early}" (TDZ ended for "early")`);

  // Some code between declarations
  log('\nExecuting some code...');
  const calculation = 10 + 20;
  log(`Calculation result: ${calculation}`);

  log('\nTrying to access "middle" (should fail):');
  try {
    log('middle =', middle);
  } catch (e) {
    log(`✗ ${e.message}`);
  }

  // Second variable initialized
  log('\nInitializing "middle":');
  const middle = 'middle value';
  log(`✓ middle = "${middle}" (TDZ ended for "middle")`);

  // More code
  log('\nExecuting more code...');
  for (let i = 0; i < 2; i++) {
    log(`Loop iteration ${i}`);
  }

  log('\nTrying to access "late" (should fail):');
  try {
    log('late =', late);
  } catch (e) {
    log(`✗ ${e.message}`);
  }

  // Final variable initialized
  log('\nInitializing "late":');
  let late = 'late value';
  log(`✓ late = "${late}" (TDZ ended for "late")`);

  log('\n=== ALL VARIABLES NOW SAFE TO ACCESS ===');
  log(`early: "${early}", middle: "${middle}", late: "${late}"`);

  // Print timeline
  console.log('\n--- TIMELINE ---');
  timeline.forEach(entry => console.log(entry.message));
}

visualizeTDZ();
```

---

### Example 3: Interview Question Solver (Advanced)

**Problem:** Common interview questions about hoisting.

```javascript
/**
 * Example 3: Hoisting Interview Questions
 *
 * Demonstrates:
 * - Common interview scenarios
 * - Tricky hoisting behaviors
 * - Explanation of each question
 */

console.log('=== INTERVIEW QUESTIONS ===\n');

// Question 1: What gets logged?
console.log('Question 1:');
console.log(typeof foo);
console.log(typeof bar);

var foo = 'hello';
let bar = 'world';

console.log('Answer: undefined, then ReferenceError (bar in TDZ)\n');

// Question 2: What gets logged?
console.log('Question 2:');
var x = 1;

function test() {
  console.log(x);
  var x = 2;
}

test();
console.log('Answer: undefined (local x hoisted, shadows global)\n');

// Question 3: What gets logged?
console.log('Question 3:');

function question3() {
  console.log(typeof myFunc);

  var myFunc = function() {
    return 'expression';
  };

  function myFunc() {
    return 'declaration';
  }

  console.log(typeof myFunc);
}

question3();
console.log('Answer: function (declaration hoisted), then function (but now the expression)\n');

// Question 4: Fix the bug
console.log('Question 4: Fix the closure bug');

console.log('Broken version:');
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log('Broken:', i), 0);
}

setTimeout(() => {
  console.log('\nFixed version:');
  for (let j = 0; j < 3; j++) {
    setTimeout(() => console.log('Fixed:', j), 0);
  }
}, 100);

// Question 5: Predict the output
console.log('\nQuestion 5:');

function hoistingChallenge() {
  var a = 1;

  function inner() {
    console.log(a);
    var a = 2;
    console.log(a);
  }

  inner();
  console.log(a);
}

hoistingChallenge();
console.log('Answer: undefined, 2, 1');
```

---

## Exercises

### Exercise 1: Hoisting Detective (Easy)

Predict the output of the following code without running it:

```javascript
console.log(a);
console.log(b);
console.log(c);

var a = 1;
let b = 2;
const c = 3;

function test() {
  console.log(a);
  console.log(b);

  var a = 10;
  let b = 20;
}

test();
```

**Solution:** See `solutions/exercise-01-hoisting-detective.js`

---

### Exercise 2: TDZ Explorer (Medium)

Create examples demonstrating TDZ in:
1. Function parameters
2. Destructuring assignments
3. Class fields
4. Default parameter values
5. Nested blocks

**Solution:** See `solutions/exercise-02-tdz-explorer.js`

---

### Exercise 3: Hoisting Refactor (Medium)

Refactor this code to avoid hoisting issues:

```javascript
function processData(items) {
  console.log(result);

  for (var i = 0; i < items.length; i++) {
    var item = items[i];

    if (shouldProcess(item)) {
      var processed = transform(item);
      results.push(processed);
    }
  }

  var result = results.join(', ');
  return result;
}

function shouldProcess(item) {
  return item.active;
}

function transform(item) {
  return item.value * 2;
}

var results = [];
```

**Solution:** See `solutions/exercise-03-hoisting-refactor.js`

---

### Exercise 4: Execution Context Simulator (Hard)

Create a function that simulates JavaScript's execution context and hoisting:

```javascript
function simulateExecution(code) {
  // Parse code string
  // Identify declarations
  // Simulate creation phase
  // Simulate execution phase
  // Return step-by-step timeline
}

const code = `
  console.log(x);
  var x = 10;
  console.log(x);
`;

const timeline = simulateExecution(code);
console.log(timeline);
```

**Solution:** See `solutions/exercise-04-execution-simulator.js`

---

### Exercise 5: Hoisting Quiz Builder (Hard)

Build an interactive quiz that tests hoisting knowledge:

**Requirements:**
- Generate random hoisting scenarios
- Track TDZ vs undefined vs ReferenceError
- Provide explanations for each answer
- Score the user's understanding

**Solution:** See `solutions/exercise-05-hoisting-quiz.js`

---

## Interview Questions

### Common Interview Questions

**Q1: What is hoisting in JavaScript?**

**A:** Hoisting is JavaScript's behavior of moving variable and function declarations to the top of their scope during the creation phase, before code execution. However, only declarations are hoisted, not initializations.

**Q2: What's the difference between how `var`, `let`, and `const` are hoisted?**

**A:**
- `var`: Hoisted and initialized with `undefined`
- `let`: Hoisted but not initialized (TDZ)
- `const`: Hoisted but not initialized (TDZ), must be initialized at declaration

**Q3: What is the Temporal Dead Zone?**

**A:** The TDZ is the period between entering a scope and the point where a `let`/`const` variable is initialized. Accessing the variable during TDZ throws a ReferenceError.

**Q4: Why does this code throw an error?**

```javascript
function test() {
  console.log(x);
  let x = 10;
}
test();
```

**A:** The variable `x` is hoisted but enters the TDZ. Accessing it before initialization throws: `ReferenceError: Cannot access 'x' before initialization`.

**Q5: What gets logged?**

```javascript
var x = 10;

function foo() {
  console.log(x);
  var x = 20;
}

foo();
```

**A:** `undefined`. The local `var x` is hoisted to the top of `foo()`, shadowing the global `x`. It's hoisted but not yet assigned the value 20.

---

## Testing & Debugging

### Test Template

```javascript
import { describe, it, expect } from 'vitest';

describe('Hoisting Behavior', () => {
  it('should hoist var with undefined', () => {
    let result;

    function test() {
      result = x;
      var x = 10;
    }

    test();
    expect(result).toBe(undefined);
  });

  it('should throw TDZ error for let', () => {
    function test() {
      return y; // TDZ
      let y = 10;
    }

    expect(test).toThrow(/Cannot access 'y' before initialization/);
  });

  it('should fully hoist function declarations', () => {
    function test() {
      return foo();

      function foo() {
        return 'hoisted';
      }
    }

    expect(test()).toBe('hoisted');
  });
});
```

### Debugging Hoisting Issues

```javascript
// Use debugger to inspect hoisting
function debugHoisting() {
  debugger; // Pause here - check variables in scope

  var hoistedVar;
  let hoistedLet;
  const hoistedConst = 42;

  debugger; // Pause here - compare variables

  hoistedVar = 'initialized';
  hoistedLet = 'initialized';

  debugger; // Pause here - see final state
}
```

---

## Summary & Next Steps

### Key Takeaways

1. **Two-phase execution:** Creation phase (hoisting) and execution phase
2. **var hoisting:** Hoisted and initialized with `undefined`
3. **let/const hoisting:** Hoisted but uninitialized (TDZ)
4. **Function declarations:** Fully hoisted with implementation
5. **Function expressions:** Follow variable hoisting rules
6. **Classes:** Hoisted but in TDZ
7. **TDZ prevents bugs:** Catches variable usage before initialization
8. **Best practice:** Use `const` by default, avoid relying on hoisting

### Related Topics

- [Let, Const, and Block Scope](./12.Let_Const_And_Block_Scope.md)
- [Scope and Closures](../05.functions_and_scope/06.Scope_And_Closures.md)
- [Execution Contexts](../advanced/execution-contexts.md)

### Further Reading

- [MDN: Hoisting](https://developer.mozilla.org/en-US/docs/Glossary/Hoisting)
- [MDN: Temporal Dead Zone](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#temporal_dead_zone_tdz)
- [ECMAScript Specification](https://tc39.es/ecma262/)

---

**Last Updated:** 2025-11-22
**Curriculum Version:** 2.0.0
