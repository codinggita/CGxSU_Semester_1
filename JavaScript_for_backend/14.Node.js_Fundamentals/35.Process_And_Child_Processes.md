# Process and Child Processes

**Difficulty:** Advanced
**Estimated Time:** 100-120 minutes
**Prerequisites:** Node.js fundamentals, streams, file system, async programming
**Target:** Node.js 18+ LTS

---

## Learning Objectives

By the end of this lesson, you will be able to:

1. Understand the process object and its properties
2. Work with command-line arguments (process.argv)
3. Manage environment variables (.env files)
4. Create and manage child processes (spawn, exec, fork)
5. Use the cluster module for multi-core utilization
6. Implement worker threads for CPU-intensive tasks
7. Handle process signals and graceful shutdown
8. Monitor process health and performance
9. Implement inter-process communication (IPC)
10. Build production-ready process management systems

---

## Table of Contents

1. [Introduction](#introduction)
2. [The Process Object](#the-process-object)
3. [Command-Line Arguments](#command-line-arguments)
4. [Environment Variables](#environment-variables)
5. [Child Processes](#child-processes)
6. [Cluster Module](#cluster-module)
7. [Worker Threads](#worker-threads)
8. [Process Signals](#process-signals)
9. [Process Management](#process-management)
10. [Inter-Process Communication](#inter-process-communication)
11. [Worked Examples](#worked-examples)
12. [Exercises](#exercises)
13. [Testing & Verification](#testing--verification)
14. [Best Practices](#best-practices)
15. [Common Pitfalls](#common-pitfalls)
16. [Performance Considerations](#performance-considerations)
17. [Summary & Next Steps](#summary--next-steps)
18. [References](#references)

---

## Introduction

The **process** object is a global object that provides information about and control over the current Node.js process. **Child processes** enable Node.js to execute system commands and run external programs.

**Why Process Management Matters:**

- **Multi-core Utilization:** Use all CPU cores
- **Scalability:** Handle more concurrent requests
- **Isolation:** Separate concerns and recover from crashes
- **Performance:** Parallel processing of CPU-intensive tasks
- **System Integration:** Execute shell commands and scripts

**Real-World Applications:**

- **Load Balancing:** Distribute requests across cores
- **Background Jobs:** Process tasks asynchronously
- **CLI Tools:** Build command-line applications
- **Build Systems:** Execute compilation and bundling
- **Monitoring:** Track application health

---

## The Process Object

### Process Properties

```javascript
/**
 * Essential process object properties
 */

// Version information
console.log('Node version:', process.version);           // v18.17.0
console.log('Versions:', process.versions);              // { node, v8, openssl, etc. }

// Platform information
console.log('Platform:', process.platform);              // linux, darwin, win32
console.log('Architecture:', process.arch);              // x64, arm64
console.log('Operating System:', process.platform);

// Process IDs
console.log('Process ID:', process.pid);                 // Current process ID
console.log('Parent PID:', process.ppid);                // Parent process ID

// Current working directory
console.log('CWD:', process.cwd());                      // /home/user/project

// Change working directory
process.chdir('/tmp');
console.log('New CWD:', process.cwd());                  // /tmp

// Execution path
console.log('Node path:', process.execPath);             // /usr/bin/node
console.log('Executable:', process.argv[0]);             // /usr/bin/node

// Memory usage
const memUsage = process.memoryUsage();
console.log('Memory Usage:', {
  rss: `${(memUsage.rss / 1024 / 1024).toFixed(2)} MB`,           // Resident Set Size
  heapTotal: `${(memUsage.heapTotal / 1024 / 1024).toFixed(2)} MB`,
  heapUsed: `${(memUsage.heapUsed / 1024 / 1024).toFixed(2)} MB`,
  external: `${(memUsage.external / 1024 / 1024).toFixed(2)} MB`
});

// CPU usage
const cpuUsage = process.cpuUsage();
console.log('CPU Usage:', {
  user: cpuUsage.user,      // microseconds
  system: cpuUsage.system   // microseconds
});

// Uptime
console.log('Uptime:', process.uptime(), 'seconds');     // Time since process started

// Resource usage (Unix)
if (process.getrusage) {
  console.log('Resource usage:', process.getrusage());
}

// Standard streams
process.stdin;   // Readable stream
process.stdout;  // Writable stream
process.stderr;  // Writable stream
```

### Process Methods

```javascript
/**
 * Process methods
 */

// Exit the process
// process.exit(0);   // Success
// process.exit(1);   // Failure

// Abort the process (generates core dump)
// process.abort();

// Send signal to process
// process.kill(process.pid, 'SIGTERM');

// Set/get user ID (Unix)
if (process.getuid) {
  console.log('User ID:', process.getuid());
  console.log('Effective UID:', process.geteuid());
}

// Set/get group ID (Unix)
if (process.getgid) {
  console.log('Group ID:', process.getgid());
  console.log('Effective GID:', process.getegid());
}

// Get/set process priority
console.log('Priority:', process.priority);
// process.priority = 10;  // Set nice value

// Get high-resolution time
const start = process.hrtime.bigint();
// ... do something ...
const end = process.hrtime.bigint();
console.log(`Execution time: ${end - start} nanoseconds`);

// Next tick (microtask queue)
process.nextTick(() => {
  console.log('Executed on next tick');
});

console.log('Synchronous code');
// Output:
// Synchronous code
// Executed on next tick
```

---

## Command-Line Arguments

### process.argv

```javascript
/**
 * Command-line arguments
 */

// node app.js --port=3000 --env=production

console.log('All arguments:', process.argv);
/**
 * [
 *   '/usr/bin/node',           // Node executable
 *   '/path/to/app.js',         // Script path
 *   '--port=3000',             // User argument
 *   '--env=production'         // User argument
 * ]
 */

// Skip node and script paths
const args = process.argv.slice(2);
console.log('User arguments:', args);  // ['--port=3000', '--env=production']

// Parse arguments
function parseArgs(args) {
  const parsed = {};

  for (const arg of args) {
    if (arg.startsWith('--')) {
      const [key, value] = arg.slice(2).split('=');
      parsed[key] = value || true;
    } else if (arg.startsWith('-')) {
      parsed[arg.slice(1)] = true;
    }
  }

  return parsed;
}

const options = parseArgs(process.argv.slice(2));
console.log('Parsed options:', options);
// { port: '3000', env: 'production' }

// Using a library (yargs)
// npm install yargs
const yargs = require('yargs/yargs');
const { hideBin } = require('yargs/helpers');

const argv = yargs(hideBin(process.argv))
  .option('port', {
    alias: 'p',
    type: 'number',
    description: 'Port to run server on',
    default: 3000
  })
  .option('env', {
    alias: 'e',
    type: 'string',
    description: 'Environment',
    choices: ['development', 'staging', 'production'],
    default: 'development'
  })
  .argv;

console.log('Port:', argv.port);
console.log('Environment:', argv.env);

// Run with: node app.js --port 8080 --env production
```

### Building CLI Applications

```javascript
/**
 * cli.js - Simple CLI application
 */

#!/usr/bin/env node

const args = process.argv.slice(2);
const command = args[0];

function showHelp() {
  console.log(`
Usage: mycli <command> [options]

Commands:
  help              Show this help message
  version           Show version
  create <name>     Create new project
  build             Build project
  test              Run tests

Options:
  --verbose, -v     Verbose output
  --help, -h        Show help
  `);
}

function showVersion() {
  const pkg = require('./package.json');
  console.log(`Version: ${pkg.version}`);
}

function createProject(name) {
  console.log(`Creating project: ${name}`);
  // Project creation logic
}

function build() {
  console.log('Building project...');
  // Build logic
}

function runTests() {
  console.log('Running tests...');
  // Test logic
}

// Command routing
switch (command) {
  case 'help':
  case '--help':
  case '-h':
    showHelp();
    break;

  case 'version':
  case '--version':
  case '-v':
    showVersion();
    break;

  case 'create':
    const name = args[1];
    if (!name) {
      console.error('Error: Project name required');
      process.exit(1);
    }
    createProject(name);
    break;

  case 'build':
    build();
    break;

  case 'test':
    runTests();
    break;

  default:
    console.error(`Unknown command: ${command}`);
    showHelp();
    process.exit(1);
}

// Make executable: chmod +x cli.js
// Run: ./cli.js create my-project
```

---

## Environment Variables

### Using Environment Variables

```javascript
/**
 * Working with environment variables
 */

// Access environment variables
console.log('Node environment:', process.env.NODE_ENV);
console.log('Path:', process.env.PATH);
console.log('Home:', process.env.HOME);

// Set environment variable
process.env.MY_VAR = 'my-value';
console.log('My var:', process.env.MY_VAR);

// Check if variable exists
if (process.env.API_KEY) {
  console.log('API key configured');
} else {
  console.error('API key missing!');
  process.exit(1);
}

// Default values
const port = process.env.PORT || 3000;
const dbUrl = process.env.DB_URL || 'mongodb://localhost/myapp';

// Type conversion
const timeout = parseInt(process.env.TIMEOUT) || 5000;
const debug = process.env.DEBUG === 'true';
const maxConnections = Number(process.env.MAX_CONNECTIONS) || 100;
```

### .env Files

```javascript
/**
 * Using .env files with dotenv
 */

// Install: npm install dotenv

// .env file
/**
 * NODE_ENV=development
 * PORT=3000
 * DB_URL=mongodb://localhost/myapp
 * API_KEY=secret123
 * DEBUG=true
 */

// Load .env file
require('dotenv').config();

console.log('Environment:', process.env.NODE_ENV);
console.log('Port:', process.env.PORT);
console.log('Database:', process.env.DB_URL);

// Custom .env path
require('dotenv').config({ path: '/custom/path/.env' });

// Multiple environments
const envFile = process.env.NODE_ENV === 'production'
  ? '.env.production'
  : '.env.development';

require('dotenv').config({ path: envFile });

// Validate required environment variables
function validateEnv() {
  const required = ['NODE_ENV', 'DB_URL', 'API_KEY'];

  const missing = required.filter(key => !process.env[key]);

  if (missing.length > 0) {
    console.error('Missing required environment variables:');
    missing.forEach(key => console.error(`  - ${key}`));
    process.exit(1);
  }
}

validateEnv();
```

### Configuration Management

```javascript
/**
 * config/index.js - Configuration management
 */

require('dotenv').config();

const config = {
  env: process.env.NODE_ENV || 'development',
  
  server: {
    port: parseInt(process.env.PORT) || 3000,
    host: process.env.HOST || 'localhost'
  },
  
  database: {
    url: process.env.DB_URL || 'mongodb://localhost/myapp',
    poolSize: parseInt(process.env.DB_POOL_SIZE) || 10
  },
  
  redis: {
    host: process.env.REDIS_HOST || 'localhost',
    port: parseInt(process.env.REDIS_PORT) || 6379,
    password: process.env.REDIS_PASSWORD
  },
  
  auth: {
    jwtSecret: process.env.JWT_SECRET,
    jwtExpiry: process.env.JWT_EXPIRY || '1d'
  },
  
  logging: {
    level: process.env.LOG_LEVEL || 'info',
    pretty: process.env.LOG_PRETTY === 'true'
  },
  
  // Feature flags
  features: {
    newUI: process.env.FEATURE_NEW_UI === 'true',
    betaAPI: process.env.FEATURE_BETA_API === 'true'
  }
};

// Validate
if (!config.auth.jwtSecret) {
  throw new Error('JWT_SECRET must be set');
}

module.exports = config;

// Usage
// const config = require('./config');
// console.log('Port:', config.server.port);
```

---

## Child Processes

### spawn() Method

```javascript
/**
 * spawn() - Stream data from command
 */

const { spawn } = require('child_process');

// Execute command
const ls = spawn('ls', ['-lh', '/usr']);

// Handle output
ls.stdout.on('data', (data) => {
  console.log(`stdout: ${data}`);
});

ls.stderr.on('data', (data) => {
  console.error(`stderr: ${data}`);
});

ls.on('close', (code) => {
  console.log(`Process exited with code ${code}`);
});

// Example: Run Python script
const python = spawn('python3', ['script.py', '--arg=value']);

python.stdout.on('data', (data) => {
  console.log(`Python output: ${data}`);
});

python.on('error', (err) => {
  console.error('Failed to start process:', err);
});

// Example: Interactive process
const interactive = spawn('node', ['--interactive']);

// Send input
interactive.stdin.write('console.log("Hello from child");\n');
interactive.stdin.end();

interactive.stdout.on('data', (data) => {
  console.log(`${data}`);
});
```

### exec() Method

```javascript
/**
 * exec() - Execute command and buffer output
 */

const { exec } = require('child_process');

// Simple command
exec('ls -lh', (error, stdout, stderr) => {
  if (error) {
    console.error(`Error: ${error}`);
    return;
  }

  if (stderr) {
    console.error(`stderr: ${stderr}`);
    return;
  }

  console.log(`stdout: ${stdout}`);
});

// With options
exec('node --version', {
  encoding: 'utf8',
  timeout: 5000,
  maxBuffer: 1024 * 1024,  // 1MB
  cwd: '/tmp'
}, (error, stdout, stderr) => {
  console.log('Node version:', stdout.trim());
});

// Promise-based
const util = require('util');
const execPromise = util.promisify(exec);

async function runCommand(command) {
  try {
    const { stdout, stderr } = await execPromise(command);
    return stdout.trim();
  } catch (error) {
    throw new Error(`Command failed: ${error.message}`);
  }
}

// Usage
(async () => {
  const version = await runCommand('node --version');
  console.log('Version:', version);
})();
```

### execFile() Method

```javascript
/**
 * execFile() - Execute file directly (safer)
 */

const { execFile } = require('child_process');

// Execute script
execFile('node', ['script.js'], (error, stdout, stderr) => {
  if (error) {
    console.error(`Error: ${error}`);
    return;
  }
  console.log(`Output: ${stdout}`);
});

// With arguments
execFile('/usr/bin/python3', ['script.py', '--data=value'], (error, stdout, stderr) => {
  console.log('Python output:', stdout);
});

// Safer than exec (no shell interpretation)
// exec('ls; rm -rf /')  ← Dangerous!
// execFile('ls', ['; rm -rf /'])  ← Safe, treated as literal argument
```

### fork() Method

```javascript
/**
 * fork() - Create Node.js child process with IPC
 */

// parent.js
const { fork } = require('child_process');

const child = fork('child.js');

// Send message to child
child.send({ type: 'greeting', message: 'Hello from parent!' });

// Receive message from child
child.on('message', (msg) => {
  console.log('Message from child:', msg);
});

child.on('close', (code) => {
  console.log(`Child process exited with code ${code}`);
});

// ===================================

// child.js
process.on('message', (msg) => {
  console.log('Message from parent:', msg);

  // Send response
  process.send({
    type: 'response',
    message: 'Hello from child!',
    data: { processed: true }
  });
});

// Signal parent on completion
setTimeout(() => {
  process.exit(0);
}, 1000);
```

---

## Cluster Module

### Creating a Cluster

```javascript
/**
 * cluster.js - Multi-core server
 */

const cluster = require('cluster');
const http = require('http');
const os = require('os');

const numCPUs = os.cpus().length;

if (cluster.isMaster) {
  console.log(`Master ${process.pid} is running`);

  // Fork workers
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }

  cluster.on('exit', (worker, code, signal) => {
    console.log(`Worker ${worker.process.pid} died`);
    
    // Restart worker
    console.log('Starting a new worker');
    cluster.fork();
  });

} else {
  // Workers share TCP connection
  http.createServer((req, res) => {
    res.writeHead(200);
    res.end(`Worker ${process.pid} handled request\n`);
  }).listen(3000);

  console.log(`Worker ${process.pid} started`);
}

// Test with: ab -n 1000 -c 100 http://localhost:3000/
```

### Advanced Cluster Management

```javascript
/**
 * Advanced cluster with graceful shutdown
 */

const cluster = require('cluster');
const http = require('http');
const os = require('os');

const numCPUs = os.cpus().length;
const PORT = process.env.PORT || 3000;

if (cluster.isMaster) {
  console.log(`Master ${process.pid} starting...`);

  // Fork workers
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }

  // Track worker restart
  const restarts = {};

  cluster.on('exit', (worker, code, signal) => {
    const id = worker.id;
    
    if (!restarts[id]) {
      restarts[id] = { count: 0, time: Date.now() };
    }

    // Check restart frequency
    const now = Date.now();
    if (now - restarts[id].time < 60000) {  // Within 1 minute
      restarts[id].count++;
      
      if (restarts[id].count > 5) {
        console.error(`Worker ${id} restarting too frequently. Not restarting.`);
        return;
      }
    } else {
      restarts[id] = { count: 1, time: now };
    }

    console.log(`Worker ${worker.process.pid} died. Starting new worker...`);
    cluster.fork();
  });

  // Graceful shutdown
  process.on('SIGTERM', () => {
    console.log('Master received SIGTERM, shutting down gracefully');

    for (const id in cluster.workers) {
      cluster.workers[id].send('shutdown');
      cluster.workers[id].disconnect();
    }

    setTimeout(() => {
      console.log('Forcing shutdown');
      process.exit(0);
    }, 10000);
  });

} else {
  // Worker code
  const server = http.createServer((req, res) => {
    // Simulate work
    const start = Date.now();
    while (Date.now() - start < 10) {}  // 10ms work

    res.writeHead(200);
    res.end(`Worker ${process.pid}\n`);
  });

  server.listen(PORT, () => {
    console.log(`Worker ${process.pid} started on port ${PORT}`);
  });

  // Graceful shutdown
  process.on('message', (msg) => {
    if (msg === 'shutdown') {
      console.log(`Worker ${process.pid} shutting down...`);

      server.close(() => {
        console.log(`Worker ${process.pid} closed all connections`);
        process.exit(0);
      });

      // Force shutdown after 5 seconds
      setTimeout(() => {
        console.error(`Worker ${process.pid} forced shutdown`);
        process.exit(1);
      }, 5000);
    }
  });

  // Handle uncaught exceptions
  process.on('uncaughtException', (err) => {
    console.error(`Worker ${process.pid} uncaught exception:`, err);
    process.exit(1);
  });
}
```

---

## Worker Threads

### Basic Worker Threads

```javascript
/**
 * Worker threads for CPU-intensive tasks
 */

// main.js
const { Worker } = require('worker_threads');

function runWorker(data) {
  return new Promise((resolve, reject) => {
    const worker = new Worker('./worker.js', {
      workerData: data
    });

    worker.on('message', resolve);
    worker.on('error', reject);
    worker.on('exit', (code) => {
      if (code !== 0) {
        reject(new Error(`Worker stopped with exit code ${code}`));
      }
    });
  });
}

// Usage
(async () => {
  const result = await runWorker({ n: 1000000 });
  console.log('Result:', result);
})();

// ===================================

// worker.js
const { workerData, parentPort } = require('worker_threads');

function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

const result = fibonacci(workerData.n);
parentPort.postMessage(result);
```

### Worker Thread Pool

```javascript
/**
 * worker-pool.js - Reusable worker pool
 */

const { Worker } = require('worker_threads');
const os = require('os');

class WorkerPool {
  constructor(workerScript, poolSize = os.cpus().length) {
    this.workerScript = workerScript;
    this.poolSize = poolSize;
    this.workers = [];
    this.queue = [];

    this.initWorkers();
  }

  initWorkers() {
    for (let i = 0; i < this.poolSize; i++) {
      this.workers.push({
        worker: null,
        busy: false
      });
    }
  }

  async execute(data) {
    return new Promise((resolve, reject) => {
      const available = this.workers.find(w => !w.busy);

      if (available) {
        this.runTask(available, data, resolve, reject);
      } else {
        this.queue.push({ data, resolve, reject });
      }
    });
  }

  runTask(workerSlot, data, resolve, reject) {
    workerSlot.busy = true;

    const worker = new Worker(this.workerScript, {
      workerData: data
    });

    worker.on('message', (result) => {
      workerSlot.busy = false;
      resolve(result);
      this.processQueue();
    });

    worker.on('error', (err) => {
      workerSlot.busy = false;
      reject(err);
      this.processQueue();
    });

    worker.on('exit', (code) => {
      workerSlot.busy = false;
      if (code !== 0) {
        reject(new Error(`Worker exited with code ${code}`));
      }
      this.processQueue();
    });

    workerSlot.worker = worker;
  }

  processQueue() {
    if (this.queue.length === 0) return;

    const available = this.workers.find(w => !w.busy);
    if (!available) return;

    const { data, resolve, reject } = this.queue.shift();
    this.runTask(available, data, resolve, reject);
  }

  async terminate() {
    for (const workerSlot of this.workers) {
      if (workerSlot.worker) {
        await workerSlot.worker.terminate();
      }
    }
  }
}

// Usage
const pool = new WorkerPool('./worker.js', 4);

Promise.all([
  pool.execute({ task: 'job1' }),
  pool.execute({ task: 'job2' }),
  pool.execute({ task: 'job3' })
]).then(results => {
  console.log('All results:', results);
  pool.terminate();
});
```

---

## Process Signals

### Handling Signals

```javascript
/**
 * Signal handling
 */

// SIGINT (Ctrl+C)
process.on('SIGINT', () => {
  console.log('Received SIGINT, shutting down gracefully');
  process.exit(0);
});

// SIGTERM (from kill command)
process.on('SIGTERM', () => {
  console.log('Received SIGTERM, shutting down gracefully');
  cleanup();
  process.exit(0);
});

// SIGHUP (terminal closed)
process.on('SIGHUP', () => {
  console.log('Received SIGHUP, reloading configuration');
  reloadConfig();
});

// Graceful shutdown
const server = require('http').createServer();

function gracefulShutdown(signal) {
  console.log(`Received ${signal}, closing server...`);

  server.close(() => {
    console.log('Server closed');
    
    // Close database connections
    // db.close();
    
    process.exit(0);
  });

  // Force shutdown after timeout
  setTimeout(() => {
    console.error('Forced shutdown');
    process.exit(1);
  }, 10000);
}

process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
process.on('SIGINT', () => gracefulShutdown('SIGINT'));

// Uncaught exceptions
process.on('uncaughtException', (err) => {
  console.error('Uncaught Exception:', err);
  
  // Log to file
  fs.appendFileSync('errors.log', `${new Date().toISOString()} ${err.stack}\n`);
  
  // Exit process
  process.exit(1);
});

// Unhandled promise rejections
process.on('unhandledRejection', (reason, promise) => {
  console.error('Unhandled Rejection at:', promise, 'reason:', reason);
  
  // In production, consider exiting
  // process.exit(1);
});
```

---

## Summary & Next Steps

### Key Takeaways

1. **process object** provides process information and control
2. **Command-line arguments** enable CLI applications
3. **Environment variables** configure applications
4. **Child processes** execute external commands
5. **Cluster module** utilizes multiple CPU cores
6. **Worker threads** handle CPU-intensive tasks

### What's Next?

- **Database Integration**: MongoDB, PostgreSQL, Redis
- **Authentication & Authorization**: JWT, OAuth, sessions
- **Deployment**: Docker, PM2, cloud platforms
- **Monitoring & Logging**: Winston, Prometheus, ELK

---

## References

- [Process Documentation](https://nodejs.org/api/process.html)
- [Child Process](https://nodejs.org/api/child_process.html)
- [Cluster Module](https://nodejs.org/api/cluster.html)
- [Worker Threads](https://nodejs.org/api/worker_threads.html)

---

**Previous Lesson:** [34. Streams and Buffers](./34.Streams_And_Buffers.md)

**Unit Complete!** Continue to [15. Advanced Backend](../15.Advanced_Backend/)
