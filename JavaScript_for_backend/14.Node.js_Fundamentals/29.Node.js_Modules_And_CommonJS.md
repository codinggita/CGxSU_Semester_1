# Node.js Modules and CommonJS

**Difficulty:** Intermediate
**Estimated Time:** 80-95 minutes
**Prerequisites:** Node.js basics, JavaScript fundamentals, npm/package.json
**Target:** Node.js 18+ LTS

---

## Learning Objectives

By the end of this lesson, you will be able to:

1. Understand the difference between CommonJS and ES Modules
2. Use require() and module.exports effectively
3. Implement various export patterns (named, default, mixed)
4. Understand module caching and its implications
5. Handle circular dependencies properly
6. Use Node.js built-in modules
7. Create your own npm packages
8. Publish packages to npm registry
9. Implement module best practices
10. Debug module resolution issues

---

## Table of Contents

1. [Introduction](#introduction)
2. [Module Systems Overview](#module-systems-overview)
3. [CommonJS: require() and module.exports](#commonjs-require-and-moduleexports)
4. [ES Modules in Node.js](#es-modules-in-nodejs)
5. [Module Caching](#module-caching)
6. [Circular Dependencies](#circular-dependencies)
7. [Built-in Modules](#built-in-modules)
8. [Creating npm Packages](#creating-npm-packages)
9. [Publishing to npm](#publishing-to-npm)
10. [Worked Examples](#worked-examples)
11. [Exercises](#exercises)
12. [Testing & Verification](#testing--verification)
13. [Best Practices](#best-practices)
14. [Common Pitfalls](#common-pitfalls)
15. [Performance Considerations](#performance-considerations)
16. [Summary & Next Steps](#summary--next-steps)
17. [References](#references)

---

## Introduction

**Modules** are the building blocks of Node.js applications. They allow you to organize code into reusable, maintainable pieces. Node.js supports two module systems: **CommonJS** (the original) and **ES Modules** (the modern standard).

**Why Modules Matter:**

- **Code Organization:** Split large applications into manageable files
- **Reusability:** Share code across projects
- **Encapsulation:** Hide implementation details
- **Dependency Management:** Clear dependencies between modules
- **Namespace Isolation:** Avoid global scope pollution
- **Performance:** Load only what you need

**Real-World Applications:**

- **Express.js:** Modular web framework
- **Lodash:** Utility library with modular exports
- **React:** Component-based modular architecture
- **AWS SDK:** Modular service clients
- **Mongoose:** MongoDB ODM with modular schemas

---

## Module Systems Overview

### CommonJS vs ES Modules

```javascript
/**
 * Module Systems Comparison
 */

// ============================================
// COMMONJS (CJS) - Node.js Default
// ============================================

// Exporting (module.exports)
// math.js
const add = (a, b) => a + b;
const subtract = (a, b) => a - b;
module.exports = { add, subtract };

// Importing (require)
// app.js
const math = require('./math');
const { add } = require('./math');

// Characteristics:
// ✓ Synchronous loading
// ✓ Dynamic imports (can use in conditionals)
// ✓ Node.js native support
// ✓ No top-level await
// ✗ Not supported in browsers without bundler

// ============================================
// ES MODULES (ESM) - Modern Standard
// ============================================

// Exporting
// math.mjs
export const add = (a, b) => a + b;
export const subtract = (a, b) => a - b;
export default { add, subtract };

// Importing
// app.mjs
import math from './math.mjs';
import { add } from './math.mjs';

// Characteristics:
// ✓ Static analysis (tree-shaking)
// ✓ Async loading
// ✓ Top-level await
// ✓ Browser native support
// ✓ Future of JavaScript
// ✗ Requires .mjs extension or "type": "module"

/**
 * Quick Comparison Table
 */
const comparison = {
  syntax: {
    CommonJS: 'require() / module.exports',
    ESModules: 'import / export'
  },
  loading: {
    CommonJS: 'Synchronous',
    ESModules: 'Asynchronous'
  },
  topLevelAwait: {
    CommonJS: '❌ No',
    ESModules: '✅ Yes'
  },
  dynamic: {
    CommonJS: '✅ Yes (require can be anywhere)',
    ESModules: '⚠️  Limited (import() dynamic)'
  },
  treeShaking: {
    CommonJS: '❌ Limited',
    ESModules: '✅ Yes'
  },
  default: {
    CommonJS: 'Node.js < 14',
    ESModules: 'Node.js 14+ (with config)'
  }
};
```

### Enabling ES Modules

```json
// package.json - Method 1: Set type
{
  "type": "module",
  "main": "index.js"
}
// Now all .js files are treated as ES Modules

// To use CommonJS in this setup, use .cjs extension
// file.cjs will be CommonJS
// file.js will be ES Module

// ============================================

// package.json - Method 2: Use .mjs extension
{
  "type": "commonjs"
}
// file.js → CommonJS
// file.mjs → ES Module

// ============================================

// Method 3: No package.json
// file.js → CommonJS (default)
// file.mjs → ES Module
```

---

## CommonJS: require() and module.exports

### Basic Exports

```javascript
/**
 * math.js - Simple exports
 */

function add(a, b) {
  return a + b;
}

function subtract(a, b) {
  return a - b;
}

function multiply(a, b) {
  return a * b;
}

function divide(a, b) {
  if (b === 0) throw new Error('Division by zero');
  return a / b;
}

// Export multiple functions
module.exports = {
  add,
  subtract,
  multiply,
  divide
};

// Alternative: Export individually
// module.exports.add = add;
// module.exports.subtract = subtract;
```

### Using require()

```javascript
/**
 * app.js - Importing modules
 */

// Import entire module
const math = require('./math');
console.log(math.add(5, 3)); // 8

// Destructure imports
const { add, subtract } = require('./math');
console.log(add(5, 3));      // 8
console.log(subtract(5, 3)); // 2

// Rename on import
const { add: sum } = require('./math');
console.log(sum(5, 3)); // 8

// Import built-in module
const fs = require('fs');
const path = require('path');

// Import from node_modules
const express = require('express');
const _ = require('lodash');
```

### Export Patterns

```javascript
/**
 * Export Pattern 1: Object Literal
 * user.js
 */
const getUser = (id) => ({ id, name: 'John' });
const createUser = (data) => ({ ...data, created: Date.now() });

module.exports = {
  getUser,
  createUser
};

// ============================================

/**
 * Export Pattern 2: Single Function/Class
 * logger.js
 */
class Logger {
  log(message) {
    console.log(`[${new Date().toISOString()}] ${message}`);
  }

  error(message) {
    console.error(`[${new Date().toISOString()}] ERROR: ${message}`);
  }
}

module.exports = Logger;
// Usage: const Logger = require('./logger'); const logger = new Logger();

// ============================================

/**
 * Export Pattern 3: Factory Function
 * database.js
 */
function createDatabase(config) {
  return {
    connect() {
      console.log('Connecting to', config.host);
    },
    disconnect() {
      console.log('Disconnecting');
    }
  };
}

module.exports = createDatabase;
// Usage: const createDb = require('./database'); const db = createDb({ host: 'localhost' });

// ============================================

/**
 * Export Pattern 4: Mixed Exports
 * utils.js
 */
function mainUtil() {
  return 'Main utility';
}

mainUtil.helper1 = function() {
  return 'Helper 1';
};

mainUtil.helper2 = function() {
  return 'Helper 2';
};

module.exports = mainUtil;
// Usage: const utils = require('./utils'); utils(); utils.helper1();

// ============================================

/**
 * Export Pattern 5: Immediate Export
 * config.js
 */
module.exports = {
  port: process.env.PORT || 3000,
  dbUrl: process.env.DB_URL || 'localhost',
  isDevelopment: process.env.NODE_ENV === 'development'
};
```

### Module Wrapper

```javascript
/**
 * The Module Wrapper
 *
 * Node.js wraps every module in a function:
 */

(function(exports, require, module, __filename, __dirname) {
  // Your module code here

  console.log(__filename);  // Full path to current file
  console.log(__dirname);   // Directory of current file
  console.log(module);      // Module object
  console.log(exports);     // Reference to module.exports
  console.log(require);     // Function to import modules

  // This is why these variables are available in every module!
});

/**
 * Available in every module:
 */

// __filename: Absolute path to current file
console.log('Current file:', __filename);
// /home/user/project/app.js

// __dirname: Directory of current file
console.log('Current directory:', __dirname);
// /home/user/project

// module: Current module object
console.log(module.exports); // {}
console.log(module.filename); // Same as __filename
console.log(module.id);      // Unique module identifier

// exports: Shorthand for module.exports
exports.myFunc = () => 'Hi'; // Same as module.exports.myFunc = ...

// require: Import other modules
const myModule = require('./my-module');
```

### exports vs module.exports

```javascript
/**
 * Understanding exports vs module.exports
 */

// Initially: exports === module.exports (same reference)
console.log(exports === module.exports); // true

// ============================================
// ✅ CORRECT: Adding properties to exports
// ============================================

exports.add = (a, b) => a + b;
exports.subtract = (a, b) => a - b;
// This works because exports points to module.exports

// ============================================
// ❌ WRONG: Reassigning exports
// ============================================

exports = {
  add: (a, b) => a + b,
  subtract: (a, b) => a - b
};
// This breaks the reference! exports no longer points to module.exports
// require() will return an empty object!

// ============================================
// ✅ CORRECT: Reassigning module.exports
// ============================================

module.exports = {
  add: (a, b) => a + b,
  subtract: (a, b) => a - b
};
// This works! module.exports is what gets returned by require()

// ============================================
// Rule of thumb:
// ============================================

// Use exports.property when adding properties
exports.func1 = () => {};
exports.func2 = () => {};

// Use module.exports when exporting entire object
module.exports = { func1, func2 };

// Never mix both patterns in the same file!
```

---

## ES Modules in Node.js

### Basic ES Module Syntax

```javascript
/**
 * math.mjs - ES Module exports
 */

// Named exports
export const add = (a, b) => a + b;
export const subtract = (a, b) => a - b;

export function multiply(a, b) {
  return a * b;
}

export function divide(a, b) {
  if (b === 0) throw new Error('Division by zero');
  return a / b;
}

// Default export
export default {
  add,
  subtract,
  multiply,
  divide
};

// ============================================

/**
 * app.mjs - ES Module imports
 */

// Import default export
import math from './math.mjs';
console.log(math.add(5, 3));

// Import named exports
import { add, subtract } from './math.mjs';
console.log(add(5, 3));

// Import all as namespace
import * as mathUtils from './math.mjs';
console.log(mathUtils.add(5, 3));

// Rename imports
import { add as sum, subtract as diff } from './math.mjs';

// Import default and named together
import math, { add, subtract } from './math.mjs';

// Side-effect import (runs code but doesn't import)
import './setup.mjs';
```

### Dynamic Imports

```javascript
/**
 * Dynamic imports with import()
 * Available in both CommonJS and ES Modules!
 */

// Conditional loading
async function loadModule(condition) {
  if (condition) {
    const { add } = await import('./math.mjs');
    return add(5, 3);
  }
}

// Lazy loading
async function handleClick() {
  const module = await import('./heavy-module.mjs');
  module.doSomething();
}

// Error handling
async function safeImport() {
  try {
    const module = await import('./optional-module.mjs');
    return module.default;
  } catch (error) {
    console.error('Module not found:', error);
    return null;
  }
}

// Load multiple modules
async function loadMultiple() {
  const [math, utils, helpers] = await Promise.all([
    import('./math.mjs'),
    import('./utils.mjs'),
    import('./helpers.mjs')
  ]);

  return { math, utils, helpers };
}

// Dynamic path
async function loadByName(name) {
  const module = await import(`./modules/${name}.mjs`);
  return module.default;
}
```

### Top-Level Await

```javascript
/**
 * top-level-await.mjs
 * Only available in ES Modules!
 */

// Fetch data at module load time
const response = await fetch('https://api.example.com/config');
const config = await response.json();

export default config;

// ============================================

// Read file at module load time
import { readFile } from 'fs/promises';

const data = await readFile('./data.txt', 'utf8');
export const content = data;

// ============================================

// Wait for database connection
import { connectDatabase } from './database.mjs';

const db = await connectDatabase();
export default db;

// ============================================

// ❌ CommonJS equivalent would require async wrapper
// const fs = require('fs').promises;
//
// (async () => {
//   const data = await fs.readFile('./data.txt', 'utf8');
//   module.exports = data;
// })();
// This doesn't work as expected!
```

### Interoperability

```javascript
/**
 * Using CommonJS modules in ES Modules
 */

// ESM file (app.mjs with "type": "module")

// Import CommonJS module
import cjsModule from './commonjs-module.js';
// Default import works

// Named imports DON'T work for CommonJS
// import { someFunction } from './commonjs-module.js'; // ❌ Error

// Solution: Import default then destructure
import cjsModule from './commonjs-module.js';
const { someFunction } = cjsModule;

// ============================================

/**
 * Using ES Modules in CommonJS (Node 14+)
 */

// CJS file (app.js without "type": "module")

// Cannot use import statement
// import { add } from './math.mjs'; // ❌ Syntax Error

// Solution: Use dynamic import()
(async () => {
  const math = await import('./math.mjs');
  console.log(math.add(5, 3));
})();

// Or with import() in functions
async function useMath() {
  const { add } = await import('./math.mjs');
  return add(5, 3);
}
```

---

## Module Caching

### How Module Caching Works

```javascript
/**
 * counter.js - Module caching demonstration
 */

let count = 0;

function increment() {
  return ++count;
}

function getCount() {
  return count;
}

module.exports = { increment, getCount };

// ============================================

/**
 * app.js - Testing module cache
 */

const counter1 = require('./counter');
const counter2 = require('./counter');

console.log(counter1.increment()); // 1
console.log(counter1.increment()); // 2
console.log(counter2.getCount());  // 2 (same instance!)

console.log(counter1 === counter2); // true (cached)

/**
 * Key Points:
 * 1. Modules are cached after first require()
 * 2. Subsequent requires return the cached version
 * 3. Module code executes only once
 * 4. Changes in one reference affect all references
 */

// ============================================

/**
 * Viewing the module cache
 */

console.log(require.cache);
// Shows all cached modules with full paths as keys

// Clearing cache (rarely needed)
delete require.cache[require.resolve('./counter')];

// Now requiring will execute the module again
const freshCounter = require('./counter');
```

### Cache Implications

```javascript
/**
 * database.js - Singleton pattern via caching
 */

class Database {
  constructor() {
    if (Database.instance) {
      return Database.instance;
    }

    this.connection = null;
    Database.instance = this;
  }

  async connect() {
    if (!this.connection) {
      console.log('Creating new connection');
      this.connection = { status: 'connected' };
    }
    return this.connection;
  }
}

// Module caching ensures this is a singleton
module.exports = new Database();

// ============================================

/**
 * config.js - Configuration loaded once
 */

console.log('Loading configuration...');

const config = {
  port: process.env.PORT || 3000,
  dbUrl: process.env.DB_URL,
  timestamp: Date.now()
};

module.exports = config;

// 'Loading configuration...' prints only once
// Even if required from multiple files

// ============================================

/**
 * hot-reload.js - Clearing cache for hot reload
 */

function requireFresh(module) {
  const fullPath = require.resolve(module);
  delete require.cache[fullPath];
  return require(module);
}

// Use in development for hot reloading
const config = requireFresh('./config');
```

---

## Circular Dependencies

### The Problem

```javascript
/**
 * a.js - Circular dependency example
 */

console.log('a starting');
exports.done = false;

const b = require('./b.js');
console.log('in a, b.done =', b.done);

exports.done = true;
console.log('a done');

// ============================================

/**
 * b.js
 */

console.log('b starting');
exports.done = false;

const a = require('./a.js');
console.log('in b, a.done =', a.done);

exports.done = true;
console.log('b done');

// ============================================

/**
 * main.js
 */

const a = require('./a.js');
const b = require('./b.js');

console.log('in main, a.done =', a.done, 'b.done =', b.done);

/**
 * Output:
 * a starting
 * b starting
 * in b, a.done = false  ← a.js not finished yet!
 * b done
 * in a, b.done = true
 * a done
 * in main, a.done = true b.done = true
 *
 * a.js gets incomplete version of b.js!
 */
```

### Avoiding Circular Dependencies

```javascript
/**
 * ❌ BAD: Circular dependency
 */

// user.js
const Post = require('./post');

class User {
  getPosts() {
    return Post.getByUserId(this.id);
  }
}

module.exports = User;

// post.js
const User = require('./user');

class Post {
  getAuthor() {
    return User.getById(this.userId);
  }
}

module.exports = Post;

// ============================================

/**
 * ✅ GOOD: Solution 1 - Dependency Injection
 */

// user.js
class User {
  getPosts(PostModel) {
    return PostModel.getByUserId(this.id);
  }
}

module.exports = User;

// post.js
class Post {
  getAuthor(UserModel) {
    return UserModel.getById(this.userId);
  }
}

module.exports = Post;

// ============================================

/**
 * ✅ GOOD: Solution 2 - Separate module
 */

// user.js
class User {
  constructor(id, name) {
    this.id = id;
    this.name = name;
  }
}

module.exports = User;

// post.js
class Post {
  constructor(id, title, userId) {
    this.id = id;
    this.title = title;
    this.userId = userId;
  }
}

module.exports = Post;

// services/userService.js
const User = require('../user');
const Post = require('../post');

function getUserWithPosts(userId) {
  const user = getUserById(userId);
  const posts = Post.getByUserId(userId);
  return { ...user, posts };
}

module.exports = { getUserWithPosts };

// ============================================

/**
 * ✅ GOOD: Solution 3 - Lazy require
 */

// user.js
class User {
  getPosts() {
    // Require inside method (lazy)
    const Post = require('./post');
    return Post.getByUserId(this.id);
  }
}

module.exports = User;
```

---

## Built-in Modules

### Core Modules Overview

```javascript
/**
 * Node.js Built-in Modules
 * No installation required!
 */

// File System
const fs = require('fs');
const fsPromises = require('fs').promises;

// Path manipulation
const path = require('path');

// HTTP/HTTPS
const http = require('http');
const https = require('https');

// URL parsing
const url = require('url');
const { URL } = require('url');

// Operating System
const os = require('os');

// Child Processes
const { spawn, exec } = require('child_process');

// Events
const EventEmitter = require('events');

// Streams
const { Readable, Writable, Transform } = require('stream');

// Crypto
const crypto = require('crypto');

// Utilities
const util = require('util');

// Query Strings
const querystring = require('querystring');

// Timers
const { setTimeout, setInterval } = require('timers/promises');
```

### Common Built-in Module Examples

```javascript
/**
 * fs - File System
 */
const fs = require('fs');

// Read file
fs.readFile('file.txt', 'utf8', (err, data) => {
  if (err) throw err;
  console.log(data);
});

// Write file
fs.writeFile('output.txt', 'Hello!', (err) => {
  if (err) throw err;
});

// ============================================

/**
 * path - Path manipulation
 */
const path = require('path');

// Join paths
const fullPath = path.join(__dirname, 'files', 'data.txt');
// /home/user/project/files/data.txt

// Get extension
const ext = path.extname('file.txt'); // .txt

// Get basename
const base = path.basename('/path/to/file.txt'); // file.txt

// Get dirname
const dir = path.dirname('/path/to/file.txt'); // /path/to

// Resolve absolute path
const absolute = path.resolve('files', 'data.txt');

// ============================================

/**
 * os - Operating System
 */
const os = require('os');

console.log('Platform:', os.platform()); // linux, darwin, win32
console.log('CPU cores:', os.cpus().length);
console.log('Free memory:', os.freemem());
console.log('Home directory:', os.homedir());
console.log('Hostname:', os.hostname());

// ============================================

/**
 * url - URL parsing
 */
const { URL } = require('url');

const myUrl = new URL('https://example.com:8000/path?name=John&age=30');

console.log(myUrl.protocol);  // https:
console.log(myUrl.hostname);  // example.com
console.log(myUrl.port);      // 8000
console.log(myUrl.pathname);  // /path
console.log(myUrl.search);    // ?name=John&age=30
console.log(myUrl.searchParams.get('name')); // John

// ============================================

/**
 * util - Utilities
 */
const util = require('util');

// Promisify callback-based functions
const readFilePromise = util.promisify(fs.readFile);

async function readAsync() {
  const data = await readFilePromise('file.txt', 'utf8');
  return data;
}

// Format strings
const formatted = util.format('Hello %s, you are %d years old', 'John', 30);

// Inspect objects
const obj = { a: 1, b: { c: 2 } };
console.log(util.inspect(obj, { depth: null, colors: true }));
```

---

## Creating npm Packages

### Package Structure

```bash
my-package/
├── src/
│   ├── index.js          # Main entry point
│   └── utils.js          # Utility functions
├── test/
│   └── index.test.js     # Tests
├── .gitignore
├── .npmignore            # Files to exclude from npm
├── LICENSE               # License file
├── README.md             # Documentation
└── package.json          # Package configuration
```

### Creating a Package

```javascript
/**
 * src/index.js - String utilities package
 */

/**
 * Capitalizes the first letter of a string
 * @param {string} str - Input string
 * @returns {string} Capitalized string
 */
function capitalize(str) {
  if (!str) return '';
  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
}

/**
 * Reverses a string
 * @param {string} str - Input string
 * @returns {string} Reversed string
 */
function reverse(str) {
  return str.split('').reverse().join('');
}

/**
 * Truncates a string to specified length
 * @param {string} str - Input string
 * @param {number} length - Max length
 * @param {string} suffix - Suffix to add (default: '...')
 * @returns {string} Truncated string
 */
function truncate(str, length, suffix = '...') {
  if (str.length <= length) return str;
  return str.slice(0, length - suffix.length) + suffix;
}

/**
 * Converts string to slug
 * @param {string} str - Input string
 * @returns {string} Slugified string
 */
function slugify(str) {
  return str
    .toLowerCase()
    .trim()
    .replace(/[^\w\s-]/g, '')
    .replace(/[\s_-]+/g, '-')
    .replace(/^-+|-+$/g, '');
}

module.exports = {
  capitalize,
  reverse,
  truncate,
  slugify
};
```

### Package Configuration

```json
{
  "name": "@yourusername/string-utils",
  "version": "1.0.0",
  "description": "Utility functions for string manipulation",
  "main": "src/index.js",
  "types": "src/index.d.ts",
  "scripts": {
    "test": "jest",
    "test:coverage": "jest --coverage",
    "lint": "eslint src/",
    "prepublishOnly": "npm test && npm run lint"
  },
  "keywords": [
    "string",
    "utilities",
    "helpers",
    "text"
  ],
  "author": "Your Name <your.email@example.com>",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/yourusername/string-utils.git"
  },
  "bugs": {
    "url": "https://github.com/yourusername/string-utils/issues"
  },
  "homepage": "https://github.com/yourusername/string-utils#readme",
  "files": [
    "src/",
    "README.md",
    "LICENSE"
  ],
  "engines": {
    "node": ">=14.0.0"
  },
  "devDependencies": {
    "jest": "^29.5.0",
    "eslint": "^8.40.0"
  }
}
```

### Documentation

```markdown
# @yourusername/string-utils

> Utility functions for string manipulation

## Installation

```bash
npm install @yourusername/string-utils
```

## Usage

```javascript
const { capitalize, reverse, truncate, slugify } = require('@yourusername/string-utils');

// Capitalize first letter
capitalize('hello world'); // 'Hello world'

// Reverse string
reverse('hello'); // 'olleh'

// Truncate string
truncate('This is a long string', 10); // 'This is...'

// Slugify string
slugify('Hello World!'); // 'hello-world'
```

## API

### capitalize(str)
Capitalizes the first letter of a string.

**Parameters:**
- `str` (string): Input string

**Returns:** (string) Capitalized string

### reverse(str)
Reverses a string.

**Parameters:**
- `str` (string): Input string

**Returns:** (string) Reversed string

### truncate(str, length, suffix)
Truncates a string to specified length.

**Parameters:**
- `str` (string): Input string
- `length` (number): Maximum length
- `suffix` (string): Suffix to add (default: '...')

**Returns:** (string) Truncated string

### slugify(str)
Converts string to URL-friendly slug.

**Parameters:**
- `str` (string): Input string

**Returns:** (string) Slugified string

## License

MIT © Your Name
```

### .npmignore

```
# Test files
test/
*.test.js
coverage/

# Development files
.eslintrc.json
.prettierrc
.editorconfig

# Documentation
docs/
examples/

# Git files
.git/
.gitignore

# CI/CD
.github/
.travis.yml

# OS files
.DS_Store
Thumbs.db

# Node
node_modules/
npm-debug.log
```

---

## Publishing to npm

### Preparation Steps

```bash
# 1. Create npm account
# Visit https://www.npmjs.com/signup

# 2. Login via CLI
npm login
# Enter username, password, email

# 3. Verify login
npm whoami

# 4. Check package name availability
npm search string-utils
# or visit https://www.npmjs.com/package/string-utils

# 5. For scoped packages (recommended for avoiding name conflicts)
# Use: @yourusername/package-name
```

### Publishing Process

```bash
# 1. Test your package locally
npm link
cd ../test-project
npm link @yourusername/string-utils

# 2. Run all tests
npm test

# 3. Update version (follows semver)
npm version patch  # 1.0.0 → 1.0.1
npm version minor  # 1.0.1 → 1.1.0
npm version major  # 1.1.0 → 2.0.0

# 4. Dry run (see what would be published)
npm publish --dry-run

# 5. Publish!
npm publish --access public  # For scoped packages

# 6. Verify publication
npm view @yourusername/string-utils

# 7. Tag versions
git tag v1.0.0
git push --tags
```

### Package Scripts for Publishing

```json
{
  "scripts": {
    "prepublishOnly": "npm run test && npm run lint",
    "postpublish": "git push --tags",
    "version": "npm run build && git add -A",
    "postversion": "git push && git push --tags"
  }
}
```

### Updating Published Package

```bash
# Make changes to your package

# Test changes
npm test

# Update version
npm version patch  # or minor, major

# Publish update
npm publish

# Users can update with:
npm update @yourusername/string-utils
```

### Unpublishing (Use with Caution!)

```bash
# Unpublish specific version (within 72 hours)
npm unpublish @yourusername/string-utils@1.0.0

# Unpublish entire package (within 72 hours)
npm unpublish @yourusername/string-utils --force

# Deprecate instead of unpublishing (better practice)
npm deprecate @yourusername/string-utils@1.0.0 "Use version 1.0.1 instead"
```

---

## Worked Examples

### Example 1: Module with Multiple Export Patterns

```javascript
/**
 * logger.js - Advanced module pattern
 */

// Private variables (not exported)
const LOG_LEVELS = {
  DEBUG: 0,
  INFO: 1,
  WARN: 2,
  ERROR: 3
};

let currentLevel = LOG_LEVELS.INFO;

// Private function
function formatMessage(level, message) {
  const timestamp = new Date().toISOString();
  return `[${timestamp}] [${level}] ${message}`;
}

// Exported class
class Logger {
  constructor(name) {
    this.name = name;
  }

  debug(message) {
    if (currentLevel <= LOG_LEVELS.DEBUG) {
      console.log(formatMessage('DEBUG', `${this.name}: ${message}`));
    }
  }

  info(message) {
    if (currentLevel <= LOG_LEVELS.INFO) {
      console.log(formatMessage('INFO', `${this.name}: ${message}`));
    }
  }

  warn(message) {
    if (currentLevel <= LOG_LEVELS.WARN) {
      console.warn(formatMessage('WARN', `${this.name}: ${message}`));
    }
  }

  error(message) {
    if (currentLevel <= LOG_LEVELS.ERROR) {
      console.error(formatMessage('ERROR', `${this.name}: ${message}`));
    }
  }
}

// Exported functions
function setLevel(level) {
  if (LOG_LEVELS[level] !== undefined) {
    currentLevel = LOG_LEVELS[level];
  }
}

function createLogger(name) {
  return new Logger(name);
}

// Default logger instance
const defaultLogger = new Logger('app');

// Export everything
module.exports = {
  Logger,
  createLogger,
  setLevel,
  LOG_LEVELS: { ...LOG_LEVELS }, // Export copy, not reference
  default: defaultLogger
};

// Usage:
// const { createLogger, setLevel, LOG_LEVELS } = require('./logger');
// const logger = createLogger('myModule');
// logger.info('Hello!');
```

### Example 2: Plugin System

```javascript
/**
 * plugin-system.js - Extensible plugin architecture
 */

class PluginSystem {
  constructor() {
    this.plugins = new Map();
  }

  register(name, plugin) {
    if (this.plugins.has(name)) {
      throw new Error(`Plugin ${name} already registered`);
    }

    if (typeof plugin.init !== 'function') {
      throw new Error(`Plugin ${name} must have an init method`);
    }

    this.plugins.set(name, plugin);
    plugin.init(this);
    console.log(`Plugin ${name} registered`);
  }

  unregister(name) {
    const plugin = this.plugins.get(name);
    if (plugin && typeof plugin.destroy === 'function') {
      plugin.destroy();
    }
    this.plugins.delete(name);
  }

  getPlugin(name) {
    return this.plugins.get(name);
  }

  hasPlugin(name) {
    return this.plugins.has(name);
  }

  listPlugins() {
    return Array.from(this.plugins.keys());
  }
}

module.exports = new PluginSystem(); // Singleton

// ============================================

/**
 * plugins/cache.js - Cache plugin
 */

class CachePlugin {
  constructor() {
    this.cache = new Map();
  }

  init(system) {
    console.log('Cache plugin initialized');
    this.system = system;
  }

  set(key, value, ttl = 60000) {
    this.cache.set(key, {
      value,
      expires: Date.now() + ttl
    });
  }

  get(key) {
    const item = this.cache.get(key);
    if (!item) return null;

    if (Date.now() > item.expires) {
      this.cache.delete(key);
      return null;
    }

    return item.value;
  }

  clear() {
    this.cache.clear();
  }

  destroy() {
    this.clear();
    console.log('Cache plugin destroyed');
  }
}

module.exports = new CachePlugin();

// ============================================

/**
 * app.js - Using plugin system
 */

const pluginSystem = require('./plugin-system');
const cachePlugin = require('./plugins/cache');
const loggingPlugin = require('./plugins/logging');

// Register plugins
pluginSystem.register('cache', cachePlugin);
pluginSystem.register('logging', loggingPlugin);

// Use plugins
const cache = pluginSystem.getPlugin('cache');
cache.set('user:1', { name: 'John' }, 5000);
console.log(cache.get('user:1'));

// List all plugins
console.log('Loaded plugins:', pluginSystem.listPlugins());
```

### Example 3: Module Loader with Validation

```javascript
/**
 * module-loader.js - Safe module loading with validation
 */

const fs = require('fs');
const path = require('path');

class ModuleLoader {
  constructor(baseDir) {
    this.baseDir = baseDir;
    this.loadedModules = new Map();
  }

  /**
   * Load a module with validation
   */
  load(modulePath, options = {}) {
    const {
      required = [],
      cache = true,
      validate = true
    } = options;

    const fullPath = path.join(this.baseDir, modulePath);

    // Check cache
    if (cache && this.loadedModules.has(fullPath)) {
      return this.loadedModules.get(fullPath);
    }

    // Check if file exists
    if (!fs.existsSync(fullPath)) {
      throw new Error(`Module not found: ${fullPath}`);
    }

    // Load module
    let module;
    try {
      module = require(fullPath);
    } catch (error) {
      throw new Error(`Failed to load module ${fullPath}: ${error.message}`);
    }

    // Validate required exports
    if (validate && required.length > 0) {
      const missing = required.filter(prop => !(prop in module));
      if (missing.length > 0) {
        throw new Error(
          `Module ${modulePath} missing required exports: ${missing.join(', ')}`
        );
      }
    }

    // Cache if enabled
    if (cache) {
      this.loadedModules.set(fullPath, module);
    }

    return module;
  }

  /**
   * Load all modules from a directory
   */
  loadDirectory(dir, options = {}) {
    const fullDir = path.join(this.baseDir, dir);
    const files = fs.readdirSync(fullDir);

    const modules = {};

    for (const file of files) {
      if (file.endsWith('.js')) {
        const name = path.basename(file, '.js');
        const modulePath = path.join(dir, file);

        try {
          modules[name] = this.load(modulePath, options);
        } catch (error) {
          console.error(`Failed to load ${file}:`, error.message);
        }
      }
    }

    return modules;
  }

  /**
   * Clear module cache
   */
  clearCache(modulePath) {
    if (modulePath) {
      const fullPath = path.join(this.baseDir, modulePath);
      this.loadedModules.delete(fullPath);
      delete require.cache[require.resolve(fullPath)];
    } else {
      this.loadedModules.clear();
      // Clear entire require cache (use with caution!)
      Object.keys(require.cache).forEach(key => {
        if (key.startsWith(this.baseDir)) {
          delete require.cache[key];
        }
      });
    }
  }

  /**
   * Reload a module
   */
  reload(modulePath, options = {}) {
    this.clearCache(modulePath);
    return this.load(modulePath, options);
  }
}

module.exports = ModuleLoader;

// ============================================

/**
 * Usage example
 */

const ModuleLoader = require('./module-loader');

const loader = new ModuleLoader(__dirname);

// Load single module with validation
const userModule = loader.load('./modules/user.js', {
  required: ['create', 'update', 'delete'],
  cache: true
});

// Load all modules from directory
const allModules = loader.loadDirectory('./plugins', {
  required: ['init'],
  cache: true
});

// Reload module
const freshModule = loader.reload('./modules/user.js');
```

---

## Exercises

### Exercise 1: Basic Module Creation (Beginner)

**Task:** Create a math utilities module with multiple exports.

**Requirements:**
1. Create `mathUtils.js` with functions: add, subtract, multiply, divide
2. Add input validation (throw errors for invalid inputs)
3. Export using module.exports
4. Create `app.js` that imports and uses all functions
5. Handle division by zero
6. Add JSDoc comments
7. Test all functions

**Solution:** See `solutions/exercise1-math-utils.js`

---

### Exercise 2: ES Module Conversion (Intermediate)

**Task:** Convert CommonJS modules to ES Modules.

**Requirements:**
1. Convert existing CommonJS modules to ESM
2. Update package.json with "type": "module"
3. Handle default and named exports
4. Use dynamic imports for conditional loading
5. Implement top-level await
6. Ensure backward compatibility
7. Update all import statements

**Solution:** See `solutions/exercise2-esm-conversion/`

---

### Exercise 3: Module Caching Investigation (Intermediate)

**Task:** Create a module that demonstrates caching behavior.

**Requirements:**
1. Create a counter module that tracks calls
2. Demonstrate that module caches
3. Show how to clear cache
4. Create singleton pattern using caching
5. Compare cached vs non-cached performance
6. Document caching implications
7. Implement cache invalidation

**Solution:** See `solutions/exercise3-module-cache.js`

---

### Exercise 4: Plugin System (Advanced)

**Task:** Build an extensible plugin system.

**Requirements:**
1. Create plugin manager that registers plugins
2. Plugins must implement interface (init, execute, destroy)
3. Support plugin dependencies
4. Enable/disable plugins dynamically
5. Plugin lifecycle hooks
6. Error handling for plugin failures
7. Create at least 3 sample plugins
8. Plugin configuration system

**Solution:** See `solutions/exercise4-plugin-system/`

---

### Exercise 5: Create and Publish npm Package (Advanced)

**Task:** Create, test, and publish a complete npm package.

**Requirements:**
1. Create utility library (array or object helpers)
2. Configure package.json properly
3. Write comprehensive README
4. Add JSDoc documentation
5. Create test suite (Jest)
6. Set up GitHub repository
7. Add CI/CD (GitHub Actions)
8. Publish to npm registry
9. Add versioning scripts
10. Create example usage project

**Solution:** See `solutions/exercise5-npm-package/`

---

## Testing & Verification

### Test Suite: modules.test.js

```javascript
/**
 * tests/modules.test.js
 */

const path = require('path');

describe('Module Systems', () => {
  describe('CommonJS', () => {
    test('require() imports module', () => {
      const math = require('../examples/math');
      expect(math).toHaveProperty('add');
      expect(math).toHaveProperty('subtract');
    });

    test('module.exports works correctly', () => {
      const math = require('../examples/math');
      expect(math.add(2, 3)).toBe(5);
      expect(math.subtract(5, 3)).toBe(2);
    });

    test('destructuring imports work', () => {
      const { add } = require('../examples/math');
      expect(add(2, 3)).toBe(5);
    });

    test('modules are cached', () => {
      const math1 = require('../examples/math');
      const math2 = require('../examples/math');
      expect(math1).toBe(math2);
    });
  });

  describe('Module Caching', () => {
    test('module executes only once', () => {
      // Clear cache first
      const modulePath = require.resolve('../examples/counter');
      delete require.cache[modulePath];

      // First require
      const counter1 = require('../examples/counter');
      const count1 = counter1.increment();

      // Second require (should use cache)
      const counter2 = require('../examples/counter');
      const count2 = counter2.increment();

      expect(count2).toBeGreaterThan(count1);
      expect(counter1).toBe(counter2);
    });

    test('cache can be cleared', () => {
      const modulePath = require.resolve('../examples/counter');

      const counter1 = require('../examples/counter');
      counter1.increment();

      // Clear cache
      delete require.cache[modulePath];

      // Require again
      const counter2 = require('../examples/counter');
      expect(counter2.getCount()).toBe(0); // Reset!
    });
  });

  describe('Built-in Modules', () => {
    test('path module works', () => {
      const joined = path.join('/', 'home', 'user', 'file.txt');
      expect(joined).toBe('/home/user/file.txt');
    });

    test('path.extname extracts extension', () => {
      expect(path.extname('file.txt')).toBe('.txt');
      expect(path.extname('file.tar.gz')).toBe('.gz');
    });

    test('path.basename gets filename', () => {
      expect(path.basename('/path/to/file.txt')).toBe('file.txt');
    });
  });

  describe('Module Resolution', () => {
    test('require.resolve finds module path', () => {
      const mathPath = require.resolve('../examples/math');
      expect(mathPath).toContain('math.js');
    });

    test('require.resolve works for node_modules', () => {
      const lodashPath = require.resolve('lodash');
      expect(lodashPath).toContain('node_modules');
    });
  });

  describe('Circular Dependencies', () => {
    test('handles circular dependencies without crashing', () => {
      expect(() => {
        require('../examples/circular-a');
      }).not.toThrow();
    });

    test('circular dependency values may be incomplete', () => {
      delete require.cache[require.resolve('../examples/circular-a')];
      delete require.cache[require.resolve('../examples/circular-b')];

      const a = require('../examples/circular-a');
      expect(a).toHaveProperty('done');
    });
  });
});

describe('ES Modules', () => {
  // Note: Testing ES modules requires different setup
  // These tests assume Jest is configured for ESM

  test('dynamic import works', async () => {
    const module = await import('../examples/math.mjs');
    expect(module).toHaveProperty('add');
  });

  test('named imports work', async () => {
    const { add } = await import('../examples/math.mjs');
    expect(typeof add).toBe('function');
  });
});
```

---

## Best Practices

### 1. Module Design

```javascript
// ✅ DO: Single Responsibility
// user.js - Handles only user operations
module.exports = {
  getUser,
  createUser,
  updateUser
};

// ❌ DON'T: Mix concerns
// utils.js - Too many unrelated functions
module.exports = {
  formatDate,
  hashPassword,
  sendEmail,
  calculateTax
};
```

### 2. Export Patterns

```javascript
// ✅ DO: Clear, consistent exports
// Option 1: Object literal
module.exports = {
  function1,
  function2
};

// Option 2: Class
module.exports = class MyClass {};

// ❌ DON'T: Mix patterns
exports.func1 = () => {};
module.exports.func2 = () => {};  // Confusing!
module.exports = { func3 };       // Overwrites previous exports!
```

### 3. Module Organization

```javascript
// ✅ DO: Organize by feature
project/
  ├── users/
  │   ├── user.model.js
  │   ├── user.controller.js
  │   └── user.service.js
  ├── posts/
  │   ├── post.model.js
  │   └── post.controller.js

// ❌ DON'T: Organize by type (for large projects)
project/
  ├── models/
  │   ├── user.js
  │   └── post.js
  ├── controllers/
  │   ├── user.js
  │   └── post.js
```

### 4. Dependency Management

```javascript
// ✅ DO: Import at top
const fs = require('fs');
const path = require('path');
const express = require('express');

function myFunction() {
  // Use imports
}

// ❌ DON'T: Import inside functions (except lazy loading)
function myFunction() {
  const fs = require('fs'); // Repeated on every call!
}
```

### 5. ES Modules vs CommonJS

```javascript
// ✅ DO: Choose one and be consistent
// Use ESM for new projects
// Use CJS for libraries (better compatibility)

// ✅ DO: Use file extensions
import { add } from './math.mjs';  // Clear it's ESM

// ❌ DON'T: Mix without good reason
```

---

## Common Pitfalls

### 1. exports vs module.exports Confusion

```javascript
// ❌ PITFALL: Overwriting exports
exports = { func1, func2 };  // Doesn't work!
// Why: exports is a reference to module.exports
// Reassigning breaks the reference

// ✅ SOLUTION
module.exports = { func1, func2 };
```

### 2. Circular Dependencies

```javascript
// ❌ PITFALL: Circular requires
// a.js requires b.js, b.js requires a.js

// ✅ SOLUTION: Restructure or use dependency injection
```

### 3. Mutating Cached Modules

```javascript
// ❌ PITFALL: Unintended mutations
const config = require('./config');
config.apiUrl = 'http://evil.com';  // Changes for everyone!

// ✅ SOLUTION: Return copies or use Object.freeze
module.exports = Object.freeze({
  apiUrl: 'http://api.com'
});
```

### 4. Forgetting Async for Dynamic Imports

```javascript
// ❌ PITFALL
const module = import('./module.mjs');  // Returns Promise!
module.doSomething();  // Error!

// ✅ SOLUTION
const module = await import('./module.mjs');
module.doSomething();
```

### 5. Global Package Pollution

```javascript
// ❌ PITFALL: Installing everything globally
npm install -g create-react-app
npm install -g webpack
npm install -g eslint

// ✅ SOLUTION: Use npx or local installation
npx create-react-app my-app
```

---

## Performance Considerations

### 1. Module Loading Performance

```javascript
// ✅ FAST: Static imports (loaded once, cached)
const lodash = require('lodash');

// ⚠️  SLOWER: Dynamic imports (async overhead)
const lodash = await import('lodash');

// Use dynamic imports only when needed:
// - Conditional loading
// - Code splitting
// - Lazy loading
```

### 2. Require Performance

```javascript
// ✅ EFFICIENT: Require at top level
const fs = require('fs');

function readFile() {
  return fs.readFileSync('file.txt');
}

// ❌ INEFFICIENT: Require inside loop
for (let i = 0; i < 1000; i++) {
  const fs = require('fs');  // Cached, but still overhead
  fs.readFileSync('file.txt');
}
```

### 3. Module Size

```javascript
// ✅ EFFICIENT: Import only what you need
const { map, filter } = require('lodash');

// ❌ INEFFICIENT: Import entire library
const _ = require('lodash');  // Loads everything!

// With ES Modules (enables tree-shaking)
import { map, filter } from 'lodash-es';
```

---

## Summary & Next Steps

### Key Takeaways

1. **CommonJS** is Node.js default, uses require() and module.exports
2. **ES Modules** are the future, use import/export
3. **Modules are cached** after first load
4. **Circular dependencies** should be avoided or carefully managed
5. **Built-in modules** provide core functionality
6. **Creating packages** enables code reuse

### What's Next?

In the next lesson, we'll explore:
- **File System Operations**: Reading, writing, and manipulating files
- **fs module**: Sync, async, and promises API
- **Streams**: Efficiently handling large files

### Further Practice

1. Convert a project from CommonJS to ES Modules
2. Create and publish your first npm package
3. Build a plugin system for your application
4. Explore Node.js built-in modules
5. Contribute to open-source npm packages

---

## References

### Official Documentation
- [Node.js Modules](https://nodejs.org/api/modules.html)
- [ES Modules](https://nodejs.org/api/esm.html)
- [npm Package Specification](https://docs.npmjs.com/cli/v9/configuring-npm/package-json)

### Tools
- [CommonJS Spec](http://www.commonjs.org/)
- [Module Bundlers](https://webpack.js.org/)

### Tutorials
- [Node.js Module Patterns](https://darrenderidder.github.io/talks/ModulePatterns/)
- [Publishing npm Packages](https://docs.npmjs.com/creating-and-publishing-unscoped-public-packages)

### Books
- "Node.js Design Patterns" by Mario Casciaro
- "Understanding ECMAScript 6" by Nicholas Zakas

---

**Next Lesson:** [30. File System Operations](./30.File_System_Operations.md)

**Previous Lesson:** [28. Node.js Introduction and Setup](./28.Node.js_Introduction_And_Setup.md)
