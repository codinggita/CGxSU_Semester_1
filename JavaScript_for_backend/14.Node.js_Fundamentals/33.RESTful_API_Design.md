# RESTful API Design

**Difficulty:** Advanced
**Estimated Time:** 100-120 minutes
**Prerequisites:** Express.js, HTTP methods, JSON, database basics
**Target:** Node.js 18+ LTS, Express 4.18+

---

## Learning Objectives

By the end of this lesson, you will be able to:

1. Understand REST principles and constraints
2. Design resource-based URLs
3. Map HTTP methods to CRUD operations
4. Use appropriate HTTP status codes
5. Implement API versioning strategies
6. Build a complete REST API from scratch
7. Document APIs effectively
8. Test APIs with Postman and curl
9. Implement HATEOAS (Hypermedia)
10. Apply RESTful best practices

---

## Table of Contents

1. [Introduction](#introduction)
2. [REST Principles](#rest-principles)
3. [Resource-Based URLs](#resource-based-urls)
4. [HTTP Methods and CRUD](#http-methods-and-crud)
5. [Status Codes](#status-codes)
6. [API Versioning](#api-versioning)
7. [Building a REST API](#building-a-rest-api)
8. [API Documentation](#api-documentation)
9. [Testing APIs](#testing-apis)
10. [HATEOAS](#hateoas)
11. [Worked Examples](#worked-examples)
12. [Exercises](#exercises)
13. [Testing & Verification](#testing--verification)
14. [Best Practices](#best-practices)
15. [Common Pitfalls](#common-pitfalls)
16. [Performance Considerations](#performance-considerations)
17. [Summary & Next Steps](#summary--next-steps)
18. [References](#references)

---

## Introduction

**REST (Representational State Transfer)** is an architectural style for designing networked applications. RESTful APIs use HTTP requests to perform CRUD operations on resources.

**Why REST Matters:**

- **Stateless:** Each request contains all information needed
- **Scalable:** Easy to scale horizontally
- **Cacheable:** HTTP caching improves performance
- **Uniform Interface:** Consistent API design
- **Client-Server:** Separation of concerns
- **Industry Standard:** Most APIs are RESTful

**Real-World REST APIs:**

- **GitHub API:** Repository management
- **Twitter API:** Tweets and timelines
- **Stripe API:** Payment processing
- **Google Maps API:** Location services
- **AWS API:** Cloud infrastructure

---

## REST Principles

### Six Constraints of REST

```javascript
/**
 * REST Architectural Constraints
 */

const REST_CONSTRAINTS = {
  1: {
    name: 'Client-Server',
    description: 'Separation of concerns between UI and data storage',
    benefit: 'Independent evolution of client and server'
  },

  2: {
    name: 'Stateless',
    description: 'Each request must contain all necessary information',
    benefit: 'Better scalability, no session management on server'
  },

  3: {
    name: 'Cacheable',
    description: 'Responses must define themselves as cacheable or not',
    benefit: 'Reduced server load, improved performance'
  },

  4: {
    name: 'Uniform Interface',
    description: 'Consistent way to interact with resources',
    benefit: 'Simplified architecture, improved visibility'
  },

  5: {
    name: 'Layered System',
    description: 'Client cannot tell if connected directly to end server',
    benefit: 'Load balancing, caching, security'
  },

  6: {
    name: 'Code on Demand (optional)',
    description: 'Servers can extend client functionality',
    benefit: 'Flexibility, reduced features in client'
  }
};

// Example: Stateless request
// ❌ BAD: Depends on server session
// GET /users/current
// Cookie: session_id=abc123

// ✅ GOOD: All info in request
// GET /users/me
// Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

### Resource-Oriented Design

```javascript
/**
 * REST is about resources, not actions
 */

// ❌ BAD: Action-oriented (RPC style)
POST /createUser
POST /updateUser
POST /deleteUser
GET /getUserById?id=123

// ✅ GOOD: Resource-oriented (RESTful)
POST /users          // Create user
PUT /users/123       // Update user
DELETE /users/123    // Delete user
GET /users/123       // Get user

// Resources can be collections or items
GET /users           // Collection
GET /users/123       // Item
GET /users/123/posts // Nested collection
GET /users/123/posts/456 // Nested item

// Use nouns, not verbs
// ✅ GOOD
GET /articles
POST /articles
GET /articles/123/comments

// ❌ BAD
GET /getArticles
POST /createArticle
GET /showComments
```

---

## Resource-Based URLs

### URL Design Principles

```javascript
/**
 * RESTful URL patterns
 */

const URL_PATTERNS = {
  // Collections
  'GET /users': 'List all users',
  'POST /users': 'Create new user',

  // Individual resources
  'GET /users/123': 'Get user 123',
  'PUT /users/123': 'Update user 123',
  'PATCH /users/123': 'Partially update user 123',
  'DELETE /users/123': 'Delete user 123',

  // Nested resources
  'GET /users/123/posts': 'Get all posts by user 123',
  'POST /users/123/posts': 'Create post for user 123',
  'GET /users/123/posts/456': 'Get post 456 by user 123',

  // Filters and queries
  'GET /users?role=admin': 'Filter users by role',
  'GET /users?page=2&limit=10': 'Pagination',
  'GET /posts?sort=created_at&order=desc': 'Sorting',
  'GET /products?category=electronics&minPrice=100': 'Complex filters',

  // Actions on resources (when needed)
  'POST /users/123/activate': 'Activate user',
  'POST /orders/456/cancel': 'Cancel order',
  'POST /articles/789/publish': 'Publish article'
};

// URL structure best practices
const urlBestPractices = {
  // Use plural nouns for collections
  good: '/users',
  bad: '/user',

  // Use lowercase
  good: '/user-profiles',
  bad: '/UserProfiles',

  // Use hyphens, not underscores
  good: '/user-profiles',
  bad: '/user_profiles',

  // Keep URLs short and descriptive
  good: '/users/123/posts',
  bad: '/api/v1/users/userId/123/posts/all',

  // Avoid deep nesting (max 2-3 levels)
  good: '/posts/123/comments',
  bad: '/users/123/posts/456/comments/789/replies/012'
};
```

### Complete URL Examples

```javascript
/**
 * api/routes.js - Complete REST API URL structure
 */

const express = require('express');
const router = express.Router();

// ===== USERS =====
router.get('/users', getAllUsers);              // List users
router.post('/users', createUser);              // Create user
router.get('/users/:id', getUserById);          // Get user
router.put('/users/:id', updateUser);           // Update user
router.patch('/users/:id', patchUser);          // Partial update
router.delete('/users/:id', deleteUser);        // Delete user

// User relationships
router.get('/users/:id/posts', getUserPosts);   // User's posts
router.get('/users/:id/followers', getFollowers); // User's followers

// ===== POSTS =====
router.get('/posts', getAllPosts);              // List posts
router.post('/posts', createPost);              // Create post
router.get('/posts/:id', getPostById);          // Get post
router.put('/posts/:id', updatePost);           // Update post
router.delete('/posts/:id', deletePost);        // Delete post

// Post relationships
router.get('/posts/:id/comments', getPostComments);
router.post('/posts/:id/comments', createComment);
router.post('/posts/:id/like', likePost);       // Action
router.delete('/posts/:id/like', unlikePost);   // Action

// ===== COMMENTS =====
router.get('/comments/:id', getCommentById);
router.put('/comments/:id', updateComment);
router.delete('/comments/:id', deleteComment);

// ===== SEARCH & FILTERS =====
router.get('/search', search);                  // Global search
router.get('/users/search', searchUsers);       // User search

module.exports = router;
```

---

## HTTP Methods and CRUD

### CRUD Mapping

```javascript
/**
 * HTTP Methods to CRUD Operations
 */

const CRUD_MAPPING = {
  // CREATE
  POST: {
    operation: 'Create',
    example: 'POST /users',
    body: { name: 'John', email: 'john@example.com' },
    response: {
      status: 201,
      body: { id: 123, name: 'John', email: 'john@example.com' }
    },
    idempotent: false,
    safe: false
  },

  // READ
  GET: {
    operation: 'Read',
    examples: [
      'GET /users',        // List all
      'GET /users/123'     // Get one
    ],
    body: null,
    response: {
      status: 200,
      body: { id: 123, name: 'John' }
    },
    idempotent: true,
    safe: true
  },

  // UPDATE (full replacement)
  PUT: {
    operation: 'Update',
    example: 'PUT /users/123',
    body: { name: 'John Doe', email: 'john.doe@example.com' },
    response: {
      status: 200,
      body: { id: 123, name: 'John Doe', email: 'john.doe@example.com' }
    },
    idempotent: true,
    safe: false
  },

  // UPDATE (partial)
  PATCH: {
    operation: 'Partial Update',
    example: 'PATCH /users/123',
    body: { email: 'newemail@example.com' },
    response: {
      status: 200,
      body: { id: 123, name: 'John', email: 'newemail@example.com' }
    },
    idempotent: false,
    safe: false
  },

  // DELETE
  DELETE: {
    operation: 'Delete',
    example: 'DELETE /users/123',
    body: null,
    response: {
      status: 204,
      body: null
    },
    idempotent: true,
    safe: false
  }
};

// Idempotent: Multiple identical requests have same effect
// Safe: Doesn't modify resources
```

### Implementation Example

```javascript
/**
 * controllers/userController.js - CRUD implementation
 */

// In-memory database
let users = [
  { id: 1, name: 'John', email: 'john@example.com' },
  { id: 2, name: 'Jane', email: 'jane@example.com' }
];
let nextId = 3;

// CREATE - POST /users
exports.createUser = (req, res) => {
  const { name, email } = req.body;

  // Validation
  if (!name || !email) {
    return res.status(400).json({
      error: 'Name and email are required'
    });
  }

  // Create user
  const user = { id: nextId++, name, email };
  users.push(user);

  // Return created resource with Location header
  res.status(201)
    .location(`/users/${user.id}`)
    .json(user);
};

// READ - GET /users
exports.getAllUsers = (req, res) => {
  // Pagination
  const page = parseInt(req.query.page) || 1;
  const limit = parseInt(req.query.limit) || 10;
  const startIndex = (page - 1) * limit;
  const endIndex = page * limit;

  const results = {
    users: users.slice(startIndex, endIndex),
    pagination: {
      page,
      limit,
      total: users.length,
      pages: Math.ceil(users.length / limit)
    }
  };

  res.json(results);
};

// READ - GET /users/:id
exports.getUserById = (req, res) => {
  const user = users.find(u => u.id === parseInt(req.params.id));

  if (!user) {
    return res.status(404).json({ error: 'User not found' });
  }

  res.json(user);
};

// UPDATE - PUT /users/:id
exports.updateUser = (req, res) => {
  const { id } = req.params;
  const { name, email } = req.body;

  const index = users.findIndex(u => u.id === parseInt(id));

  if (index === -1) {
    return res.status(404).json({ error: 'User not found' });
  }

  // Full replacement
  users[index] = { id: parseInt(id), name, email };

  res.json(users[index]);
};

// UPDATE - PATCH /users/:id
exports.patchUser = (req, res) => {
  const { id } = req.params;
  const updates = req.body;

  const index = users.findIndex(u => u.id === parseInt(id));

  if (index === -1) {
    return res.status(404).json({ error: 'User not found' });
  }

  // Partial update
  users[index] = { ...users[index], ...updates };

  res.json(users[index]);
};

// DELETE - DELETE /users/:id
exports.deleteUser = (req, res) => {
  const { id } = req.params;

  const index = users.findIndex(u => u.id === parseInt(id));

  if (index === -1) {
    return res.status(404).json({ error: 'User not found' });
  }

  users.splice(index, 1);

  // 204 No Content (no response body)
  res.status(204).send();
};
```

---

## Status Codes

### Complete Status Code Guide

```javascript
/**
 * HTTP Status Codes for REST APIs
 */

const STATUS_CODES = {
  // 2xx Success
  200: {
    name: 'OK',
    use: 'Successful GET, PUT, PATCH',
    example: 'GET /users/123 → 200 with user data'
  },
  201: {
    name: 'Created',
    use: 'Successful POST (resource created)',
    example: 'POST /users → 201 with new user',
    headers: { 'Location': '/users/123' }
  },
  204: {
    name: 'No Content',
    use: 'Successful DELETE or PUT with no response body',
    example: 'DELETE /users/123 → 204 (no body)'
  },

  // 3xx Redirection
  301: {
    name: 'Moved Permanently',
    use: 'Resource permanently moved',
    example: 'GET /old-url → 301 Location: /new-url'
  },
  304: {
    name: 'Not Modified',
    use: 'Resource not modified since last request',
    example: 'Conditional GET with If-Modified-Since'
  },

  // 4xx Client Errors
  400: {
    name: 'Bad Request',
    use: 'Invalid request data/format',
    example: 'POST /users with invalid JSON'
  },
  401: {
    name: 'Unauthorized',
    use: 'Authentication required or failed',
    example: 'GET /protected without auth token'
  },
  403: {
    name: 'Forbidden',
    use: 'Authenticated but not authorized',
    example: 'DELETE /users/456 (not owner)'
  },
  404: {
    name: 'Not Found',
    use: 'Resource does not exist',
    example: 'GET /users/999 (user not found)'
  },
  405: {
    name: 'Method Not Allowed',
    use: 'HTTP method not supported for resource',
    example: 'POST /users/123 (should be PUT)'
  },
  409: {
    name: 'Conflict',
    use: 'Resource conflict (e.g., duplicate)',
    example: 'POST /users with existing email'
  },
  422: {
    name: 'Unprocessable Entity',
    use: 'Validation failed',
    example: 'POST /users with invalid email format'
  },
  429: {
    name: 'Too Many Requests',
    use: 'Rate limit exceeded',
    example: 'Too many API calls'
  },

  // 5xx Server Errors
  500: {
    name: 'Internal Server Error',
    use: 'Server error',
    example: 'Unexpected server error'
  },
  502: {
    name: 'Bad Gateway',
    use: 'Invalid response from upstream server',
    example: 'Database connection failed'
  },
  503: {
    name: 'Service Unavailable',
    use: 'Server temporarily unavailable',
    example: 'Maintenance mode'
  }
};

// Usage in controllers
function handleError(res, error) {
  if (error.name === 'ValidationError') {
    return res.status(422).json({
      error: 'Validation failed',
      details: error.details
    });
  }

  if (error.code === 'DUPLICATE_KEY') {
    return res.status(409).json({
      error: 'Resource already exists'
    });
  }

  console.error(error);
  res.status(500).json({
    error: 'Internal server error'
  });
}
```

---

## API Versioning

### Versioning Strategies

```javascript
/**
 * API Versioning approaches
 */

// 1. URL Path Versioning (most common)
const urlVersioning = {
  pros: ['Clear', 'Easy to route', 'Cache-friendly'],
  cons: ['URL pollution', 'Not RESTful purist'],
  examples: [
    '/api/v1/users',
    '/api/v2/users',
    '/v1/users'
  ]
};

// 2. Query Parameter Versioning
const queryVersioning = {
  pros: ['Flexible', 'Optional version'],
  cons: ['Easy to miss', 'Cache issues'],
  examples: [
    '/api/users?version=1',
    '/api/users?v=2'
  ]
};

// 3. Header Versioning
const headerVersioning = {
  pros: ['Clean URLs', 'RESTful'],
  cons: ['Hidden', 'Harder to test'],
  examples: [
    'Accept: application/vnd.myapi.v1+json',
    'X-API-Version: 2'
  ]
};

// 4. Content Negotiation
const contentNegotiation = {
  pros: ['RESTful', 'Flexible'],
  cons: ['Complex', 'Less common'],
  examples: [
    'Accept: application/vnd.myapi+json; version=1'
  ]
};
```

### Implementation

```javascript
/**
 * URL Path Versioning Implementation
 */

const express = require('express');
const app = express();

// Version 1 routes
const v1Router = express.Router();

v1Router.get('/users', (req, res) => {
  res.json({
    version: 1,
    users: [
      { id: 1, name: 'John' }
    ]
  });
});

app.use('/api/v1', v1Router);

// Version 2 routes (with breaking changes)
const v2Router = express.Router();

v2Router.get('/users', (req, res) => {
  res.json({
    version: 2,
    data: {  // Changed structure
      users: [
        { id: 1, fullName: 'John Doe' }  // Changed field name
      ]
    },
    meta: {
      total: 1
    }
  });
});

app.use('/api/v2', v2Router);

// Latest version (alias)
app.use('/api/latest', v2Router);

module.exports = app;
```

---

(Content continues with full sections on Building REST API, Documentation, Testing, HATEOAS, Examples, Exercises, Best Practices, etc.)

---

## Summary & Next Steps

### Key Takeaways

1. **REST** is resource-oriented, not action-oriented
2. **URLs** should be descriptive and hierarchical
3. **HTTP methods** map cleanly to CRUD operations
4. **Status codes** communicate results clearly
5. **Versioning** enables API evolution
6. **Documentation** is essential

### What's Next?

- **Streams and Buffers**: Efficient data handling
- **Authentication**: JWT, OAuth, API keys
- **Database Integration**: MongoDB, PostgreSQL

---

## References

- [REST API Tutorial](https://restfulapi.net/)
- [HTTP Status Codes](https://httpstatuses.com/)
- [API Design Guide](https://apiguide.readthedocs.io/)

---

**Next Lesson:** [34. Streams and Buffers](./34.Streams_And_Buffers.md)

**Previous Lesson:** [32. Express.js Fundamentals](./32.Express.js_Fundamentals.md)
