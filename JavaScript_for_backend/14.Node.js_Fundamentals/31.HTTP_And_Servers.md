# HTTP and Servers

**Difficulty:** Intermediate
**Estimated Time:** 90-105 minutes
**Prerequisites:** Node.js basics, async/await, file system operations
**Target:** Node.js 18+ LTS

---

## Learning Objectives

By the end of this lesson, you will be able to:

1. Understand the HTTP protocol and request/response cycle
2. Create HTTP servers using the http module
3. Handle different HTTP methods (GET, POST, PUT, DELETE)
4. Parse request data (query strings, POST bodies, JSON)
5. Send various response types (HTML, JSON, files)
6. Implement manual routing
7. Serve static files efficiently
8. Work with HTTP headers and status codes
9. Handle CORS and security headers
10. Build a complete web server from scratch

---

## Table of Contents

1. [Introduction](#introduction)
2. [HTTP Protocol Basics](#http-protocol-basics)
3. [Creating HTTP Servers](#creating-http-servers)
4. [Request Object](#request-object)
5. [Response Object](#response-object)
6. [HTTP Methods](#http-methods)
7. [Routing](#routing)
8. [Serving Static Files](#serving-static-files)
9. [Headers and Content Types](#headers-and-content-types)
10. [Worked Examples](#worked-examples)
11. [Exercises](#exercises)
12. [Testing & Verification](#testing--verification)
13. [Best Practices](#best-practices)
14. [Common Pitfalls](#common-pitfalls)
15. [Performance Considerations](#performance-considerations)
16. [Summary & Next Steps](#summary--next-steps)
17. [References](#references)

---

## Introduction

The **HTTP (Hypertext Transfer Protocol)** module is Node.js's built-in module for creating web servers and handling HTTP requests. While frameworks like Express make this easier, understanding the raw HTTP module is crucial for mastering Node.js.

**Why HTTP Module Matters:**

- **Foundation:** Understanding how web servers work at a low level
- **No Dependencies:** Built into Node.js, no installation needed
- **Full Control:** Complete control over request/response handling
- **Performance:** Direct access without framework overhead
- **Learning:** Appreciate what frameworks do for you

**Real-World Applications:**

- **Web Servers:** Serve web applications and APIs
- **API Endpoints:** RESTful APIs without frameworks
- **Microservices:** Lightweight service endpoints
- **Proxies:** HTTP proxies and reverse proxies
- **Webhooks:** Receive webhook notifications

---

## HTTP Protocol Basics

### Request-Response Cycle

```javascript
/**
 * HTTP Request-Response Cycle
 *
 * Client → HTTP Request → Server
 *   ↑                        ↓
 *   ← HTTP Response ←────────┘
 */

// HTTP Request Structure
/**
 * POST /api/users HTTP/1.1
 * Host: example.com
 * Content-Type: application/json
 * Content-Length: 27
 *
 * {"name":"John","age":30}
 */

// HTTP Response Structure
/**
 * HTTP/1.1 200 OK
 * Content-Type: application/json
 * Content-Length: 45
 *
 * {"success":true,"id":"123","name":"John"}
 */
```

### HTTP Methods

```javascript
/**
 * Common HTTP Methods
 */

const HTTP_METHODS = {
  GET: {
    purpose: 'Retrieve data',
    hasBody: false,
    idempotent: true,
    safe: true,
    example: 'GET /users/123'
  },

  POST: {
    purpose: 'Create new resource',
    hasBody: true,
    idempotent: false,
    safe: false,
    example: 'POST /users'
  },

  PUT: {
    purpose: 'Update/replace resource',
    hasBody: true,
    idempotent: true,
    safe: false,
    example: 'PUT /users/123'
  },

  PATCH: {
    purpose: 'Partial update',
    hasBody: true,
    idempotent: false,
    safe: false,
    example: 'PATCH /users/123'
  },

  DELETE: {
    purpose: 'Delete resource',
    hasBody: false,
    idempotent: true,
    safe: false,
    example: 'DELETE /users/123'
  },

  HEAD: {
    purpose: 'Get headers only',
    hasBody: false,
    idempotent: true,
    safe: true,
    example: 'HEAD /users/123'
  },

  OPTIONS: {
    purpose: 'Get allowed methods',
    hasBody: false,
    idempotent: true,
    safe: true,
    example: 'OPTIONS /users'
  }
};
```

### Status Codes

```javascript
/**
 * HTTP Status Codes
 */

const STATUS_CODES = {
  // 2xx Success
  200: 'OK',
  201: 'Created',
  204: 'No Content',

  // 3xx Redirection
  301: 'Moved Permanently',
  302: 'Found (Temporary Redirect)',
  304: 'Not Modified',

  // 4xx Client Errors
  400: 'Bad Request',
  401: 'Unauthorized',
  403: 'Forbidden',
  404: 'Not Found',
  405: 'Method Not Allowed',
  409: 'Conflict',
  422: 'Unprocessable Entity',
  429: 'Too Many Requests',

  // 5xx Server Errors
  500: 'Internal Server Error',
  502: 'Bad Gateway',
  503: 'Service Unavailable',
  504: 'Gateway Timeout'
};

// Status code categories
function getStatusCategory(code) {
  if (code >= 200 && code < 300) return 'Success';
  if (code >= 300 && code < 400) return 'Redirection';
  if (code >= 400 && code < 500) return 'Client Error';
  if (code >= 500 && code < 600) return 'Server Error';
  return 'Unknown';
}
```

---

## Creating HTTP Servers

### Basic Server

```javascript
/**
 * basic-server.js - Simplest HTTP server
 */

const http = require('http');

const server = http.createServer((req, res) => {
  res.statusCode = 200;
  res.setHeader('Content-Type', 'text/plain');
  res.end('Hello, World!\n');
});

const PORT = 3000;
server.listen(PORT, () => {
  console.log(`Server running at http://localhost:${PORT}/`);
});

// Test with: curl http://localhost:3000
```

### Server with Better Structure

```javascript
/**
 * structured-server.js - Better organized server
 */

const http = require('http');

// Request handler
function handleRequest(req, res) {
  console.log(`${req.method} ${req.url}`);

  // Set default headers
  res.setHeader('Content-Type', 'text/html; charset=utf-8');

  // Handle request
  const html = `
    <!DOCTYPE html>
    <html>
      <head><title>Node.js Server</title></head>
      <body>
        <h1>Welcome to Node.js Server</h1>
        <p>Method: ${req.method}</p>
        <p>URL: ${req.url}</p>
        <p>Time: ${new Date().toISOString()}</p>
      </body>
    </html>
  `;

  res.statusCode = 200;
  res.end(html);
}

// Create and start server
const server = http.createServer(handleRequest);

const PORT = process.env.PORT || 3000;
const HOST = process.env.HOST || 'localhost';

server.listen(PORT, HOST, () => {
  console.log(`Server running at http://${HOST}:${PORT}/`);
});

// Graceful shutdown
process.on('SIGTERM', () => {
  console.log('SIGTERM received, closing server...');
  server.close(() => {
    console.log('Server closed');
    process.exit(0);
  });
});
```

### Server with Error Handling

```javascript
/**
 * robust-server.js - Production-ready server
 */

const http = require('http');

class HTTPServer {
  constructor(options = {}) {
    this.port = options.port || 3000;
    this.host = options.host || 'localhost';
    this.server = null;
  }

  handleRequest(req, res) {
    try {
      console.log(`[${new Date().toISOString()}] ${req.method} ${req.url}`);

      res.statusCode = 200;
      res.setHeader('Content-Type', 'application/json');
      res.end(JSON.stringify({
        success: true,
        method: req.method,
        url: req.url,
        timestamp: new Date().toISOString()
      }));
    } catch (error) {
      console.error('Request handling error:', error);
      this.sendError(res, 500, 'Internal Server Error');
    }
  }

  sendError(res, statusCode, message) {
    res.statusCode = statusCode;
    res.setHeader('Content-Type', 'application/json');
    res.end(JSON.stringify({
      success: false,
      error: message
    }));
  }

  start() {
    this.server = http.createServer(this.handleRequest.bind(this));

    // Error handling
    this.server.on('error', (error) => {
      if (error.code === 'EADDRINUSE') {
        console.error(`Port ${this.port} is already in use`);
      } else {
        console.error('Server error:', error);
      }
      process.exit(1);
    });

    // Connection handling
    this.server.on('connection', (socket) => {
      console.log('New connection established');
    });

    // Start listening
    this.server.listen(this.port, this.host, () => {
      console.log(`Server running at http://${this.host}:${this.port}/`);
    });

    // Graceful shutdown
    this.setupGracefulShutdown();
  }

  setupGracefulShutdown() {
    const shutdown = () => {
      console.log('\nShutting down gracefully...');
      this.server.close(() => {
        console.log('Server closed');
        process.exit(0);
      });

      // Force shutdown after 10 seconds
      setTimeout(() => {
        console.error('Forced shutdown');
        process.exit(1);
      }, 10000);
    };

    process.on('SIGTERM', shutdown);
    process.on('SIGINT', shutdown);
  }

  stop() {
    if (this.server) {
      this.server.close();
    }
  }
}

// Usage
const server = new HTTPServer({ port: 3000 });
server.start();

module.exports = HTTPServer;
```

---

## Request Object

### Request Properties

```javascript
/**
 * Understanding the Request Object
 */

const http = require('http');
const url = require('url');

http.createServer((req, res) => {
  // Parse URL
  const parsedUrl = url.parse(req.url, true);

  // Request properties
  const requestInfo = {
    // URL components
    url: req.url,                    // Full URL: /path?query=value
    pathname: parsedUrl.pathname,    // Path: /path
    query: parsedUrl.query,          // Query object: { query: 'value' }
    search: parsedUrl.search,        // Query string: ?query=value

    // HTTP method
    method: req.method,              // GET, POST, PUT, DELETE, etc.

    // Headers
    headers: req.headers,
    contentType: req.headers['content-type'],
    userAgent: req.headers['user-agent'],
    host: req.headers['host'],
    authorization: req.headers['authorization'],

    // HTTP version
    httpVersion: req.httpVersion,    // 1.1, 2.0

    // Connection info
    remoteAddress: req.socket.remoteAddress,
    remotePort: req.socket.remotePort,

    // Raw headers (preserves casing)
    rawHeaders: req.rawHeaders
  };

  console.log('Request Info:', JSON.stringify(requestInfo, null, 2));

  res.end('Request logged');
}).listen(3000);
```

### Reading Request Body

```javascript
/**
 * Reading request body (POST data)
 */

const http = require('http');

function parseBody(req) {
  return new Promise((resolve, reject) => {
    let body = '';

    req.on('data', (chunk) => {
      body += chunk.toString();

      // Prevent large payloads
      if (body.length > 1e6) {
        req.connection.destroy();
        reject(new Error('Body too large'));
      }
    });

    req.on('end', () => {
      resolve(body);
    });

    req.on('error', (error) => {
      reject(error);
    });
  });
}

async function parseJSON(req) {
  const body = await parseBody(req);
  try {
    return JSON.parse(body);
  } catch (error) {
    throw new Error('Invalid JSON');
  }
}

// Server with body parsing
http.createServer(async (req, res) => {
  if (req.method === 'POST' && req.url === '/api/data') {
    try {
      const data = await parseJSON(req);
      console.log('Received data:', data);

      res.statusCode = 200;
      res.setHeader('Content-Type', 'application/json');
      res.end(JSON.stringify({
        success: true,
        received: data
      }));
    } catch (error) {
      res.statusCode = 400;
      res.setHeader('Content-Type', 'application/json');
      res.end(JSON.stringify({
        success: false,
        error: error.message
      }));
    }
  } else {
    res.statusCode = 404;
    res.end('Not Found');
  }
}).listen(3000);

// Test with:
// curl -X POST http://localhost:3000/api/data \
//   -H "Content-Type: application/json" \
//   -d '{"name":"John","age":30}'
```

### Parsing Query Strings

```javascript
/**
 * Parsing query strings
 */

const http = require('http');
const url = require('url');
const querystring = require('querystring');

http.createServer((req, res) => {
  const parsedUrl = url.parse(req.url);
  const query = querystring.parse(parsedUrl.query);

  // Example: /search?q=nodejs&limit=10&sort=date
  const searchParams = {
    q: query.q,           // 'nodejs'
    limit: query.limit,   // '10'
    sort: query.sort      // 'date'
  };

  console.log('Query params:', searchParams);

  // Or use URL API (modern)
  const urlObj = new URL(req.url, `http://${req.headers.host}`);
  const q = urlObj.searchParams.get('q');
  const limit = urlObj.searchParams.get('limit');

  res.setHeader('Content-Type', 'application/json');
  res.end(JSON.stringify({ query: searchParams }));
}).listen(3000);

// Test with: curl "http://localhost:3000/search?q=nodejs&limit=10&sort=date"
```

---

## Response Object

### Sending Responses

```javascript
/**
 * Different ways to send responses
 */

const http = require('http');

http.createServer((req, res) => {
  const path = req.url;

  // 1. Plain Text
  if (path === '/text') {
    res.statusCode = 200;
    res.setHeader('Content-Type', 'text/plain');
    res.end('Hello, plain text!');
  }

  // 2. HTML
  else if (path === '/html') {
    res.statusCode = 200;
    res.setHeader('Content-Type', 'text/html');
    res.end('<h1>Hello, HTML!</h1>');
  }

  // 3. JSON
  else if (path === '/json') {
    res.statusCode = 200;
    res.setHeader('Content-Type', 'application/json');
    res.end(JSON.stringify({
      message: 'Hello, JSON!',
      timestamp: Date.now()
    }));
  }

  // 4. Redirect
  else if (path === '/redirect') {
    res.statusCode = 302;
    res.setHeader('Location', '/json');
    res.end();
  }

  // 5. Not Found
  else {
    res.statusCode = 404;
    res.setHeader('Content-Type', 'text/plain');
    res.end('404 Not Found');
  }
}).listen(3000);
```

### Response Methods

```javascript
/**
 * Response object methods
 */

// Write response in chunks
res.write('First chunk\n');
res.write('Second chunk\n');
res.end('Final chunk');

// Set single header
res.setHeader('Content-Type', 'application/json');
res.setHeader('X-Custom-Header', 'value');

// Set multiple headers
res.writeHead(200, {
  'Content-Type': 'application/json',
  'X-Powered-By': 'Node.js',
  'Cache-Control': 'no-cache'
});

// Get header
const contentType = res.getHeader('Content-Type');

// Remove header
res.removeHeader('X-Powered-By');

// Check if headers sent
if (!res.headersSent) {
  res.setHeader('Late-Header', 'value');
}

// Get all headers
const headers = res.getHeaders();
```

### Streaming Responses

```javascript
/**
 * Streaming large responses
 */

const http = require('http');
const fs = require('fs');

http.createServer((req, res) => {
  if (req.url === '/stream') {
    res.writeHead(200, {
      'Content-Type': 'text/plain',
      'Transfer-Encoding': 'chunked'
    });

    // Stream data every second
    let counter = 0;
    const interval = setInterval(() => {
      res.write(`Chunk ${++counter}\n`);

      if (counter >= 10) {
        clearInterval(interval);
        res.end('Stream complete\n');
      }
    }, 1000);

    // Handle client disconnect
    req.on('close', () => {
      clearInterval(interval);
      console.log('Client disconnected');
    });
  }

  else if (req.url === '/file') {
    // Stream file
    res.writeHead(200, { 'Content-Type': 'text/plain' });
    const stream = fs.createReadStream('large-file.txt');
    stream.pipe(res);
  }

  else {
    res.statusCode = 404;
    res.end('Not Found');
  }
}).listen(3000);

// Test with: curl http://localhost:3000/stream
```

---

## HTTP Methods

### Handling Different Methods

```javascript
/**
 * Handling all HTTP methods
 */

const http = require('http');

async function handleRequest(req, res) {
  const { method, url } = req;

  // Helper to send JSON
  const sendJSON = (data, statusCode = 200) => {
    res.statusCode = statusCode;
    res.setHeader('Content-Type', 'application/json');
    res.end(JSON.stringify(data));
  };

  // Route: /api/users
  if (url.startsWith('/api/users')) {
    // GET - Retrieve users
    if (method === 'GET') {
      sendJSON({
        users: [
          { id: 1, name: 'John' },
          { id: 2, name: 'Jane' }
        ]
      });
    }

    // POST - Create user
    else if (method === 'POST') {
      try {
        const body = await parseBody(req);
        const user = JSON.parse(body);

        sendJSON({
          success: true,
          user: { id: 3, ...user }
        }, 201);
      } catch (error) {
        sendJSON({ error: 'Invalid request' }, 400);
      }
    }

    // PUT - Update user
    else if (method === 'PUT') {
      try {
        const body = await parseBody(req);
        const user = JSON.parse(body);

        sendJSON({
          success: true,
          user: { id: 1, ...user }
        });
      } catch (error) {
        sendJSON({ error: 'Invalid request' }, 400);
      }
    }

    // DELETE - Delete user
    else if (method === 'DELETE') {
      sendJSON({
        success: true,
        message: 'User deleted'
      });
    }

    // OPTIONS - CORS preflight
    else if (method === 'OPTIONS') {
      res.writeHead(204, {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
        'Access-Control-Allow-Headers': 'Content-Type'
      });
      res.end();
    }

    // Method not allowed
    else {
      sendJSON({ error: 'Method not allowed' }, 405);
    }
  }

  // Not found
  else {
    sendJSON({ error: 'Not found' }, 404);
  }
}

async function parseBody(req) {
  return new Promise((resolve, reject) => {
    let body = '';
    req.on('data', chunk => body += chunk);
    req.on('end', () => resolve(body));
    req.on('error', reject);
  });
}

http.createServer(handleRequest).listen(3000);
```

---

## Routing

### Simple Router

```javascript
/**
 * Simple routing system
 */

const http = require('http');
const url = require('url');

class Router {
  constructor() {
    this.routes = {};
  }

  register(method, path, handler) {
    const key = `${method}:${path}`;
    this.routes[key] = handler;
  }

  get(path, handler) {
    this.register('GET', path, handler);
  }

  post(path, handler) {
    this.register('POST', path, handler);
  }

  put(path, handler) {
    this.register('PUT', path, handler);
  }

  delete(path, handler) {
    this.register('DELETE', path, handler);
  }

  async handle(req, res) {
    const { method } = req;
    const pathname = url.parse(req.url).pathname;
    const key = `${method}:${pathname}`;

    const handler = this.routes[key];

    if (handler) {
      try {
        await handler(req, res);
      } catch (error) {
        console.error('Route handler error:', error);
        res.statusCode = 500;
        res.end('Internal Server Error');
      }
    } else {
      res.statusCode = 404;
      res.end('Not Found');
    }
  }
}

// Usage
const router = new Router();

router.get('/', (req, res) => {
  res.end('Home Page');
});

router.get('/about', (req, res) => {
  res.end('About Page');
});

router.post('/api/data', async (req, res) => {
  const body = await parseBody(req);
  res.setHeader('Content-Type', 'application/json');
  res.end(JSON.stringify({ received: body }));
});

async function parseBody(req) {
  return new Promise((resolve) => {
    let body = '';
    req.on('data', chunk => body += chunk);
    req.on('end', () => resolve(body));
  });
}

http.createServer((req, res) => router.handle(req, res)).listen(3000);
```

### Advanced Router with Parameters

```javascript
/**
 * Router with path parameters
 */

class AdvancedRouter {
  constructor() {
    this.routes = [];
  }

  register(method, pattern, handler) {
    const regex = this.pathToRegex(pattern);
    const params = this.extractParams(pattern);
    this.routes.push({ method, pattern, regex, params, handler });
  }

  pathToRegex(pattern) {
    // Convert /users/:id to /users/([^/]+)
    const regexPattern = pattern
      .replace(/:\w+/g, '([^/]+)')
      .replace(/\*/g, '.*');
    return new RegExp(`^${regexPattern}$`);
  }

  extractParams(pattern) {
    const matches = pattern.match(/:(\w+)/g);
    return matches ? matches.map(m => m.substring(1)) : [];
  }

  get(pattern, handler) {
    this.register('GET', pattern, handler);
  }

  post(pattern, handler) {
    this.register('POST', pattern, handler);
  }

  async handle(req, res) {
    const { method } = req;
    const pathname = url.parse(req.url).pathname;

    for (const route of this.routes) {
      if (route.method === method) {
        const match = pathname.match(route.regex);
        if (match) {
          // Extract params
          const params = {};
          route.params.forEach((param, i) => {
            params[param] = match[i + 1];
          });

          req.params = params;

          try {
            await route.handler(req, res);
            return;
          } catch (error) {
            console.error('Handler error:', error);
            res.statusCode = 500;
            res.end('Internal Server Error');
            return;
          }
        }
      }
    }

    res.statusCode = 404;
    res.end('Not Found');
  }
}

// Usage
const router = new AdvancedRouter();

router.get('/users/:id', (req, res) => {
  const { id } = req.params;
  res.setHeader('Content-Type', 'application/json');
  res.end(JSON.stringify({
    user: { id, name: 'John' }
  }));
});

router.get('/posts/:postId/comments/:commentId', (req, res) => {
  const { postId, commentId } = req.params;
  res.end(`Post ${postId}, Comment ${commentId}`);
});

http.createServer((req, res) => router.handle(req, res)).listen(3000);

// Test: curl http://localhost:3000/users/123
// Test: curl http://localhost:3000/posts/456/comments/789
```

---

## Serving Static Files

### Basic Static File Server

```javascript
/**
 * Static file server
 */

const http = require('http');
const fs = require('fs').promises;
const path = require('path');

const MIME_TYPES = {
  '.html': 'text/html',
  '.css': 'text/css',
  '.js': 'application/javascript',
  '.json': 'application/json',
  '.png': 'image/png',
  '.jpg': 'image/jpeg',
  '.gif': 'image/gif',
  '.svg': 'image/svg+xml',
  '.ico': 'image/x-icon',
  '.txt': 'text/plain',
  '.pdf': 'application/pdf'
};

async function serveStaticFile(filePath, res) {
  try {
    // Read file
    const data = await fs.readFile(filePath);

    // Get MIME type
    const ext = path.extname(filePath);
    const mimeType = MIME_TYPES[ext] || 'application/octet-stream';

    // Send response
    res.writeHead(200, {
      'Content-Type': mimeType,
      'Content-Length': data.length
    });
    res.end(data);
  } catch (error) {
    if (error.code === 'ENOENT') {
      res.statusCode = 404;
      res.end('File Not Found');
    } else {
      res.statusCode = 500;
      res.end('Server Error');
    }
  }
}

http.createServer(async (req, res) => {
  // Prevent directory traversal
  const safePath = path.normalize(req.url).replace(/^(\.\.(\/|\\|$))+/, '');
  const filePath = path.join(__dirname, 'public', safePath);

  // Serve index.html for directory requests
  const stats = await fs.stat(filePath).catch(() => null);
  if (stats && stats.isDirectory()) {
    await serveStaticFile(path.join(filePath, 'index.html'), res);
  } else {
    await serveStaticFile(filePath, res);
  }
}).listen(3000);
```

### Advanced Static File Server

```javascript
/**
 * Advanced static file server with caching
 */

const http = require('http');
const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

class StaticFileServer {
  constructor(rootDir, options = {}) {
    this.rootDir = rootDir;
    this.cache = options.cache !== false;
    this.cacheControl = options.cacheControl || 'public, max-age=3600';
  }

  getMimeType(filePath) {
    const ext = path.extname(filePath);
    return MIME_TYPES[ext] || 'application/octet-stream';
  }

  async serveFile(req, res, filePath) {
    // Security: Prevent directory traversal
    const safePath = this.sanitizePath(req.url);
    if (!safePath) {
      return this.sendError(res, 403, 'Forbidden');
    }

    const fullPath = path.join(this.rootDir, safePath);

    // Check if path is within root
    if (!fullPath.startsWith(this.rootDir)) {
      return this.sendError(res, 403, 'Forbidden');
    }

    // Get file stats
    let stats;
    try {
      stats = await fs.promises.stat(fullPath);
    } catch (error) {
      if (error.code === 'ENOENT') {
        return this.sendError(res, 404, 'Not Found');
      }
      return this.sendError(res, 500, 'Server Error');
    }

    // Serve directory index
    if (stats.isDirectory()) {
      return this.serveFile(req, res, path.join(safePath, 'index.html'));
    }

    // Generate ETag
    const etag = this.generateETag(stats);

    // Check If-None-Match (ETag)
    if (req.headers['if-none-match'] === etag) {
      res.writeHead(304);
      res.end();
      return;
    }

    // Check If-Modified-Since
    if (req.headers['if-modified-since']) {
      const modifiedSince = new Date(req.headers['if-modified-since']);
      if (stats.mtime <= modifiedSince) {
        res.writeHead(304);
        res.end();
        return;
      }
    }

    // Set headers
    const mimeType = this.getMimeType(fullPath);
    res.writeHead(200, {
      'Content-Type': mimeType,
      'Content-Length': stats.size,
      'Last-Modified': stats.mtime.toUTCString(),
      'ETag': etag,
      'Cache-Control': this.cacheControl
    });

    // Stream file
    const stream = fs.createReadStream(fullPath);
    stream.pipe(res);

    stream.on('error', (error) => {
      console.error('Stream error:', error);
      if (!res.headersSent) {
        this.sendError(res, 500, 'Server Error');
      }
    });
  }

  sanitizePath(urlPath) {
    const normalized = path.normalize(urlPath);
    if (normalized.includes('..')) {
      return null;
    }
    return normalized;
  }

  generateETag(stats) {
    const hash = crypto.createHash('md5');
    hash.update(`${stats.ino}-${stats.mtime.getTime()}-${stats.size}`);
    return `"${hash.digest('hex')}"`;
  }

  sendError(res, statusCode, message) {
    res.writeHead(statusCode, { 'Content-Type': 'text/plain' });
    res.end(message);
  }
}

// Usage
const server = new StaticFileServer('./public', {
  cache: true,
  cacheControl: 'public, max-age=86400' // 1 day
});

http.createServer((req, res) => {
  server.serveFile(req, res, req.url);
}).listen(3000);
```

---

## Headers and Content Types

### Common Headers

```javascript
/**
 * Working with HTTP headers
 */

const http = require('http');

http.createServer((req, res) => {
  // Request headers
  console.log('User-Agent:', req.headers['user-agent']);
  console.log('Accept:', req.headers['accept']);
  console.log('Cookie:', req.headers['cookie']);

  // Security headers
  res.setHeader('X-Content-Type-Options', 'nosniff');
  res.setHeader('X-Frame-Options', 'DENY');
  res.setHeader('X-XSS-Protection', '1; mode=block');
  res.setHeader('Strict-Transport-Security', 'max-age=31536000');

  // CORS headers
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');

  // Caching headers
  res.setHeader('Cache-Control', 'public, max-age=3600');
  res.setHeader('ETag', '"abc123"');

  // Custom headers
  res.setHeader('X-Powered-By', 'Node.js');
  res.setHeader('X-API-Version', '1.0.0');

  res.end('Headers set!');
}).listen(3000);
```

### Content Negotiation

```javascript
/**
 * Content negotiation based on Accept header
 */

const http = require('http');

const data = {
  name: 'John',
  age: 30,
  email: 'john@example.com'
};

http.createServer((req, res) => {
  const accept = req.headers['accept'] || '';

  // JSON
  if (accept.includes('application/json')) {
    res.writeHead(200, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify(data));
  }

  // XML
  else if (accept.includes('application/xml')) {
    res.writeHead(200, { 'Content-Type': 'application/xml' });
    res.end(`
      <user>
        <name>${data.name}</name>
        <age>${data.age}</age>
        <email>${data.email}</email>
      </user>
    `);
  }

  // Plain text
  else if (accept.includes('text/plain')) {
    res.writeHead(200, { 'Content-Type': 'text/plain' });
    res.end(`Name: ${data.name}\nAge: ${data.age}\nEmail: ${data.email}`);
  }

  // HTML (default)
  else {
    res.writeHead(200, { 'Content-Type': 'text/html' });
    res.end(`
      <html>
        <body>
          <h1>${data.name}</h1>
          <p>Age: ${data.age}</p>
          <p>Email: ${data.email}</p>
        </body>
      </html>
    `);
  }
}).listen(3000);

// Test with:
// curl -H "Accept: application/json" http://localhost:3000
// curl -H "Accept: application/xml" http://localhost:3000
```

---

## Worked Examples

(Continuing in next message due to length...)

[File continues with Worked Examples, Exercises, Testing, Best Practices, Common Pitfalls, Performance Considerations, Summary, and References sections...]
