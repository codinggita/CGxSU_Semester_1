# File System Operations

**Difficulty:** Intermediate
**Estimated Time:** 85-100 minutes
**Prerequisites:** Node.js basics, async/await, callbacks, promises
**Target:** Node.js 18+ LTS

---

## Learning Objectives

By the end of this lesson, you will be able to:

1. Use the fs module for file operations (sync, async, promises)
2. Read and write files using various methods
3. Work with directories (create, read, delete)
4. Handle file streams for large files
5. Use the path module effectively
6. Implement file watching for changes
7. Handle file permissions and metadata
8. Perform real-world file operations safely
9. Implement error handling for file operations
10. Choose the right approach for different scenarios

---

## Table of Contents

1. [Introduction](#introduction)
2. [The fs Module](#the-fs-module)
3. [Reading Files](#reading-files)
4. [Writing Files](#writing-files)
5. [Working with Directories](#working-with-directories)
6. [File Streams](#file-streams)
7. [Path Module](#path-module)
8. [File Watching](#file-watching)
9. [File Metadata and Permissions](#file-metadata-and-permissions)
10. [Worked Examples](#worked-examples)
11. [Exercises](#exercises)
12. [Testing & Verification](#testing--verification)
13. [Best Practices](#best-practices)
14. [Common Pitfalls](#common-pitfalls)
15. [Performance Considerations](#performance-considerations)
16. [Summary & Next Steps](#summary--next-steps)
17. [References](#references)

---

## Introduction

The **File System (fs)** module is one of Node.js's most powerful built-in modules, enabling you to interact with the file system. It provides three APIs for file operations: **callback-based**, **synchronous**, and **promise-based**.

**Why File Operations Matter:**

- **Configuration Management:** Read config files, .env files
- **Data Processing:** Process CSV, JSON, log files
- **File Uploads:** Handle user-uploaded files
- **Static File Serving:** Serve images, CSS, JavaScript
- **Logging:** Write application logs
- **Build Tools:** Read source files, write compiled output

**Real-World Applications:**

- **Content Management Systems:** File uploads and storage
- **Data Analysis Tools:** Processing large datasets
- **Build Tools:** Webpack, Babel, Rollup
- **Log Aggregators:** Processing application logs
- **Backup Systems:** File synchronization and backup

---

## The fs Module

### Three APIs: Callback, Sync, Promises

```javascript
/**
 * Three ways to use fs module
 */

// 1. CALLBACK-BASED (Original, Node.js style)
const fs = require('fs');

fs.readFile('file.txt', 'utf8', (err, data) => {
  if (err) {
    console.error('Error:', err);
    return;
  }
  console.log('Data:', data);
});

// 2. SYNCHRONOUS (Blocking)
const fs = require('fs');

try {
  const data = fs.readFileSync('file.txt', 'utf8');
  console.log('Data:', data);
} catch (err) {
  console.error('Error:', err);
}

// 3. PROMISE-BASED (Modern, recommended)
const fs = require('fs').promises;
// or: const fs = require('fs/promises');

async function readFileAsync() {
  try {
    const data = await fs.readFile('file.txt', 'utf8');
    console.log('Data:', data);
  } catch (err) {
    console.error('Error:', err);
  }
}

readFileAsync();
```

### Choosing the Right API

```javascript
/**
 * When to use each API
 */

const comparisonGuide = {
  callbacks: {
    when: 'Legacy code, Node.js < 10',
    pros: ['Most compatible', 'Well documented'],
    cons: ['Callback hell', 'Error handling complex'],
    example: 'fs.readFile(path, callback)'
  },

  synchronous: {
    when: 'Startup scripts, CLI tools, small files',
    pros: ['Simple code', 'Easy to understand'],
    cons: ['Blocks event loop', 'No concurrency'],
    example: 'fs.readFileSync(path)',
    warning: '⚠️  Never use in server request handlers!'
  },

  promises: {
    when: 'Modern applications, async operations',
    pros: ['Clean async/await', 'Easy error handling', 'Best practice'],
    cons: ['Requires Node 10+'],
    example: 'await fs.promises.readFile(path)',
    recommended: '✅ Use this for new code'
  }
};

// ============================================
// EXAMPLE: When to use sync vs async
// ============================================

// ✅ SYNC: OK for startup configuration
const config = JSON.parse(fs.readFileSync('./config.json', 'utf8'));
startServer(config);

// ❌ SYNC: NEVER in request handlers
app.get('/file', (req, res) => {
  const data = fs.readFileSync('large-file.txt'); // BLOCKS all other requests!
  res.send(data);
});

// ✅ ASYNC: Always in request handlers
app.get('/file', async (req, res) => {
  try {
    const data = await fs.promises.readFile('large-file.txt', 'utf8');
    res.send(data);
  } catch (error) {
    res.status(500).send('Error reading file');
  }
});
```

---

## Reading Files

### Basic File Reading

```javascript
/**
 * Reading files with fs.promises
 */

const fs = require('fs').promises;

// Read entire file as string
async function readTextFile() {
  try {
    const data = await fs.readFile('example.txt', 'utf8');
    console.log('File contents:', data);
    return data;
  } catch (error) {
    if (error.code === 'ENOENT') {
      console.error('File not found');
    } else if (error.code === 'EACCES') {
      console.error('Permission denied');
    } else {
      console.error('Error reading file:', error);
    }
    throw error;
  }
}

// Read file as Buffer (binary data)
async function readBinaryFile() {
  try {
    const buffer = await fs.readFile('image.png');
    console.log('File size:', buffer.length, 'bytes');
    return buffer;
  } catch (error) {
    console.error('Error:', error);
    throw error;
  }
}

// Read JSON file
async function readJSON(filePath) {
  try {
    const data = await fs.readFile(filePath, 'utf8');
    return JSON.parse(data);
  } catch (error) {
    if (error instanceof SyntaxError) {
      throw new Error(`Invalid JSON in ${filePath}`);
    }
    throw error;
  }
}

// Usage
(async () => {
  const config = await readJSON('./config.json');
  console.log('Config:', config);
})();
```

### Reading Files Line by Line

```javascript
/**
 * Reading large files line by line
 */

const fs = require('fs');
const readline = require('readline');

async function processFileLineByLine(filePath) {
  const fileStream = fs.createReadStream(filePath);

  const rl = readline.createInterface({
    input: fileStream,
    crlfDelay: Infinity // Handle both \n and \r\n
  });

  let lineNumber = 0;

  for await (const line of rl) {
    lineNumber++;
    console.log(`Line ${lineNumber}: ${line}`);
    // Process each line here
  }

  console.log(`Processed ${lineNumber} lines`);
}

// Example: Count occurrences in large file
async function countOccurrences(filePath, searchTerm) {
  const fileStream = fs.createReadStream(filePath);
  const rl = readline.createInterface({
    input: fileStream,
    crlfDelay: Infinity
  });

  let count = 0;

  for await (const line of rl) {
    if (line.includes(searchTerm)) {
      count++;
    }
  }

  return count;
}

// Usage
(async () => {
  const count = await countOccurrences('./logs.txt', 'ERROR');
  console.log(`Found ${count} errors`);
})();
```

### Reading Directories

```javascript
/**
 * Reading directory contents
 */

const fs = require('fs').promises;
const path = require('path');

// Read directory (simple)
async function listFiles(dirPath) {
  try {
    const files = await fs.readdir(dirPath);
    console.log('Files:', files);
    return files;
  } catch (error) {
    console.error('Error reading directory:', error);
    throw error;
  }
}

// Read directory with file info
async function listFilesWithInfo(dirPath) {
  try {
    const files = await fs.readdir(dirPath, { withFileTypes: true });

    for (const file of files) {
      const type = file.isDirectory() ? 'DIR ' : 'FILE';
      console.log(`${type}: ${file.name}`);
    }

    return files;
  } catch (error) {
    console.error('Error:', error);
    throw error;
  }
}

// Recursive directory reading
async function readDirRecursive(dirPath, result = []) {
  const files = await fs.readdir(dirPath, { withFileTypes: true });

  for (const file of files) {
    const fullPath = path.join(dirPath, file.name);

    if (file.isDirectory()) {
      await readDirRecursive(fullPath, result);
    } else {
      result.push(fullPath);
    }
  }

  return result;
}

// Usage
(async () => {
  const allFiles = await readDirRecursive('./src');
  console.log('All files:', allFiles);
})();
```

---

## Writing Files

### Basic File Writing

```javascript
/**
 * Writing files with fs.promises
 */

const fs = require('fs').promises;

// Write string to file (overwrites existing)
async function writeTextFile(filePath, content) {
  try {
    await fs.writeFile(filePath, content, 'utf8');
    console.log('File written successfully');
  } catch (error) {
    console.error('Error writing file:', error);
    throw error;
  }
}

// Write JSON to file
async function writeJSON(filePath, data) {
  try {
    const jsonString = JSON.stringify(data, null, 2);
    await fs.writeFile(filePath, jsonString, 'utf8');
    console.log('JSON written successfully');
  } catch (error) {
    console.error('Error writing JSON:', error);
    throw error;
  }
}

// Append to file
async function appendToFile(filePath, content) {
  try {
    await fs.appendFile(filePath, content + '\n', 'utf8');
    console.log('Content appended');
  } catch (error) {
    console.error('Error appending:', error);
    throw error;
  }
}

// Write with options
async function writeWithOptions(filePath, content) {
  try {
    await fs.writeFile(filePath, content, {
      encoding: 'utf8',
      mode: 0o644,      // File permissions
      flag: 'w'         // Write flag (w = overwrite, a = append)
    });
    console.log('File written with options');
  } catch (error) {
    console.error('Error:', error);
    throw error;
  }
}

// Usage
(async () => {
  await writeTextFile('./output.txt', 'Hello, World!');

  const data = { name: 'John', age: 30 };
  await writeJSON('./data.json', data);

  await appendToFile('./log.txt', `[${new Date().toISOString()}] Log entry`);
})();
```

### Safe File Writing

```javascript
/**
 * Safe file writing with atomic operations
 */

const fs = require('fs').promises;
const path = require('path');

// Atomic write (write to temp, then rename)
async function writeFileAtomic(filePath, content) {
  const tempPath = `${filePath}.tmp`;

  try {
    // Write to temporary file
    await fs.writeFile(tempPath, content, 'utf8');

    // Atomic rename (replaces original)
    await fs.rename(tempPath, filePath);

    console.log('File written atomically');
  } catch (error) {
    // Cleanup temp file on error
    try {
      await fs.unlink(tempPath);
    } catch {}
    throw error;
  }
}

// Write with backup
async function writeWithBackup(filePath, content) {
  const backupPath = `${filePath}.backup`;

  try {
    // Create backup of existing file
    try {
      await fs.copyFile(filePath, backupPath);
    } catch (error) {
      if (error.code !== 'ENOENT') throw error;
      // File doesn't exist, no backup needed
    }

    // Write new content
    await fs.writeFile(filePath, content, 'utf8');

    console.log('File written with backup');
  } catch (error) {
    // Restore from backup on error
    try {
      await fs.copyFile(backupPath, filePath);
      console.log('Restored from backup');
    } catch {}
    throw error;
  }
}

// Create file only if it doesn't exist
async function createFileIfNotExists(filePath, content) {
  try {
    await fs.writeFile(filePath, content, { flag: 'wx' });
    console.log('File created');
    return true;
  } catch (error) {
    if (error.code === 'EEXIST') {
      console.log('File already exists');
      return false;
    }
    throw error;
  }
}
```

---

## Working with Directories

### Directory Operations

```javascript
/**
 * Directory operations with fs.promises
 */

const fs = require('fs').promises;
const path = require('path');

// Create directory
async function createDirectory(dirPath) {
  try {
    await fs.mkdir(dirPath);
    console.log('Directory created');
  } catch (error) {
    if (error.code === 'EEXIST') {
      console.log('Directory already exists');
    } else {
      throw error;
    }
  }
}

// Create nested directories
async function createNestedDirectories(dirPath) {
  try {
    await fs.mkdir(dirPath, { recursive: true });
    console.log('Directories created');
  } catch (error) {
    console.error('Error creating directories:', error);
    throw error;
  }
}

// Remove directory
async function removeDirectory(dirPath) {
  try {
    await fs.rmdir(dirPath);
    console.log('Directory removed');
  } catch (error) {
    if (error.code === 'ENOTEMPTY') {
      console.error('Directory not empty');
    }
    throw error;
  }
}

// Remove directory recursively
async function removeDirectoryRecursive(dirPath) {
  try {
    await fs.rm(dirPath, { recursive: true, force: true });
    console.log('Directory removed recursively');
  } catch (error) {
    console.error('Error removing directory:', error);
    throw error;
  }
}

// Check if directory exists
async function directoryExists(dirPath) {
  try {
    const stats = await fs.stat(dirPath);
    return stats.isDirectory();
  } catch (error) {
    if (error.code === 'ENOENT') {
      return false;
    }
    throw error;
  }
}

// Ensure directory exists
async function ensureDirectory(dirPath) {
  const exists = await directoryExists(dirPath);
  if (!exists) {
    await fs.mkdir(dirPath, { recursive: true });
  }
}

// Usage
(async () => {
  await createNestedDirectories('./data/uploads/images');
  await ensureDirectory('./logs');
})();
```

### File Operations

```javascript
/**
 * Common file operations
 */

const fs = require('fs').promises;
const path = require('path');

// Copy file
async function copyFile(source, destination) {
  try {
    await fs.copyFile(source, destination);
    console.log('File copied');
  } catch (error) {
    console.error('Error copying file:', error);
    throw error;
  }
}

// Move/rename file
async function moveFile(oldPath, newPath) {
  try {
    await fs.rename(oldPath, newPath);
    console.log('File moved');
  } catch (error) {
    console.error('Error moving file:', error);
    throw error;
  }
}

// Delete file
async function deleteFile(filePath) {
  try {
    await fs.unlink(filePath);
    console.log('File deleted');
  } catch (error) {
    if (error.code === 'ENOENT') {
      console.log('File does not exist');
    } else {
      throw error;
    }
  }
}

// Check if file exists
async function fileExists(filePath) {
  try {
    await fs.access(filePath);
    return true;
  } catch {
    return false;
  }
}

// Get file size
async function getFileSize(filePath) {
  try {
    const stats = await fs.stat(filePath);
    return stats.size;
  } catch (error) {
    console.error('Error getting file size:', error);
    throw error;
  }
}

// Copy directory recursively
async function copyDirectory(source, destination) {
  await fs.mkdir(destination, { recursive: true });

  const entries = await fs.readdir(source, { withFileTypes: true });

  for (const entry of entries) {
    const srcPath = path.join(source, entry.name);
    const destPath = path.join(destination, entry.name);

    if (entry.isDirectory()) {
      await copyDirectory(srcPath, destPath);
    } else {
      await fs.copyFile(srcPath, destPath);
    }
  }

  console.log('Directory copied');
}
```

---

## File Streams

### Reading Streams

```javascript
/**
 * Reading files with streams (memory efficient)
 */

const fs = require('fs');

// Create readable stream
function readLargeFile(filePath) {
  const readStream = fs.createReadStream(filePath, {
    encoding: 'utf8',
    highWaterMark: 64 * 1024 // 64KB chunks (default: 64KB)
  });

  readStream.on('data', (chunk) => {
    console.log(`Received ${chunk.length} bytes`);
    // Process chunk
  });

  readStream.on('end', () => {
    console.log('File reading complete');
  });

  readStream.on('error', (error) => {
    console.error('Error reading file:', error);
  });
}

// Process large file in chunks
async function processLargeFileInChunks(filePath, processChunk) {
  return new Promise((resolve, reject) => {
    const readStream = fs.createReadStream(filePath, { encoding: 'utf8' });

    readStream.on('data', (chunk) => {
      processChunk(chunk);
    });

    readStream.on('end', resolve);
    readStream.on('error', reject);
  });
}

// Usage
processLargeFileInChunks('./large-log.txt', (chunk) => {
  // Count errors in each chunk
  const errorCount = (chunk.match(/ERROR/g) || []).length;
  if (errorCount > 0) {
    console.log(`Found ${errorCount} errors in chunk`);
  }
});
```

### Writing Streams

```javascript
/**
 * Writing files with streams
 */

const fs = require('fs');

// Create writable stream
function writeWithStream(filePath, data) {
  const writeStream = fs.createWriteStream(filePath, { encoding: 'utf8' });

  writeStream.write(data);
  writeStream.end(); // Important: close stream

  writeStream.on('finish', () => {
    console.log('Writing complete');
  });

  writeStream.on('error', (error) => {
    console.error('Error writing file:', error);
  });
}

// Generate large file with streams
async function generateLargeFile(filePath, lines) {
  return new Promise((resolve, reject) => {
    const writeStream = fs.createWriteStream(filePath);

    writeStream.on('error', reject);
    writeStream.on('finish', resolve);

    for (let i = 0; i < lines; i++) {
      const line = `Line ${i}: ${Math.random()}\n`;

      // Check if buffer is full
      const canContinue = writeStream.write(line);

      if (!canContinue) {
        // Wait for drain event before continuing
        await new Promise(resolve => writeStream.once('drain', resolve));
      }
    }

    writeStream.end();
  });
}

// Copy file using streams (memory efficient)
function copyFileWithStreams(source, destination) {
  return new Promise((resolve, reject) => {
    const readStream = fs.createReadStream(source);
    const writeStream = fs.createWriteStream(destination);

    readStream.on('error', reject);
    writeStream.on('error', reject);
    writeStream.on('finish', resolve);

    readStream.pipe(writeStream);
  });
}

// Usage
copyFileWithStreams('./large-file.txt', './large-file-copy.txt')
  .then(() => console.log('Copy complete'))
  .catch(error => console.error('Copy failed:', error));
```

### Transform Streams

```javascript
/**
 * Transform streams for processing data
 */

const fs = require('fs');
const { Transform } = require('stream');

// Create uppercase transform stream
class UpperCaseTransform extends Transform {
  _transform(chunk, encoding, callback) {
    const upperChunk = chunk.toString().toUpperCase();
    this.push(upperChunk);
    callback();
  }
}

// Transform file to uppercase
function transformFileToUpperCase(source, destination) {
  const readStream = fs.createReadStream(source);
  const writeStream = fs.createWriteStream(destination);
  const upperCaseTransform = new UpperCaseTransform();

  readStream
    .pipe(upperCaseTransform)
    .pipe(writeStream);

  writeStream.on('finish', () => {
    console.log('Transform complete');
  });
}

// CSV to JSON transform
class CSVToJSONTransform extends Transform {
  constructor() {
    super({ objectMode: true });
    this.headers = null;
    this.isFirstLine = true;
  }

  _transform(line, encoding, callback) {
    const lineStr = line.toString().trim();
    if (!lineStr) {
      callback();
      return;
    }

    const values = lineStr.split(',');

    if (this.isFirstLine) {
      this.headers = values;
      this.isFirstLine = false;
    } else {
      const obj = {};
      this.headers.forEach((header, index) => {
        obj[header] = values[index];
      });
      this.push(JSON.stringify(obj) + '\n');
    }

    callback();
  }
}

// Usage
const readline = require('readline');

function convertCSVToJSON(csvFile, jsonFile) {
  const readStream = fs.createReadStream(csvFile);
  const writeStream = fs.createWriteStream(jsonFile);
  const csvTransform = new CSVToJSONTransform();

  const rl = readline.createInterface({
    input: readStream,
    crlfDelay: Infinity
  });

  rl.on('line', (line) => {
    csvTransform.write(line);
  });

  rl.on('close', () => {
    csvTransform.end();
  });

  csvTransform.pipe(writeStream);
}
```

---

## Path Module

### Path Manipulation

```javascript
/**
 * Path module for cross-platform path handling
 */

const path = require('path');

// Join path segments
const fullPath = path.join('/users', 'john', 'documents', 'file.txt');
// Result: /users/john/documents/file.txt (Unix)
//         \users\john\documents\file.txt (Windows)

// Resolve absolute path
const absolutePath = path.resolve('documents', 'file.txt');
// Result: /current/working/directory/documents/file.txt

// Get directory name
const dir = path.dirname('/users/john/documents/file.txt');
// Result: /users/john/documents

// Get file name
const filename = path.basename('/users/john/documents/file.txt');
// Result: file.txt

const filenameNoExt = path.basename('/users/john/documents/file.txt', '.txt');
// Result: file

// Get extension
const ext = path.extname('/users/john/documents/file.txt');
// Result: .txt

// Parse path
const parsed = path.parse('/users/john/documents/file.txt');
console.log(parsed);
/**
 * {
 *   root: '/',
 *   dir: '/users/john/documents',
 *   base: 'file.txt',
 *   ext: '.txt',
 *   name: 'file'
 * }
 */

// Format path
const formatted = path.format({
  root: '/',
  dir: '/users/john/documents',
  base: 'file.txt'
});
// Result: /users/john/documents/file.txt

// Normalize path
const normalized = path.normalize('/users/john/../jane/./documents/file.txt');
// Result: /users/jane/documents/file.txt

// Get relative path
const relative = path.relative('/users/john/documents', '/users/john/photos/pic.jpg');
// Result: ../../photos/pic.jpg

// Check if path is absolute
const isAbs = path.isAbsolute('/users/john/file.txt'); // true
const isAbs2 = path.isAbsolute('documents/file.txt');  // false

// Path separator
console.log(path.sep);      // / on Unix, \ on Windows
console.log(path.delimiter); // : on Unix, ; on Windows
```

### Common Path Patterns

```javascript
/**
 * Common path patterns and utilities
 */

const path = require('path');
const fs = require('fs').promises;

// Get all files with specific extension
async function getFilesByExtension(dirPath, extension) {
  const files = await fs.readdir(dirPath);
  return files.filter(file => path.extname(file) === extension);
}

// Change file extension
function changeExtension(filePath, newExt) {
  const parsed = path.parse(filePath);
  return path.join(parsed.dir, parsed.name + newExt);
}

// Get unique filename
async function getUniqueFilename(dirPath, filename) {
  let counter = 0;
  let uniqueName = filename;
  const ext = path.extname(filename);
  const name = path.basename(filename, ext);

  while (await fileExists(path.join(dirPath, uniqueName))) {
    counter++;
    uniqueName = `${name}-${counter}${ext}`;
  }

  return uniqueName;
}

async function fileExists(filePath) {
  try {
    await fs.access(filePath);
    return true;
  } catch {
    return false;
  }
}

// Build safe file path (prevent directory traversal)
function buildSafePath(baseDir, userPath) {
  const safePath = path.normalize(userPath).replace(/^(\.\.(\/|\\|$))+/, '');
  const fullPath = path.join(baseDir, safePath);

  // Ensure path is still within baseDir
  if (!fullPath.startsWith(baseDir)) {
    throw new Error('Invalid path');
  }

  return fullPath;
}

// Usage
try {
  const safePath = buildSafePath('/uploads', '../../etc/passwd');
} catch (error) {
  console.error('Security violation:', error.message);
}
```

---

## File Watching

### Watching Files and Directories

```javascript
/**
 * File watching with fs.watch
 */

const fs = require('fs');
const path = require('path');

// Watch single file
function watchFile(filePath) {
  const watcher = fs.watch(filePath, (eventType, filename) => {
    console.log(`Event: ${eventType}`);
    if (filename) {
      console.log(`File: ${filename}`);
    }

    if (eventType === 'change') {
      console.log(`${filePath} was modified`);
    } else if (eventType === 'rename') {
      console.log(`${filePath} was renamed or deleted`);
    }
  });

  // Stop watching after 30 seconds
  setTimeout(() => {
    watcher.close();
    console.log('Stopped watching');
  }, 30000);

  return watcher;
}

// Watch directory
function watchDirectory(dirPath) {
  const watcher = fs.watch(dirPath, { recursive: false }, (eventType, filename) => {
    if (filename) {
      const fullPath = path.join(dirPath, filename);
      console.log(`${eventType}: ${fullPath}`);
    }
  });

  return watcher;
}

// Watch directory recursively (manual implementation)
async function watchDirectoryRecursive(dirPath, callback) {
  const watchers = [];

  async function watchDir(dir) {
    // Watch current directory
    const watcher = fs.watch(dir, async (eventType, filename) => {
      if (filename) {
        const fullPath = path.join(dir, filename);
        callback(eventType, fullPath);

        // If new directory created, watch it too
        if (eventType === 'rename') {
          try {
            const stats = await fs.promises.stat(fullPath);
            if (stats.isDirectory()) {
              watchDir(fullPath);
            }
          } catch {
            // File deleted or not accessible
          }
        }
      }
    });

    watchers.push(watcher);

    // Watch subdirectories
    const entries = await fs.promises.readdir(dir, { withFileTypes: true });
    for (const entry of entries) {
      if (entry.isDirectory()) {
        await watchDir(path.join(dir, entry.name));
      }
    }
  }

  await watchDir(dirPath);

  // Return cleanup function
  return () => {
    watchers.forEach(watcher => watcher.close());
  };
}

// Usage
(async () => {
  const cleanup = await watchDirectoryRecursive('./src', (eventType, filePath) => {
    console.log(`${eventType}: ${filePath}`);
    // Trigger rebuild, hot reload, etc.
  });

  // Stop watching after 5 minutes
  setTimeout(cleanup, 5 * 60 * 1000);
})();
```

### Advanced File Watching

```javascript
/**
 * Advanced file watching with debouncing
 */

const fs = require('fs');

class FileWatcher {
  constructor(filePath, options = {}) {
    this.filePath = filePath;
    this.debounceDelay = options.debounceDelay || 100;
    this.onChange = options.onChange || (() => {});
    this.watcher = null;
    this.debounceTimer = null;
  }

  start() {
    this.watcher = fs.watch(this.filePath, (eventType) => {
      if (eventType === 'change') {
        this.handleChange();
      }
    });
  }

  handleChange() {
    // Debounce: wait for changes to settle
    clearTimeout(this.debounceTimer);
    this.debounceTimer = setTimeout(() => {
      this.onChange(this.filePath);
    }, this.debounceDelay);
  }

  stop() {
    if (this.watcher) {
      this.watcher.close();
      this.watcher = null;
    }
    clearTimeout(this.debounceTimer);
  }
}

// Usage
const watcher = new FileWatcher('./config.json', {
  debounceDelay: 200,
  onChange: (filePath) => {
    console.log(`Config file changed: ${filePath}`);
    // Reload configuration
  }
});

watcher.start();

// Stop watching later
// watcher.stop();
```

---

## File Metadata and Permissions

### File Statistics

```javascript
/**
 * Getting file metadata
 */

const fs = require('fs').promises;

async function getFileInfo(filePath) {
  try {
    const stats = await fs.stat(filePath);

    const info = {
      size: stats.size,                    // Size in bytes
      sizeKB: (stats.size / 1024).toFixed(2) + ' KB',
      created: stats.birthtime,            // Creation time
      modified: stats.mtime,               // Last modified
      accessed: stats.atime,               // Last accessed
      isFile: stats.isFile(),
      isDirectory: stats.isDirectory(),
      isSymbolicLink: stats.isSymbolicLink(),
      permissions: stats.mode.toString(8), // Octal permissions
      uid: stats.uid,                      // User ID
      gid: stats.gid                       // Group ID
    };

    return info;
  } catch (error) {
    console.error('Error getting file info:', error);
    throw error;
  }
}

// Usage
(async () => {
  const info = await getFileInfo('./example.txt');
  console.log(info);
})();

// Check file type
async function getFileType(filePath) {
  const stats = await fs.stat(filePath);

  if (stats.isFile()) return 'file';
  if (stats.isDirectory()) return 'directory';
  if (stats.isSymbolicLink()) return 'symlink';
  if (stats.isBlockDevice()) return 'block-device';
  if (stats.isCharacterDevice()) return 'character-device';
  if (stats.isFIFO()) return 'fifo';
  if (stats.isSocket()) return 'socket';

  return 'unknown';
}
```

### File Permissions

```javascript
/**
 * Working with file permissions
 */

const fs = require('fs').promises;

// Change file permissions
async function changePermissions(filePath, mode) {
  try {
    await fs.chmod(filePath, mode);
    console.log('Permissions changed');
  } catch (error) {
    console.error('Error changing permissions:', error);
    throw error;
  }
}

// Common permission modes
const PERMISSIONS = {
  OWNER_READ_WRITE:       0o600, // Owner: rw-
  OWNER_READ_WRITE_EXEC:  0o700, // Owner: rwx
  ALL_READ_WRITE:         0o666, // Everyone: rw-
  ALL_READ_EXEC:          0o555, // Everyone: r-x
  TYPICAL_FILE:           0o644, // Owner: rw-, Others: r--
  TYPICAL_DIR:            0o755, // Owner: rwx, Others: r-x
  PRIVATE:                0o600  // Owner only: rw-
};

// Usage
await changePermissions('./script.sh', PERMISSIONS.OWNER_READ_WRITE_EXEC);

// Check if file is readable/writable
async function checkAccess(filePath) {
  try {
    // Check if file exists and is readable
    await fs.access(filePath, fs.constants.R_OK);
    console.log('File is readable');

    // Check if writable
    await fs.access(filePath, fs.constants.W_OK);
    console.log('File is writable');

    // Check if executable
    await fs.access(filePath, fs.constants.X_OK);
    console.log('File is executable');
  } catch (error) {
    console.error('Access denied:', error.message);
  }
}

// Change file ownership (requires permissions)
async function changeOwnership(filePath, uid, gid) {
  try {
    await fs.chown(filePath, uid, gid);
    console.log('Ownership changed');
  } catch (error) {
    console.error('Error changing ownership:', error);
    throw error;
  }
}
```

---

## Worked Examples

### Example 1: Log File Manager

```javascript
/**
 * log-manager.js - Rotating log file manager
 */

const fs = require('fs').promises;
const fsSync = require('fs');
const path = require('path');

class LogManager {
  constructor(logDir, options = {}) {
    this.logDir = logDir;
    this.maxSize = options.maxSize || 10 * 1024 * 1024; // 10MB
    this.maxFiles = options.maxFiles || 5;
    this.currentLogPath = path.join(logDir, 'app.log');
  }

  async init() {
    await fs.mkdir(this.logDir, { recursive: true });
  }

  async log(level, message) {
    const timestamp = new Date().toISOString();
    const logEntry = `[${timestamp}] [${level}] ${message}\n`;

    try {
      // Check if rotation needed
      await this.rotateIfNeeded();

      // Append to current log
      await fs.appendFile(this.currentLogPath, logEntry, 'utf8');
    } catch (error) {
      console.error('Error writing log:', error);
    }
  }

  async rotateIfNeeded() {
    try {
      const stats = await fs.stat(this.currentLogPath);

      if (stats.size >= this.maxSize) {
        await this.rotate();
      }
    } catch (error) {
      if (error.code !== 'ENOENT') throw error;
      // File doesn't exist yet, no rotation needed
    }
  }

  async rotate() {
    // Shift existing log files
    for (let i = this.maxFiles - 1; i >= 1; i--) {
      const oldPath = path.join(this.logDir, `app.log.${i}`);
      const newPath = path.join(this.logDir, `app.log.${i + 1}`);

      try {
        await fs.rename(oldPath, newPath);
      } catch (error) {
        if (error.code !== 'ENOENT') throw error;
      }
    }

    // Rename current log to .1
    const firstRotated = path.join(this.logDir, 'app.log.1');
    await fs.rename(this.currentLogPath, firstRotated);

    // Delete oldest if exceeds max
    const oldestPath = path.join(this.logDir, `app.log.${this.maxFiles + 1}`);
    try {
      await fs.unlink(oldestPath);
    } catch {}
  }

  async getLogs(count = 100) {
    const logs = [];
    const stream = fsSync.createReadStream(this.currentLogPath, { encoding: 'utf8' });
    const readline = require('readline');

    const rl = readline.createInterface({
      input: stream,
      crlfDelay: Infinity
    });

    for await (const line of rl) {
      logs.push(line);
      if (logs.length >= count) break;
    }

    return logs;
  }

  async searchLogs(searchTerm) {
    const results = [];
    const files = await fs.readdir(this.logDir);

    for (const file of files.filter(f => f.startsWith('app.log'))) {
      const filePath = path.join(this.logDir, file);
      const stream = fsSync.createReadStream(filePath, { encoding: 'utf8' });
      const readline = require('readline');

      const rl = readline.createInterface({
        input: stream,
        crlfDelay: Infinity
      });

      for await (const line of rl) {
        if (line.includes(searchTerm)) {
          results.push({ file, line });
        }
      }
    }

    return results;
  }
}

// Usage
(async () => {
  const logger = new LogManager('./logs', {
    maxSize: 5 * 1024 * 1024, // 5MB
    maxFiles: 3
  });

  await logger.init();

  await logger.log('INFO', 'Application started');
  await logger.log('ERROR', 'Database connection failed');

  // Search logs
  const errors = await logger.searchLogs('ERROR');
  console.log('Found errors:', errors.length);
})();

module.exports = LogManager;
```

### Example 2: File Backup System

```javascript
/**
 * backup-system.js - Incremental file backup
 */

const fs = require('fs').promises;
const path = require('path');
const crypto = require('crypto');

class BackupSystem {
  constructor(sourceDir, backupDir) {
    this.sourceDir = sourceDir;
    this.backupDir = backupDir;
    this.manifestPath = path.join(backupDir, 'manifest.json');
    this.manifest = {};
  }

  async init() {
    await fs.mkdir(this.backupDir, { recursive: true });
    await this.loadManifest();
  }

  async loadManifest() {
    try {
      const data = await fs.readFile(this.manifestPath, 'utf8');
      this.manifest = JSON.parse(data);
    } catch (error) {
      if (error.code !== 'ENOENT') throw error;
      this.manifest = { files: {}, lastBackup: null };
    }
  }

  async saveManifest() {
    await fs.writeFile(
      this.manifestPath,
      JSON.stringify(this.manifest, null, 2),
      'utf8'
    );
  }

  async getFileHash(filePath) {
    const content = await fs.readFile(filePath);
    return crypto.createHash('md5').update(content).digest('hex');
  }

  async backup() {
    const startTime = Date.now();
    let backedUp = 0;
    let skipped = 0;

    const files = await this.getAllFiles(this.sourceDir);

    for (const file of files) {
      const relativePath = path.relative(this.sourceDir, file);
      const hash = await this.getFileHash(file);
      const previousHash = this.manifest.files[relativePath]?.hash;

      if (hash !== previousHash) {
        // File changed or new, back it up
        const backupPath = path.join(this.backupDir, relativePath);
        await fs.mkdir(path.dirname(backupPath), { recursive: true });
        await fs.copyFile(file, backupPath);

        this.manifest.files[relativePath] = {
          hash,
          size: (await fs.stat(file)).size,
          backedUpAt: new Date().toISOString()
        };

        backedUp++;
      } else {
        skipped++;
      }
    }

    this.manifest.lastBackup = new Date().toISOString();
    await this.saveManifest();

    const duration = Date.now() - startTime;

    return {
      backedUp,
      skipped,
      duration,
      total: files.length
    };
  }

  async getAllFiles(dir, files = []) {
    const entries = await fs.readdir(dir, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);

      if (entry.isDirectory()) {
        await this.getAllFiles(fullPath, files);
      } else {
        files.push(fullPath);
      }
    }

    return files;
  }

  async restore(relativePath) {
    const backupPath = path.join(this.backupDir, relativePath);
    const restorePath = path.join(this.sourceDir, relativePath);

    await fs.mkdir(path.dirname(restorePath), { recursive: true });
    await fs.copyFile(backupPath, restorePath);

    console.log(`Restored: ${relativePath}`);
  }

  async restoreAll() {
    for (const relativePath of Object.keys(this.manifest.files)) {
      await this.restore(relativePath);
    }
    console.log('All files restored');
  }

  async getStatus() {
    const files = Object.keys(this.manifest.files);
    const totalSize = Object.values(this.manifest.files)
      .reduce((sum, file) => sum + file.size, 0);

    return {
      fileCount: files.length,
      totalSize: (totalSize / 1024 / 1024).toFixed(2) + ' MB',
      lastBackup: this.manifest.lastBackup
    };
  }
}

// Usage
(async () => {
  const backup = new BackupSystem('./data', './backups');
  await backup.init();

  const result = await backup.backup();
  console.log('Backup complete:', result);

  const status = await backup.getStatus();
  console.log('Backup status:', status);
})();

module.exports = BackupSystem;
```

### Example 3: File Upload Handler

```javascript
/**
 * file-upload-handler.js - Secure file upload handler
 */

const fs = require('fs').promises;
const path = require('path');
const crypto = require('crypto');

class FileUploadHandler {
  constructor(uploadDir, options = {}) {
    this.uploadDir = uploadDir;
    this.maxSize = options.maxSize || 10 * 1024 * 1024; // 10MB
    this.allowedExtensions = options.allowedExtensions || ['.jpg', '.png', '.pdf'];
    this.allowedMimeTypes = options.allowedMimeTypes || [
      'image/jpeg',
      'image/png',
      'application/pdf'
    ];
  }

  async init() {
    await fs.mkdir(this.uploadDir, { recursive: true });
  }

  async handleUpload(file) {
    // Validate
    await this.validate(file);

    // Generate safe filename
    const safeFilename = await this.generateSafeFilename(file.originalName);
    const filePath = path.join(this.uploadDir, safeFilename);

    // Save file
    await fs.writeFile(filePath, file.buffer);

    // Get file info
    const stats = await fs.stat(filePath);

    return {
      filename: safeFilename,
      path: filePath,
      size: stats.size,
      uploadedAt: new Date().toISOString()
    };
  }

  async validate(file) {
    // Check size
    if (file.size > this.maxSize) {
      throw new Error(`File too large. Max size: ${this.maxSize} bytes`);
    }

    // Check extension
    const ext = path.extname(file.originalName).toLowerCase();
    if (!this.allowedExtensions.includes(ext)) {
      throw new Error(`File type not allowed. Allowed: ${this.allowedExtensions.join(', ')}`);
    }

    // Check MIME type
    if (!this.allowedMimeTypes.includes(file.mimeType)) {
      throw new Error(`MIME type not allowed. Allowed: ${this.allowedMimeTypes.join(', ')}`);
    }

    return true;
  }

  async generateSafeFilename(originalName) {
    const ext = path.extname(originalName);
    const nameWithoutExt = path.basename(originalName, ext);

    // Remove unsafe characters
    const safeName = nameWithoutExt
      .replace(/[^a-zA-Z0-9-_]/g, '_')
      .substring(0, 50);

    // Add timestamp and random string
    const timestamp = Date.now();
    const random = crypto.randomBytes(8).toString('hex');

    return `${safeName}_${timestamp}_${random}${ext}`;
  }

  async deleteFile(filename) {
    const filePath = this.buildSafePath(filename);
    await fs.unlink(filePath);
    console.log(`Deleted: ${filename}`);
  }

  async getFile(filename) {
    const filePath = this.buildSafePath(filename);
    return await fs.readFile(filePath);
  }

  buildSafePath(filename) {
    // Prevent directory traversal
    const safeName = path.basename(filename);
    const filePath = path.join(this.uploadDir, safeName);

    if (!filePath.startsWith(this.uploadDir)) {
      throw new Error('Invalid filename');
    }

    return filePath;
  }

  async listFiles() {
    const files = await fs.readdir(this.uploadDir);
    const fileInfos = [];

    for (const file of files) {
      const filePath = path.join(this.uploadDir, file);
      const stats = await fs.stat(filePath);

      fileInfos.push({
        filename: file,
        size: stats.size,
        created: stats.birthtime,
        modified: stats.mtime
      });
    }

    return fileInfos;
  }

  async cleanup(olderThanDays = 30) {
    const files = await fs.readdir(this.uploadDir);
    const cutoffDate = Date.now() - (olderThanDays * 24 * 60 * 60 * 1000);
    let deleted = 0;

    for (const file of files) {
      const filePath = path.join(this.uploadDir, file);
      const stats = await fs.stat(filePath);

      if (stats.mtime.getTime() < cutoffDate) {
        await fs.unlink(filePath);
        deleted++;
      }
    }

    return { deleted, cutoffDate: new Date(cutoffDate) };
  }
}

// Usage with Express
const express = require('express');
const multer = require('multer');
const app = express();

const upload = multer({ storage: multer.memoryStorage() });
const fileHandler = new FileUploadHandler('./uploads', {
  maxSize: 5 * 1024 * 1024,
  allowedExtensions: ['.jpg', '.png', '.pdf'],
  allowedMimeTypes: ['image/jpeg', 'image/png', 'application/pdf']
});

await fileHandler.init();

app.post('/upload', upload.single('file'), async (req, res) => {
  try {
    const result = await fileHandler.handleUpload({
      originalName: req.file.originalname,
      buffer: req.file.buffer,
      size: req.file.size,
      mimeType: req.file.mimetype
    });

    res.json({ success: true, file: result });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
});

module.exports = FileUploadHandler;
```

---

## Exercises

### Exercise 1: File Statistics Tool (Beginner)

**Task:** Create a command-line tool that analyzes files in a directory.

**Requirements:**
1. Count total files and directories
2. Calculate total size
3. Group files by extension
4. Find largest and smallest files
5. Show file type distribution (chart)
6. Handle errors gracefully
7. Support recursive scanning

**Solution:** See `solutions/exercise1-file-stats.js`

---

### Exercise 2: Text File Processor (Intermediate)

**Task:** Build a tool to process large text files.

**Requirements:**
1. Read file line by line (memory efficient)
2. Count words, lines, characters
3. Find most common words (exclude stop words)
4. Search for patterns (regex support)
5. Export results to JSON
6. Progress indicator for large files
7. Support for multiple encodings

**Solution:** See `solutions/exercise2-text-processor.js`

---

### Exercise 3: File Synchronization (Intermediate)

**Task:** Create a file synchronization utility.

**Requirements:**
1. Compare two directories
2. Detect new, modified, deleted files
3. Sync files based on timestamps or hashes
4. Support dry-run mode
5. Show sync summary
6. Handle errors and conflicts
7. Support bidirectional sync

**Solution:** See `solutions/exercise3-file-sync.js`

---

### Exercise 4: Log Analyzer (Advanced)

**Task:** Build a log file analyzer with streaming.

**Requirements:**
1. Parse various log formats (Apache, Nginx, custom)
2. Extract statistics (status codes, IPs, endpoints)
3. Detect patterns and anomalies
4. Generate HTML report
5. Handle compressed logs (.gz)
6. Real-time monitoring mode
7. Performance optimized for GB-sized files

**Solution:** See `solutions/exercise4-log-analyzer.js`

---

### Exercise 5: Version Control System (Advanced)

**Task:** Implement a simple version control system.

**Requirements:**
1. Initialize repository
2. Track file changes (add, commit)
3. View file history
4. Diff between versions
5. Restore previous versions
6. Branch support (basic)
7. Efficient storage (delta compression)
8. .gitignore style exclusions

**Solution:** See `solutions/exercise5-version-control/`

---

## Testing & Verification

### Test Suite: fs-operations.test.js

```javascript
/**
 * tests/fs-operations.test.js
 */

const fs = require('fs').promises;
const path = require('path');

const TEST_DIR = path.join(__dirname, 'test-files');

describe('File System Operations', () => {
  beforeAll(async () => {
    await fs.mkdir(TEST_DIR, { recursive: true });
  });

  afterAll(async () => {
    await fs.rm(TEST_DIR, { recursive: true, force: true });
  });

  describe('Reading Files', () => {
    test('reads text file', async () => {
      const filePath = path.join(TEST_DIR, 'test.txt');
      await fs.writeFile(filePath, 'Hello, World!', 'utf8');

      const content = await fs.readFile(filePath, 'utf8');
      expect(content).toBe('Hello, World!');
    });

    test('reads JSON file', async () => {
      const filePath = path.join(TEST_DIR, 'test.json');
      const data = { name: 'John', age: 30 };
      await fs.writeFile(filePath, JSON.stringify(data), 'utf8');

      const content = await fs.readFile(filePath, 'utf8');
      const parsed = JSON.parse(content);
      expect(parsed).toEqual(data);
    });

    test('handles missing file', async () => {
      await expect(
        fs.readFile(path.join(TEST_DIR, 'nonexistent.txt'), 'utf8')
      ).rejects.toThrow();
    });
  });

  describe('Writing Files', () => {
    test('writes text file', async () => {
      const filePath = path.join(TEST_DIR, 'output.txt');
      await fs.writeFile(filePath, 'Test content', 'utf8');

      const content = await fs.readFile(filePath, 'utf8');
      expect(content).toBe('Test content');
    });

    test('appends to file', async () => {
      const filePath = path.join(TEST_DIR, 'append.txt');
      await fs.writeFile(filePath, 'Line 1\n', 'utf8');
      await fs.appendFile(filePath, 'Line 2\n', 'utf8');

      const content = await fs.readFile(filePath, 'utf8');
      expect(content).toBe('Line 1\nLine 2\n');
    });
  });

  describe('Directory Operations', () => {
    test('creates directory', async () => {
      const dirPath = path.join(TEST_DIR, 'new-dir');
      await fs.mkdir(dirPath);

      const stats = await fs.stat(dirPath);
      expect(stats.isDirectory()).toBe(true);
    });

    test('creates nested directories', async () => {
      const dirPath = path.join(TEST_DIR, 'a', 'b', 'c');
      await fs.mkdir(dirPath, { recursive: true });

      const stats = await fs.stat(dirPath);
      expect(stats.isDirectory()).toBe(true);
    });

    test('reads directory', async () => {
      const dirPath = path.join(TEST_DIR, 'read-dir');
      await fs.mkdir(dirPath, { recursive: true });
      await fs.writeFile(path.join(dirPath, 'file1.txt'), '');
      await fs.writeFile(path.join(dirPath, 'file2.txt'), '');

      const files = await fs.readdir(dirPath);
      expect(files).toHaveLength(2);
      expect(files).toContain('file1.txt');
      expect(files).toContain('file2.txt');
    });
  });

  describe('File Operations', () => {
    test('copies file', async () => {
      const source = path.join(TEST_DIR, 'source.txt');
      const dest = path.join(TEST_DIR, 'dest.txt');

      await fs.writeFile(source, 'Copy me', 'utf8');
      await fs.copyFile(source, dest);

      const content = await fs.readFile(dest, 'utf8');
      expect(content).toBe('Copy me');
    });

    test('moves/renames file', async () => {
      const oldPath = path.join(TEST_DIR, 'old.txt');
      const newPath = path.join(TEST_DIR, 'new.txt');

      await fs.writeFile(oldPath, 'Move me', 'utf8');
      await fs.rename(oldPath, newPath);

      const content = await fs.readFile(newPath, 'utf8');
      expect(content).toBe('Move me');

      await expect(fs.access(oldPath)).rejects.toThrow();
    });

    test('deletes file', async () => {
      const filePath = path.join(TEST_DIR, 'delete-me.txt');
      await fs.writeFile(filePath, 'Delete me', 'utf8');
      await fs.unlink(filePath);

      await expect(fs.access(filePath)).rejects.toThrow();
    });
  });

  describe('File Stats', () => {
    test('gets file stats', async () => {
      const filePath = path.join(TEST_DIR, 'stats.txt');
      await fs.writeFile(filePath, 'Stats test', 'utf8');

      const stats = await fs.stat(filePath);
      expect(stats.isFile()).toBe(true);
      expect(stats.size).toBeGreaterThan(0);
      expect(stats.mtime).toBeInstanceOf(Date);
    });
  });
});
```

---

## Best Practices

### 1. Always Use Promises API

```javascript
// ✅ DO: Use promises/async-await
const fs = require('fs').promises;

async function readFile() {
  const data = await fs.readFile('file.txt', 'utf8');
  return data;
}

// ❌ DON'T: Use callbacks in new code
const fs = require('fs');

fs.readFile('file.txt', 'utf8', (err, data) => {
  // Callback hell risk
});
```

### 2. Handle Errors Properly

```javascript
// ✅ DO: Specific error handling
try {
  await fs.readFile('file.txt', 'utf8');
} catch (error) {
  if (error.code === 'ENOENT') {
    console.log('File not found');
  } else if (error.code === 'EACCES') {
    console.log('Permission denied');
  } else {
    throw error;
  }
}

// ❌ DON'T: Ignore errors
try {
  await fs.readFile('file.txt', 'utf8');
} catch {}  // Silent failure!
```

### 3. Use Path Module

```javascript
// ✅ DO: Use path.join for cross-platform
const fullPath = path.join(__dirname, 'data', 'file.txt');

// ❌ DON'T: Hard-code separators
const fullPath = __dirname + '/data/file.txt';  // Breaks on Windows
```

### 4. Clean Up Resources

```javascript
// ✅ DO: Close streams and watchers
const watcher = fs.watch('file.txt');
// ... use watcher ...
watcher.close();

// ✅ DO: Use try-finally for cleanup
const stream = fs.createReadStream('file.txt');
try {
  // Process stream
} finally {
  stream.destroy();
}
```

### 5. Use Streams for Large Files

```javascript
// ✅ DO: Stream large files
const stream = fs.createReadStream('large-file.txt');
stream.pipe(destinationStream);

// ❌ DON'T: Read entire file into memory
const data = await fs.readFile('large-file.txt');  // OOM risk!
```

---

## Common Pitfalls

### 1. Synchronous Operations in Async Code

```javascript
// ❌ PITFALL: Blocks event loop
app.get('/file', (req, res) => {
  const data = fs.readFileSync('file.txt');
  res.send(data);
});

// ✅ SOLUTION
app.get('/file', async (req, res) => {
  const data = await fs.promises.readFile('file.txt', 'utf8');
  res.send(data);
});
```

### 2. Not Handling ENOENT

```javascript
// ❌ PITFALL: Crashes on missing file
const data = await fs.readFile('maybe-exists.txt', 'utf8');

// ✅ SOLUTION
try {
  const data = await fs.readFile('maybe-exists.txt', 'utf8');
} catch (error) {
  if (error.code === 'ENOENT') {
    // Handle missing file
  }
}
```

### 3. Path Traversal Vulnerability

```javascript
// ❌ PITFALL: Security vulnerability
const userPath = req.query.file;  // '../../../etc/passwd'
const data = await fs.readFile(userPath);

// ✅ SOLUTION
const safePath = path.basename(userPath);
const fullPath = path.join(SAFE_DIR, safePath);
if (!fullPath.startsWith(SAFE_DIR)) {
  throw new Error('Invalid path');
}
```

### 4. Race Conditions

```javascript
// ❌ PITFALL: Race condition
if (await fileExists('file.txt')) {
  await fs.unlink('file.txt');  // Might fail if deleted between check and unlink
}

// ✅ SOLUTION: Just try and catch
try {
  await fs.unlink('file.txt');
} catch (error) {
  if (error.code !== 'ENOENT') throw error;
}
```

### 5. Not Using Recursive Option

```javascript
// ❌ PITFALL: Fails if parent doesn't exist
await fs.mkdir('/path/to/deep/dir');

// ✅ SOLUTION
await fs.mkdir('/path/to/deep/dir', { recursive: true });
```

---

## Performance Considerations

### 1. Use Streams for Large Files

```javascript
// ⚠️  SLOW: Reads entire file into memory
const data = await fs.readFile('1GB-file.txt', 'utf8');

// ✅ FAST: Streams data in chunks
const stream = fs.createReadStream('1GB-file.txt');
stream.on('data', chunk => processChunk(chunk));
```

### 2. Batch Operations

```javascript
// ⚠️  SLOW: Individual reads
for (const file of files) {
  await fs.readFile(file);
}

// ✅ FAST: Parallel reads
await Promise.all(files.map(file => fs.readFile(file)));
```

### 3. Cache File Stats

```javascript
// ⚠️  SLOW: Multiple stat calls
const size = (await fs.stat(file)).size;
const mtime = (await fs.stat(file)).mtime;

// ✅ FAST: Single stat call
const stats = await fs.stat(file);
const size = stats.size;
const mtime = stats.mtime;
```

---

## Summary & Next Steps

### Key Takeaways

1. **fs module** has three APIs: callbacks, sync, promises (use promises!)
2. **Always handle errors** with specific error codes
3. **Use streams** for large files
4. **path module** ensures cross-platform compatibility
5. **File watching** enables reactive file operations
6. **Security matters:** Validate paths, check permissions

### What's Next?

In the next lesson, we'll explore:
- **HTTP module**: Creating web servers
- **Request/Response handling**
- **Routing and static file serving**

### Further Practice

1. Build a file-based database
2. Create a markdown to HTML converter
3. Implement a file search engine
4. Build a photo gallery generator
5. Create a backup automation tool

---

## References

### Official Documentation
- [File System API](https://nodejs.org/api/fs.html)
- [Path Module](https://nodejs.org/api/path.html)
- [Streams](https://nodejs.org/api/stream.html)

### Tutorials
- [Working with Files](https://nodejs.dev/learn/working-with-folders-in-nodejs)
- [Stream Handbook](https://github.com/substack/stream-handbook)

### Tools
- [chokidar](https://github.com/paulmillr/chokidar) - Better file watching
- [fs-extra](https://github.com/jprichardson/node-fs-extra) - Enhanced fs

---

**Next Lesson:** [31. HTTP and Servers](./31.HTTP_And_Servers.md)

**Previous Lesson:** [29. Node.js Modules and CommonJS](./29.Node.js_Modules_And_CommonJS.md)
