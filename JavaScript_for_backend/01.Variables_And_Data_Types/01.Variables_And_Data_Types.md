# Variables and Data Types in JavaScript: From Fundamentals to Production

**Difficulty:** Introductory
**Estimated Time:** 40-60 minutes
**Prerequisites:** Basic JavaScript knowledge, Node.js 18+ installed, completed [Introduction to JavaScript](../00.Introduction_to_JavaScript/00.Introduction_to_JavaScript.md)
**Node.js Version:** 18.0.0+ LTS
**Browser Targets:** Chrome 90+, Firefox 88+, Safari 14+, Edge 90+

---

## Learning Objectives

By the end of this lesson, you will be able to:

1. **Differentiate** between `var`, `let`, and `const` keywords and apply the appropriate declaration method based on scope and mutability requirements
2. **Identify** and classify all JavaScript primitive types (number, string, boolean, null, undefined, symbol, bigint) and understand their memory characteristics
3. **Implement** type checking, conversion, and coercion techniques to handle dynamic typing safely in production code
4. **Distinguish** between primitive and reference types, understanding their implications for memory management and comparison operations
5. **Apply** variable naming conventions and best practices to write maintainable, professional JavaScript code
6. **Diagnose** and debug common type-related errors using typeof, strict equality, and modern JavaScript tooling

---

## Table of Contents

1. [Introduction](#introduction)
2. [Variable Declaration: var, let, and const](#variable-declaration-var-let-and-const)
3. [Primitive Data Types](#primitive-data-types)
4. [Reference Types vs Primitives](#reference-types-vs-primitives)
5. [Type Checking with typeof](#type-checking-with-typeof)
6. [Type Conversion and Coercion](#type-conversion-and-coercion)
7. [Truthy and Falsy Values](#truthy-and-falsy-values)
8. [Notation and Conventions](#notation-and-conventions)
9. [Worked Examples](#worked-examples)
10. [Exercises](#exercises)
11. [Practical Applications](#practical-applications)
12. [Testing and Verification](#testing-and-verification)
13. [Common Pitfalls and Debugging](#common-pitfalls-and-debugging)
14. [Security Considerations](#security-considerations)
15. [Performance Notes](#performance-notes)
16. [Summary and Next Steps](#summary-and-next-steps)
17. [References](#references)

---

## Introduction

Variables are the foundation of programming—they store data that your program needs to remember and manipulate. In JavaScript, understanding variables and data types is critical because JavaScript is **dynamically typed**, meaning variables can hold different types of values during program execution.

### Why This Matters

In production applications, improper variable handling leads to:
- **Type errors** that crash applications
- **Memory leaks** from incorrect scope management
- **Security vulnerabilities** from type coercion exploits
- **Performance issues** from inefficient type conversions

This lesson teaches you to work with JavaScript's type system safely and efficiently.

### What You'll Build

By the end of this lesson, you'll create:
1. A type-safe data validator with comprehensive type checking
2. A variable scope demonstrator showing `var`, `let`, and `const` behaviors
3. A type conversion utility with error handling

---

## Variable Declaration: var, let, and const

JavaScript provides three keywords for declaring variables: `var` (legacy), `let` (modern, mutable), and `const` (modern, immutable reference).

### The `var` Keyword (Legacy - Avoid)

**Characteristics:**
- **Function-scoped** (not block-scoped)
- **Hoisted** to the top of the function
- **Can be redeclared** in the same scope
- **Not recommended** in modern JavaScript

```javascript
// ❌ AVOID: var has problematic scoping
function demonstrateVar() {
  console.log(x); // undefined (hoisted, not ReferenceError)
  var x = 10;

  if (true) {
    var x = 20; // Same variable! (function-scoped)
    console.log(x); // 20
  }

  console.log(x); // 20 (unexpected!)
}

// var is hoisted to function scope
function hoistingExample() {
  var x; // Hoisted declaration
  console.log(x); // undefined
  x = 5; // Assignment remains in place
}
```

### The `let` Keyword (Modern - Mutable)

**Characteristics:**
- **Block-scoped** (scoped to `{}`)
- **Temporal Dead Zone** (TDZ): cannot access before declaration
- **Cannot be redeclared** in the same scope
- **Can be reassigned**

```javascript
// ✅ CORRECT: let is block-scoped and safe
function demonstrateLet() {
  // console.log(x); // ReferenceError: Cannot access 'x' before initialization
  let x = 10;

  if (true) {
    let x = 20; // Different variable (block-scoped)
    console.log(x); // 20
  }

  console.log(x); // 10 (preserved)

  x = 30; // Reassignment allowed
  console.log(x); // 30
}

// Block scope example
{
  let blockScoped = 'I exist only in this block';
  console.log(blockScoped); // Works
}
// console.log(blockScoped); // ReferenceError: blockScoped is not defined
```

### The `const` Keyword (Modern - Immutable Reference)

**Characteristics:**
- **Block-scoped** (scoped to `{}`)
- **Temporal Dead Zone** (TDZ): cannot access before declaration
- **Must be initialized** at declaration
- **Cannot be reassigned**
- **Object properties can still be mutated**

```javascript
// ✅ CORRECT: const prevents reassignment
const MAX_USERS = 100;
// MAX_USERS = 200; // TypeError: Assignment to constant variable

const user = {
  name: 'Alice',
  age: 30,
};

// ✅ Mutation of object properties is allowed
user.age = 31; // Works!
console.log(user.age); // 31

// ❌ Reassignment of the reference is not allowed
// user = { name: 'Bob' }; // TypeError: Assignment to constant variable

// Freezing objects to prevent mutation
const frozenUser = Object.freeze({
  name: 'Charlie',
  age: 25,
});

frozenUser.age = 26; // Silently fails in non-strict mode
console.log(frozenUser.age); // 25 (unchanged)
```

### Decision Matrix: When to Use Each

| Keyword | Use Case | Example |
|---------|----------|---------|
| `const` | **Default choice** - values that won't be reassigned | `const API_URL = 'https://api.example.com'` |
| `let` | Loop counters, values that change | `let count = 0; count++` |
| `var` | **Never** (legacy code only) | ❌ Avoid |

**Best Practice:** Always use `const` by default. Only use `let` when you need to reassign. Never use `var`.

---

## Primitive Data Types

JavaScript has **7 primitive data types**. Primitives are **immutable** and stored **by value**.

### 1. Number

Represents both integers and floating-point numbers (IEEE 754 double-precision 64-bit).

```javascript
// Integer
const integer = 42;

// Floating-point
const float = 3.14159;

// Scientific notation
const scientific = 2.5e6; // 2,500,000

// Special numeric values
const infinity = Infinity;
const negInfinity = -Infinity;
const notANumber = NaN; // Result of invalid operations

// Number range
const maxSafeInteger = Number.MAX_SAFE_INTEGER; // 2^53 - 1 = 9007199254740991
const minSafeInteger = Number.MIN_SAFE_INTEGER; // -(2^53 - 1)

// Checking for special values
console.log(Number.isNaN(NaN)); // true
console.log(Number.isFinite(42)); // true
console.log(Number.isFinite(Infinity)); // false
console.log(Number.isInteger(42)); // true
console.log(Number.isInteger(3.14)); // false
```

**Precision Caveat:**
```javascript
// Floating-point arithmetic can be imprecise
console.log(0.1 + 0.2); // 0.30000000000000004 (not exactly 0.3!)

// Solution: Use rounding or libraries like decimal.js
const sum = Math.round((0.1 + 0.2) * 100) / 100; // 0.3
```

### 2. String

Represents textual data (sequences of UTF-16 code units).

```javascript
// Three ways to create strings
const singleQuotes = 'Hello';
const doubleQuotes = "World";
const templateLiteral = `Hello, ${singleQuotes}!`; // String interpolation

// Escape sequences
const escaped = 'It\'s a nice day\nSecond line\tTabbed';

// String properties and methods
const text = 'JavaScript';
console.log(text.length); // 10
console.log(text.toUpperCase()); // "JAVASCRIPT"
console.log(text.slice(0, 4)); // "Java"
console.log(text.includes('Script')); // true

// Strings are immutable
const original = 'Hello';
const modified = original.toUpperCase();
console.log(original); // "Hello" (unchanged)
console.log(modified); // "HELLO"

// Template literals (multi-line and expressions)
const name = 'Alice';
const age = 30;
const message = `
  Name: ${name}
  Age: ${age}
  Year of Birth: ${new Date().getFullYear() - age}
`;
```

### 3. Boolean

Represents logical values: `true` or `false`.

```javascript
const isActive = true;
const isLoggedIn = false;

// Comparison operators return booleans
console.log(5 > 3); // true
console.log(10 === '10'); // false (strict equality)

// Logical operators
console.log(true && false); // false (AND)
console.log(true || false); // true (OR)
console.log(!true); // false (NOT)

// Boolean conversion
console.log(Boolean(1)); // true
console.log(Boolean(0)); // false
console.log(Boolean('')); // false
console.log(Boolean('text')); // true
```

### 4. Undefined

Represents a variable that has been declared but not assigned a value.

```javascript
let uninitialized;
console.log(uninitialized); // undefined
console.log(typeof uninitialized); // "undefined"

// Accessing non-existent object properties
const obj = { name: 'Alice' };
console.log(obj.age); // undefined (property doesn't exist)

// Function with no return statement
function noReturn() {
  // No return statement
}
console.log(noReturn()); // undefined

// Explicit undefined assignment
let explicitUndefined = undefined; // Generally avoid this
```

### 5. Null

Represents the **intentional absence** of any object value.

```javascript
let user = null; // Explicitly set to "no value"
console.log(user); // null
console.log(typeof null); // "object" (historical JavaScript bug!)

// Common use: Resetting a value
let data = { name: 'Alice' };
data = null; // Clear the data

// null vs undefined
console.log(null == undefined); // true (loose equality)
console.log(null === undefined); // false (strict equality)
```

### 6. Symbol (ES6+)

Represents a **unique, immutable** primitive value, often used as object property keys.

```javascript
// Creating symbols
const sym1 = Symbol('description');
const sym2 = Symbol('description');

console.log(sym1 === sym2); // false (each Symbol is unique!)

// Use case: Unique object keys
const id = Symbol('id');
const user = {
  name: 'Alice',
  [id]: 12345, // Symbol as property key
};

console.log(user[id]); // 12345
console.log(user.id); // undefined (different from Symbol)

// Symbols are not enumerable
console.log(Object.keys(user)); // ["name"] (Symbol key excluded)

// Well-known symbols
const arr = [1, 2, 3];
console.log(arr[Symbol.iterator]); // Built-in iterator function
```

### 7. BigInt (ES2020)

Represents integers larger than `Number.MAX_SAFE_INTEGER` (2^53 - 1).

```javascript
// Creating BigInts (note the 'n' suffix)
const bigInt1 = 1234567890123456789012345678901234567890n;
const bigInt2 = BigInt('9007199254740992'); // From string

// Arithmetic operations
console.log(bigInt1 + bigInt2); // Works!
console.log(bigInt1 * 2n); // Must use BigInt operands

// ❌ Cannot mix BigInt and Number
// console.log(bigInt1 + 100); // TypeError: Cannot mix BigInt and other types

// ✅ Convert explicitly
console.log(bigInt1 + BigInt(100)); // Works

// Use case: Cryptography, precise integer calculations
const largeNumber = 9007199254740991n; // MAX_SAFE_INTEGER
console.log(largeNumber + 1n); // 9007199254740992n (precise!)
```

---

## Reference Types vs Primitives

### Primitive Types (Stored by Value)

Primitives are **immutable** and **compared by value**.

```javascript
let a = 10;
let b = a; // Copy value
b = 20;

console.log(a); // 10 (unchanged)
console.log(b); // 20

// Comparison by value
console.log(5 === 5); // true
console.log('hello' === 'hello'); // true
```

### Reference Types (Stored by Reference)

Objects, arrays, and functions are **mutable** and **compared by reference** (memory address).

```javascript
// Objects are compared by reference
const obj1 = { value: 10 };
const obj2 = { value: 10 };
const obj3 = obj1; // Copy reference, not value

console.log(obj1 === obj2); // false (different objects in memory)
console.log(obj1 === obj3); // true (same reference)

// Mutation affects all references
obj1.value = 20;
console.log(obj3.value); // 20 (same object!)

// Arrays are reference types
const arr1 = [1, 2, 3];
const arr2 = arr1; // Copy reference

arr1.push(4);
console.log(arr2); // [1, 2, 3, 4] (same array!)

// Shallow vs Deep Copy
const original = { name: 'Alice', address: { city: 'NYC' } };

// Shallow copy (top-level only)
const shallowCopy = { ...original };
shallowCopy.name = 'Bob'; // Doesn't affect original
shallowCopy.address.city = 'LA'; // Affects original! (nested object)

console.log(original.address.city); // "LA" (mutated!)

// Deep copy (all levels)
const deepCopy = JSON.parse(JSON.stringify(original));
// Or use structuredClone (modern browsers/Node.js 17+)
const deepCopy2 = structuredClone(original);
```

---

## Type Checking with typeof

The `typeof` operator returns a string indicating the type of a value.

### typeof Operator

```javascript
// Primitive types
console.log(typeof 42); // "number"
console.log(typeof 3.14); // "number"
console.log(typeof NaN); // "number" (!)
console.log(typeof Infinity); // "number"

console.log(typeof 'hello'); // "string"
console.log(typeof ''); // "string"

console.log(typeof true); // "boolean"
console.log(typeof false); // "boolean"

console.log(typeof undefined); // "undefined"

console.log(typeof Symbol('id')); // "symbol"

console.log(typeof 123n); // "bigint"

// Reference types
console.log(typeof null); // "object" (historical bug!)
console.log(typeof {}); // "object"
console.log(typeof []); // "object" (arrays are objects)
console.log(typeof new Date()); // "object"

console.log(typeof function() {}); // "function"
console.log(typeof class {}); // "function" (classes are functions)
```

### Advanced Type Checking

```javascript
// Check for null specifically
const isNull = value => value === null;

// Check for array
const isArray = value => Array.isArray(value);
console.log(isArray([])); // true
console.log(isArray({})); // false

// Check for plain object
const isPlainObject = value =>
  value !== null &&
  typeof value === 'object' &&
  !Array.isArray(value) &&
  !(value instanceof Date);

// Comprehensive type checker
const getType = value => {
  if (value === null) return 'null';
  if (Array.isArray(value)) return 'array';
  if (value instanceof Date) return 'date';
  if (value instanceof RegExp) return 'regexp';
  return typeof value;
};

console.log(getType(null)); // "null"
console.log(getType([])); // "array"
console.log(getType(new Date())); // "date"
console.log(getType(/regex/)); // "regexp"
```

---

## Type Conversion and Coercion

### Explicit Type Conversion (Casting)

**String Conversion:**
```javascript
// Using String()
const num = 123;
const str = String(num); // "123"

// Using .toString()
const bool = true;
const str2 = bool.toString(); // "true"

// Using template literals
const str3 = `${42}`; // "42"
```

**Number Conversion:**
```javascript
// Using Number()
console.log(Number('123')); // 123
console.log(Number('3.14')); // 3.14
console.log(Number('hello')); // NaN
console.log(Number(true)); // 1
console.log(Number(false)); // 0
console.log(Number(null)); // 0
console.log(Number(undefined)); // NaN

// Using parseInt() and parseFloat()
console.log(parseInt('123px')); // 123 (stops at first non-digit)
console.log(parseFloat('3.14em')); // 3.14
console.log(parseInt('0xFF', 16)); // 255 (hexadecimal)

// Using unary +
console.log(+'42'); // 42
```

**Boolean Conversion:**
```javascript
// Using Boolean()
console.log(Boolean(1)); // true
console.log(Boolean(0)); // false
console.log(Boolean('')); // false
console.log(Boolean('text')); // true
console.log(Boolean(null)); // false
console.log(Boolean(undefined)); // false
console.log(Boolean([])); // true (empty array is truthy!)
console.log(Boolean({})); // true (empty object is truthy!)

// Using double negation !!
console.log(!!1); // true
console.log(!!0); // false
```

### Implicit Type Coercion (Automatic)

JavaScript automatically converts types in certain contexts.

```javascript
// String coercion with + operator
console.log('5' + 3); // "53" (number → string)
console.log(5 + '3'); // "53"
console.log('Score: ' + 100); // "Score: 100"

// Numeric coercion with arithmetic operators
console.log('5' - 3); // 2 (string → number)
console.log('10' * '2'); // 20
console.log('20' / '4'); // 5
console.log('10' - 'abc'); // NaN

// Boolean coercion in conditionals
if ('hello') {
  console.log('Truthy!'); // Executes (non-empty string is truthy)
}

if (0) {
  console.log('Will not execute'); // 0 is falsy
}

// Comparison coercion
console.log('5' == 5); // true (loose equality, coercion happens)
console.log('5' === 5); // false (strict equality, no coercion)

// Edge cases
console.log([] + []); // "" (empty string)
console.log([] + {}); // "[object Object]"
console.log({} + []); // "[object Object]" (in expression context)
console.log(true + false); // 1 (true=1, false=0)
console.log(Number(null)); // 0
console.log(Number(undefined)); // NaN
```

**Best Practice:** Always use **strict equality (`===`)** to avoid unexpected coercion.

---

## Truthy and Falsy Values

In JavaScript, all values are either **truthy** or **falsy** when evaluated in a Boolean context.

### Falsy Values (Only 8!)

```javascript
// The complete list of falsy values:
const falsyValues = [
  false,        // Boolean false
  0,            // Number zero
  -0,           // Negative zero
  0n,           // BigInt zero
  '',           // Empty string
  null,         // Null
  undefined,    // Undefined
  NaN,          // Not a Number
];

// All of these evaluate to false in conditionals
falsyValues.forEach(value => {
  if (!value) {
    console.log(`${value} is falsy`);
  }
});
```

### Truthy Values (Everything Else!)

```javascript
// Examples of truthy values
const truthyValues = [
  true,           // Boolean true
  1,              // Any non-zero number
  -1,
  3.14,
  Infinity,
  'hello',        // Any non-empty string
  '0',            // String "0" (not number 0!)
  'false',        // String "false" (not boolean false!)
  [],             // Empty array (object!)
  {},             // Empty object
  function() {},  // Any function
];

// All of these evaluate to true in conditionals
truthyValues.forEach(value => {
  if (value) {
    console.log(`${value} is truthy`);
  }
});
```

### Practical Applications

```javascript
// Default values with || (OR operator)
const username = userInput || 'Anonymous'; // Use 'Anonymous' if userInput is falsy

// Nullish coalescing ?? (ES2020) - better for 0, '', false
const count = userCount ?? 10; // Only use 10 if userCount is null/undefined

// Short-circuit evaluation
const user = getUser() || createNewUser(); // Create only if getUser() fails

// Guard clauses
function processData(data) {
  if (!data) {
    throw new Error('Data is required');
  }
  // Process data...
}
```

---

## Notation and Conventions

### Variable Naming Rules

**Syntax Rules (enforced by JavaScript):**
1. Must start with: letter (`a-z`, `A-Z`), underscore (`_`), or dollar sign (`$`)
2. Subsequent characters: letters, digits (`0-9`), underscores, dollar signs
3. Cannot use reserved keywords: `const`, `let`, `var`, `function`, `class`, etc.
4. Case-sensitive: `myVar` ≠ `myvar`

```javascript
// ✅ Valid variable names
let userName;
let _private;
let $element;
let user123;
let αβγ; // Unicode letters allowed (but avoid for readability)

// ❌ Invalid variable names
// let 123user;       // Cannot start with digit
// let my-var;        // Hyphens not allowed
// let function;      // Reserved keyword
// let user name;     // Spaces not allowed
```

### Naming Conventions (best practices)

```javascript
// camelCase for variables and functions
const firstName = 'Alice';
const calculateTotal = (items) => items.reduce((sum, item) => sum + item.price, 0);

// PascalCase for classes and constructors
class UserAccount {
  constructor(name) {
    this.name = name;
  }
}

// UPPER_SNAKE_CASE for constants (configuration values)
const MAX_RETRY_ATTEMPTS = 3;
const API_BASE_URL = 'https://api.example.com';
const DEFAULT_TIMEOUT_MS = 5000;

// Prefix boolean variables with is/has/can
const isActive = true;
const hasPermission = false;
const canEdit = true;

// Use descriptive names (avoid abbreviations)
// ✅ Good
const userEmailAddress = 'alice@example.com';
const totalPriceWithTax = 109.99;

// ❌ Bad
const uea = 'alice@example.com'; // Too cryptic
const tpwt = 109.99; // Unclear
const x = 10; // No context
```

### Coding Style

```javascript
// ✅ CORRECT: Modern JavaScript style
const items = [1, 2, 3, 4, 5];

const evenNumbers = items
  .filter(n => n % 2 === 0)  // Predicate function
  .map(n => n * 2);           // Transform function

const user = {
  name: 'Alice',
  age: 30,
  email: 'alice@example.com', // Trailing comma
};

// ❌ AVOID: Legacy style
var items = [1, 2, 3, 4, 5];

var evenNumbers = items
  .filter(function(n) { return n % 2 === 0; })
  .map(function(n) { return n * 2; });
```

---

## Worked Examples

### Example 1: Variable Scope Demonstrator (Simple - 30 lines)

**Objective:** Demonstrate differences between `var`, `let`, and `const` scoping.

```javascript
/**
 * Example 1: Variable Scope Demonstrator
 *
 * Demonstrates:
 * - Function scope (var) vs block scope (let/const)
 * - Hoisting behavior
 * - Reassignment rules
 */

// --- Setup: Scope comparison function ---
function compareScopeKeywords() {
  console.log('=== VAR (Function-scoped) ===');

  // var is hoisted to function scope
  console.log('Before declaration:', typeof varVariable); // "undefined"
  var varVariable = 'var value';

  if (true) {
    var varVariable = 'var modified in block';
    console.log('Inside block:', varVariable); // "var modified in block"
  }

  console.log('After block:', varVariable); // "var modified in block" (leaked!)

  console.log('\n=== LET (Block-scoped) ===');

  // let is NOT hoisted (Temporal Dead Zone)
  // console.log('Before declaration:', letVariable); // ReferenceError!

  let letVariable = 'let value';

  if (true) {
    let letVariable = 'let in block'; // Different variable
    console.log('Inside block:', letVariable); // "let in block"
  }

  console.log('After block:', letVariable); // "let value" (preserved!)

  console.log('\n=== CONST (Block-scoped, immutable reference) ===');

  const constVariable = { value: 'original' };

  // constVariable = {}; // TypeError: Assignment to constant variable

  constVariable.value = 'modified'; // ✅ Object mutation allowed
  console.log('Mutated object:', constVariable.value); // "modified"
}

// --- Execute ---
compareScopeKeywords();

// --- Verification ---
import { expect } from 'vitest';

describe('Variable Scope', () => {
  it('should demonstrate block scope with let', () => {
    let outer = 'outer';

    if (true) {
      let outer = 'inner';
      expect(outer).toBe('inner');
    }

    expect(outer).toBe('outer'); // Preserved!
  });

  it('should prevent const reassignment', () => {
    const value = 10;
    expect(() => { value = 20; }).toThrow(); // TypeError
  });
});
```

---

### Example 2: Type-Safe Validator (Intermediate - 60 lines)

**Objective:** Build a robust type validation utility with error handling.

```javascript
/**
 * Example 2: Type-Safe Data Validator
 *
 * Demonstrates:
 * - Type checking with typeof
 * - Advanced type detection (arrays, null, dates)
 * - Input validation and sanitization
 * - Error handling patterns
 */

// --- Type validation utilities ---

/**
 * Validates if value is a valid number (not NaN or Infinity)
 * @param {*} value - Value to check
 * @returns {boolean}
 */
const isValidNumber = value => {
  return typeof value === 'number' && Number.isFinite(value);
};

/**
 * Validates if value is a non-empty string
 * @param {*} value - Value to check
 * @returns {boolean}
 */
const isNonEmptyString = value => {
  return typeof value === 'string' && value.trim().length > 0;
};

/**
 * Validates if value is a plain object (not null, array, or date)
 * @param {*} value - Value to check
 * @returns {boolean}
 */
const isPlainObject = value => {
  return (
    value !== null &&
    typeof value === 'object' &&
    !Array.isArray(value) &&
    !(value instanceof Date)
  );
};

/**
 * Schema validator for user objects
 * @param {*} data - Data to validate
 * @returns {{ valid: boolean, errors: string[] }}
 */
const validateUser = data => {
  const errors = [];

  // Check if data is an object
  if (!isPlainObject(data)) {
    return { valid: false, errors: ['Data must be a plain object'] };
  }

  // Validate name (required, non-empty string)
  if (!isNonEmptyString(data.name)) {
    errors.push('Name must be a non-empty string');
  }

  // Validate age (required, positive number)
  if (!isValidNumber(data.age) || data.age < 0 || data.age > 150) {
    errors.push('Age must be a number between 0 and 150');
  }

  // Validate email (required, basic format check)
  if (!isNonEmptyString(data.email) || !data.email.includes('@')) {
    errors.push('Email must be a valid email address');
  }

  // Validate isActive (optional boolean)
  if (data.isActive !== undefined && typeof data.isActive !== 'boolean') {
    errors.push('isActive must be a boolean');
  }

  return {
    valid: errors.length === 0,
    errors,
  };
};

// --- Example usage ---
const testCases = [
  { name: 'Alice', age: 30, email: 'alice@example.com', isActive: true },
  { name: '', age: 30, email: 'alice@example.com' }, // Invalid name
  { name: 'Bob', age: -5, email: 'bob@example.com' }, // Invalid age
  { name: 'Charlie', age: 25, email: 'invalid-email' }, // Invalid email
  null, // Invalid data type
  'not an object', // Invalid data type
];

testCases.forEach((testCase, index) => {
  const result = validateUser(testCase);
  console.log(`Test ${index + 1}:`, result.valid ? '✅ Valid' : '❌ Invalid');
  if (!result.valid) {
    console.log('  Errors:', result.errors);
  }
});

// --- Automated Tests ---
describe('Type Validator', () => {
  it('should validate correct user data', () => {
    const validUser = {
      name: 'Alice',
      age: 30,
      email: 'alice@example.com',
      isActive: true,
    };

    const result = validateUser(validUser);
    expect(result.valid).toBe(true);
    expect(result.errors).toHaveLength(0);
  });

  it('should reject invalid email', () => {
    const invalidUser = {
      name: 'Bob',
      age: 25,
      email: 'not-an-email',
    };

    const result = validateUser(invalidUser);
    expect(result.valid).toBe(false);
    expect(result.errors).toContain('Email must be a valid email address');
  });

  it('should reject non-object data', () => {
    const result = validateUser(null);
    expect(result.valid).toBe(false);
  });
});
```

---

### Example 3: Type Conversion Utility (Advanced - 80 lines)

**Objective:** Create a production-ready type conversion library with comprehensive error handling.

```javascript
/**
 * Example 3: Safe Type Conversion Utility
 *
 * Demonstrates:
 * - Explicit type conversion
 * - Error handling and fallback values
 * - Edge case handling (NaN, Infinity, etc.)
 * - Functional programming patterns
 */

// --- Conversion utilities ---

/**
 * Safely converts a value to a number
 * @param {*} value - Value to convert
 * @param {number} fallback - Fallback value if conversion fails
 * @returns {number}
 */
const toNumber = (value, fallback = 0) => {
  // Handle null and undefined
  if (value === null || value === undefined) return fallback;

  // Already a number
  if (typeof value === 'number') {
    return Number.isFinite(value) ? value : fallback;
  }

  // Convert string to number
  if (typeof value === 'string') {
    const trimmed = value.trim();
    if (trimmed === '') return fallback;

    const parsed = Number(trimmed);
    return Number.isFinite(parsed) ? parsed : fallback;
  }

  // Convert boolean to number
  if (typeof value === 'boolean') {
    return value ? 1 : 0;
  }

  // Cannot convert
  return fallback;
};

/**
 * Safely converts a value to a string
 * @param {*} value - Value to convert
 * @param {string} fallback - Fallback value if conversion fails
 * @returns {string}
 */
const toString = (value, fallback = '') => {
  // Handle null and undefined
  if (value === null) return 'null';
  if (value === undefined) return 'undefined';

  // Already a string
  if (typeof value === 'string') return value;

  // Handle objects and arrays with JSON
  if (typeof value === 'object') {
    try {
      return JSON.stringify(value);
    } catch {
      return fallback;
    }
  }

  // Primitive types
  return String(value);
};

/**
 * Safely converts a value to a boolean
 * @param {*} value - Value to convert
 * @returns {boolean}
 */
const toBoolean = value => {
  // Explicit true/false strings
  if (typeof value === 'string') {
    const lower = value.toLowerCase().trim();
    if (lower === 'true' || lower === 'yes' || lower === '1') return true;
    if (lower === 'false' || lower === 'no' || lower === '0') return false;
  }

  // Standard JavaScript truthiness
  return Boolean(value);
};

/**
 * Converts a value to the specified type
 * @param {*} value - Value to convert
 * @param {'number'|'string'|'boolean'} targetType - Target type
 * @param {*} fallback - Fallback value if conversion fails
 * @returns {number|string|boolean}
 */
const convertTo = (value, targetType, fallback) => {
  switch (targetType) {
    case 'number':
      return toNumber(value, fallback ?? 0);
    case 'string':
      return toString(value, fallback ?? '');
    case 'boolean':
      return toBoolean(value);
    default:
      throw new Error(`Unsupported target type: ${targetType}`);
  }
};

// --- Example usage ---
console.log('=== Number Conversions ===');
console.log(toNumber('42')); // 42
console.log(toNumber('3.14')); // 3.14
console.log(toNumber('invalid', 100)); // 100 (fallback)
console.log(toNumber(true)); // 1
console.log(toNumber(false)); // 0
console.log(toNumber(null, -1)); // -1 (fallback)

console.log('\n=== String Conversions ===');
console.log(toString(42)); // "42"
console.log(toString(true)); // "true"
console.log(toString(null)); // "null"
console.log(toString({ name: 'Alice' })); // '{"name":"Alice"}'
console.log(toString([1, 2, 3])); // "[1,2,3]"

console.log('\n=== Boolean Conversions ===');
console.log(toBoolean(1)); // true
console.log(toBoolean(0)); // false
console.log(toBoolean('yes')); // true
console.log(toBoolean('false')); // false
console.log(toBoolean([])); // true (truthy!)

// --- Automated Tests ---
describe('Type Conversion Utility', () => {
  describe('toNumber', () => {
    it('should convert string numbers', () => {
      expect(toNumber('42')).toBe(42);
      expect(toNumber('3.14')).toBe(3.14);
    });

    it('should return fallback for invalid values', () => {
      expect(toNumber('invalid', 999)).toBe(999);
      expect(toNumber(NaN, 0)).toBe(0);
      expect(toNumber(Infinity, 100)).toBe(100);
    });

    it('should convert booleans', () => {
      expect(toNumber(true)).toBe(1);
      expect(toNumber(false)).toBe(0);
    });
  });

  describe('toString', () => {
    it('should convert primitives', () => {
      expect(toString(42)).toBe('42');
      expect(toString(true)).toBe('true');
      expect(toString(null)).toBe('null');
    });

    it('should stringify objects', () => {
      expect(toString({ a: 1 })).toBe('{"a":1}');
    });
  });

  describe('toBoolean', () => {
    it('should convert string booleans', () => {
      expect(toBoolean('true')).toBe(true);
      expect(toBoolean('false')).toBe(false);
      expect(toBoolean('yes')).toBe(true);
      expect(toBoolean('no')).toBe(false);
    });

    it('should follow JavaScript truthiness', () => {
      expect(toBoolean(1)).toBe(true);
      expect(toBoolean(0)).toBe(false);
      expect(toBoolean('')).toBe(false);
      expect(toBoolean('text')).toBe(true);
    });
  });
});
```

---

## Exercises

### Exercise 1: Variable Shadowing Explorer (Difficulty: Easy)

**Task:** Create a program that demonstrates variable shadowing with `let` and `const` in nested scopes.

**Requirements:**
- Create three nested scopes (function → block → inner block)
- Declare a variable with the same name in each scope
- Log the variable value at each scope level
- Add comments explaining the shadowing behavior

**Starter Code:**
```javascript
// TODO: Implement variable shadowing demonstration
function exploreShadowing() {
  // Declare variable in function scope

  // Create first block scope
  {
    // Declare variable with same name

    // Create inner block scope
    {
      // Declare variable with same name again
    }
  }
}
```

**Hint:** Each `let` or `const` declaration in a nested block creates a new variable that shadows the outer one.

**Solution:** See `solutions/exercise-01-shadowing.js`

---

### Exercise 2: Type Checker Library (Difficulty: Medium)

**Task:** Build a comprehensive type checking library with functions for all JavaScript types.

**Requirements:**
- Create functions: `isString`, `isNumber`, `isBoolean`, `isNull`, `isUndefined`, `isArray`, `isObject`, `isFunction`, `isSymbol`, `isBigInt`
- Handle edge cases (NaN, Infinity, null vs undefined)
- Include a `getType` function that returns a precise type string
- Write comprehensive tests for all functions

**Example Usage:**
```javascript
isNumber(42); // true
isNumber(NaN); // false
isArray([]); // true
isObject([]); // false (not a plain object)
getType(null); // "null"
getType([]); // "array"
```

**Hint:** Use `typeof`, `Array.isArray()`, and strict equality checks.

**Solution:** See `solutions/exercise-02-type-checker.js`

---

### Exercise 3: Refactor Legacy Code (Difficulty: Medium)

**Task:** Refactor the provided legacy code to use modern JavaScript (ES6+) with proper variable declarations and best practices.

**Broken Code:**
```javascript
// Legacy code with var and poor practices
function processUserData() {
  var userName = "Alice";
  var userAge = 30;
  var userEmail;

  if (userAge >= 18) {
    var isAdult = true;
    var message = userName + " is an adult.";
  }

  console.log(message); // Works due to var hoisting

  for (var i = 0; i < 3; i++) {
    setTimeout(function() {
      console.log("Loop iteration: " + i);
    }, i * 1000);
  }
}
```

**Requirements:**
- Replace `var` with `const` or `let`
- Use template literals instead of string concatenation
- Fix the closure issue in the setTimeout loop
- Use arrow functions where appropriate
- Add proper error handling

**Hint:** The loop will log "Loop iteration: 3" three times due to `var` scoping. Fix with `let`.

**Solution:** See `solutions/exercise-03-refactor.js`

---

### Exercise 4: Primitive vs Reference Comparison (Difficulty: Medium)

**Task:** Create a utility function that deep compares two values, handling both primitives and reference types.

**Requirements:**
- Compare primitives by value
- Compare objects recursively (deep equality)
- Handle arrays, nested objects, null, undefined
- Return `true` if values are equal, `false` otherwise
- Include edge case tests (circular references, different types)

**Example Usage:**
```javascript
deepEqual(5, 5); // true
deepEqual(5, '5'); // false
deepEqual({ a: 1 }, { a: 1 }); // true
deepEqual({ a: { b: 2 } }, { a: { b: 2 } }); // true
deepEqual([1, 2, 3], [1, 2, 3]); // true
```

**Hint:** Recursively compare object keys and values. Check array lengths first.

**Solution:** See `solutions/exercise-04-deep-equal.js`

---

### Exercise 5: Configuration Manager (Difficulty: Hard)

**Task:** Build a configuration management system that validates, converts, and provides type-safe access to configuration values.

**Requirements:**
- Accept configuration from environment variables, objects, or JSON strings
- Define a schema with expected types and default values
- Validate all configuration values against the schema
- Provide type conversion (string "true" → boolean true)
- Throw descriptive errors for invalid configurations
- Support nested configuration objects
- Include comprehensive tests

**Schema Example:**
```javascript
const schema = {
  port: { type: 'number', default: 3000, min: 1, max: 65535 },
  host: { type: 'string', default: 'localhost' },
  debug: { type: 'boolean', default: false },
  database: {
    type: 'object',
    schema: {
      url: { type: 'string', required: true },
      maxConnections: { type: 'number', default: 10 },
    },
  },
};
```

**Hint:** Use recursive validation for nested objects. Store converted values internally.

**Solution:** See `solutions/exercise-05-config-manager.js`

---

### Exercise 6: Memory Efficiency Challenge (Difficulty: Hard)

**Task:** Analyze and optimize code for memory efficiency, focusing on primitive vs reference type usage.

**Scenario:** You're building a data processing system that handles millions of user records. Each record contains: `id` (number), `name` (string), `email` (string), `isActive` (boolean).

**Requirements:**
- Compare memory usage of different data structures (array of objects vs separate typed arrays)
- Implement both approaches and measure memory footprint
- Explain trade-offs between readability and memory efficiency
- Provide performance benchmarks for common operations (filter, map, reduce)
- Write a report with recommendations

**Hint:** Use `process.memoryUsage()` in Node.js to measure memory consumption.

**Solution:** See `solutions/exercise-06-memory-optimization.js`

---

## Practical Applications

### Application 1: API Response Validation

Production APIs must validate response data to prevent type errors.

```javascript
/**
 * Validates and normalizes API response data
 */
const validateApiResponse = response => {
  // Check response structure
  if (!response || typeof response !== 'object') {
    throw new TypeError('Invalid API response: expected object');
  }

  // Validate required fields
  const { status, data } = response;

  if (typeof status !== 'number') {
    throw new TypeError('Invalid status: expected number');
  }

  if (status < 200 || status >= 300) {
    throw new Error(`API error: status ${status}`);
  }

  // Return normalized data
  return {
    status,
    data: data ?? null,
    timestamp: new Date().toISOString(),
  };
};
```

### Application 2: Form Input Sanitization

User input requires type conversion and validation.

```javascript
/**
 * Sanitizes form input data
 */
const sanitizeFormData = formData => {
  return {
    username: String(formData.username || '').trim(),
    age: parseInt(formData.age, 10) || 0,
    email: String(formData.email || '').toLowerCase().trim(),
    newsletter: toBoolean(formData.newsletter),
  };
};
```

### Application 3: Database Query Builder

Type-safe query parameters prevent SQL injection and errors.

```javascript
/**
 * Builds type-safe database queries
 */
const buildQuery = (table, conditions) => {
  const validConditions = Object.entries(conditions)
    .filter(([key, value]) => {
      // Only include valid types
      return (
        typeof value === 'string' ||
        typeof value === 'number' ||
        typeof value === 'boolean'
      );
    })
    .map(([key, value]) => {
      // Escape and format based on type
      if (typeof value === 'string') {
        return `${key} = '${value.replace(/'/g, "''")}'`; // Escape quotes
      }
      return `${key} = ${value}`;
    });

  return `SELECT * FROM ${table} WHERE ${validConditions.join(' AND ')}`;
};
```

---

## Testing and Verification

### Setting Up Tests

```bash
# Install Vitest (testing framework)
npm install --save-dev vitest

# Run tests
npm test

# Run tests in watch mode
npm test -- --watch

# Generate coverage report
npm test -- --coverage
```

### Test Template

```javascript
import { describe, it, expect, beforeEach, afterEach } from 'vitest';

describe('Variable and Type Tests', () => {
  describe('Type Checking', () => {
    it('should identify primitive types', () => {
      expect(typeof 42).toBe('number');
      expect(typeof 'hello').toBe('string');
      expect(typeof true).toBe('boolean');
    });

    it('should handle null correctly', () => {
      const value = null;
      expect(value === null).toBe(true);
      expect(typeof value).toBe('object'); // Known quirk
    });
  });

  describe('Type Conversion', () => {
    it('should convert strings to numbers', () => {
      expect(Number('42')).toBe(42);
      expect(parseInt('42px')).toBe(42);
      expect(parseFloat('3.14')).toBe(3.14);
    });

    it('should handle invalid conversions', () => {
      expect(Number('invalid')).toBeNaN();
      expect(Number(undefined)).toBeNaN();
    });
  });
});
```

---

## Common Pitfalls and Debugging

### Pitfall 1: `typeof null` Returns "object"

**Problem:**
```javascript
console.log(typeof null); // "object" (not "null"!)
```

**Explanation:** This is a historical JavaScript bug from the language's initial implementation. The ECMAScript committee decided not to fix it to avoid breaking existing code.

**Solution:**
```javascript
// Explicit null check
const isNull = value => value === null;

// Comprehensive type checker
const getType = value => {
  if (value === null) return 'null';
  if (Array.isArray(value)) return 'array';
  return typeof value;
};
```

---

### Pitfall 2: Type Coercion with `==` Operator

**Problem:**
```javascript
console.log(0 == false); // true (unexpected!)
console.log('' == false); // true
console.log('0' == 0); // true
console.log(null == undefined); // true
```

**Explanation:** Loose equality (`==`) performs type coercion, leading to unexpected comparisons.

**Solution:**
```javascript
// ✅ Always use strict equality
console.log(0 === false); // false
console.log('' === false); // false
console.log('0' === 0); // false
console.log(null === undefined); // false
```

---

### Pitfall 3: NaN is Not Equal to Itself

**Problem:**
```javascript
const value = NaN;
console.log(value === NaN); // false (!)
console.log(value == NaN); // false
```

**Explanation:** `NaN` is the only JavaScript value that is not equal to itself (IEEE 754 spec).

**Solution:**
```javascript
// ✅ Use Number.isNaN()
console.log(Number.isNaN(NaN)); // true
console.log(Number.isNaN(42)); // false

// ❌ Avoid global isNaN (coerces to number first)
console.log(isNaN('hello')); // true (coerces to NaN)
console.log(Number.isNaN('hello')); // false (no coercion)
```

---

### Pitfall 4: Empty Array and Object are Truthy

**Problem:**
```javascript
if ([]) {
  console.log('Empty array is truthy!'); // Executes!
}

if ({}) {
  console.log('Empty object is truthy!'); // Executes!
}
```

**Explanation:** All objects (including arrays) are truthy, even when empty.

**Solution:**
```javascript
// ✅ Check array length
if (array.length > 0) {
  console.log('Array has items');
}

// ✅ Check object keys
if (Object.keys(obj).length > 0) {
  console.log('Object has properties');
}
```

---

### Pitfall 5: Floating-Point Precision

**Problem:**
```javascript
console.log(0.1 + 0.2); // 0.30000000000000004 (not 0.3!)
console.log(0.1 + 0.2 === 0.3); // false
```

**Explanation:** IEEE 754 floating-point arithmetic has precision limitations.

**Solution:**
```javascript
// ✅ Round to desired precision
const sum = Math.round((0.1 + 0.2) * 100) / 100; // 0.3

// ✅ Use epsilon comparison for equality
const EPSILON = Number.EPSILON;
const almostEqual = (a, b) => Math.abs(a - b) < EPSILON;

console.log(almostEqual(0.1 + 0.2, 0.3)); // true

// ✅ Use libraries for decimal precision (e.g., decimal.js)
```

---

### Pitfall 6: Variable Hoisting with `var`

**Problem:**
```javascript
console.log(x); // undefined (not ReferenceError!)
var x = 5;
console.log(x); // 5
```

**Explanation:** `var` declarations are hoisted to the top of the function, but assignments remain in place.

**Solution:**
```javascript
// ✅ Use let/const (no hoisting to usable state)
console.log(y); // ReferenceError: Cannot access 'y' before initialization
let y = 5;
```

---

### Debugging Techniques

**1. Type Inspection:**
```javascript
const inspect = value => {
  console.log('Value:', value);
  console.log('Type:', typeof value);
  console.log('Is Array:', Array.isArray(value));
  console.log('Constructor:', value?.constructor?.name);
  console.log('JSON:', JSON.stringify(value, null, 2));
};
```

**2. Assertion-Based Debugging:**
```javascript
import assert from 'node:assert/strict';

const validateInput = value => {
  assert(typeof value === 'number', 'Expected number');
  assert(Number.isFinite(value), 'Expected finite number');
  return value * 2;
};
```

**3. Runtime Type Guards:**
```javascript
const processUser = user => {
  if (!user || typeof user !== 'object') {
    throw new TypeError('Invalid user object');
  }

  if (typeof user.name !== 'string') {
    throw new TypeError('User name must be a string');
  }

  // Safe to proceed...
};
```

---

## Security Considerations

### Input Validation

**Risk:** Unvalidated input can cause type errors, injections, or crashes.

```javascript
// ❌ DANGEROUS: No validation
const processAge = age => {
  const nextYear = age + 1; // What if age is not a number?
  return nextYear;
};

// ✅ SAFE: Validate and sanitize
const processAgeSafe = age => {
  // Type guard
  if (typeof age !== 'number' || !Number.isFinite(age)) {
    throw new TypeError('Age must be a valid number');
  }

  // Range validation
  if (age < 0 || age > 150) {
    throw new RangeError('Age must be between 0 and 150');
  }

  return age + 1;
};
```

### Type Coercion Exploits

**Risk:** Attackers can exploit type coercion for injections or bypasses.

```javascript
// ❌ VULNERABLE: Loose equality allows bypass
const isAdmin = userRole => {
  return userRole == 'admin'; // "0" == 0 == false
};

// Attacker passes: { userRole: 0 }
// "admin" == 0 → false (expected)
// But if logic is inverted...

// ✅ SECURE: Strict equality
const isAdminSafe = userRole => {
  return userRole === 'admin'; // Type-safe comparison
};
```

### Environment Variable Type Handling

**Risk:** Environment variables are always strings and need conversion.

```javascript
// ❌ WRONG: Treating string as boolean
const DEBUG = process.env.DEBUG; // "false" (string)
if (DEBUG) {
  console.log('Debug mode'); // Always executes! ("false" is truthy)
}

// ✅ CORRECT: Convert to boolean
const DEBUG_SAFE = process.env.DEBUG === 'true';
if (DEBUG_SAFE) {
  console.log('Debug mode'); // Only when truly enabled
}
```

---

## Performance Notes

### Primitive vs Reference Performance

**Primitives are faster:**
```javascript
// Primitives: Stored on stack, fast access
const num1 = 42;
const num2 = num1; // Fast copy

// References: Stored on heap, slower access
const obj1 = { value: 42 };
const obj2 = obj1; // Copies reference, not value
```

### Type Checking Performance

```javascript
// Fast type checks (single operation)
typeof value === 'string'; // Fast
typeof value === 'number'; // Fast

// Slower type checks (multiple operations)
Array.isArray(value); // Slower (function call)
value instanceof Date; // Slower (prototype chain walk)
```

### Type Conversion Performance

```javascript
// Fastest string→number conversion
const num = +str; // Unary plus

// Fast alternatives
const num2 = Number(str);
const num3 = parseInt(str, 10); // Specify radix!

// Slow (avoid in loops)
const num4 = parseFloat(str);
```

### Memory Considerations

```javascript
// Strings are immutable - concatenation creates new strings
let result = '';
for (let i = 0; i < 10000; i++) {
  result += 'text'; // Creates 10,000 string objects!
}

// ✅ Better: Use array join
const parts = [];
for (let i = 0; i < 10000; i++) {
  parts.push('text');
}
const result2 = parts.join(''); // Single concatenation
```

---

## Summary and Next Steps

### Key Takeaways

1. **Use `const` by default**, `let` when reassignment is needed, and never use `var`
2. **JavaScript has 7 primitive types**: number, string, boolean, null, undefined, symbol, bigint
3. **Primitives are immutable** and stored by value; objects are mutable and stored by reference
4. **Use `typeof` for type checking**, but remember `typeof null === "object"` (quirk)
5. **Always use strict equality (`===`)** to avoid type coercion bugs
6. **Understand truthy/falsy values**: Only 8 falsy values exist; everything else is truthy
7. **Validate and convert types explicitly** in production code to prevent runtime errors
8. **Follow naming conventions**: camelCase for variables, PascalCase for classes, UPPER_SNAKE_CASE for constants

### What You've Accomplished

- ✅ Mastered variable declaration with `var`, `let`, and `const`
- ✅ Understood all JavaScript primitive and reference types
- ✅ Implemented type checking and conversion utilities
- ✅ Built production-ready validators and type guards
- ✅ Debugged common type-related pitfalls
- ✅ Applied security best practices for type handling

### Next Topics to Study

1. **Operators** → [02.Operators.md](../02.Operators/02.Operators.md)
   - Arithmetic, logical, bitwise operators
   - Operator precedence and associativity

2. **Control Structures** → [03.Control_Structures_Conditionals.md](../03.Control_Structures_Conditionals/03.Control_Structures_Conditionals.md)
   - if/else, switch, ternary operator
   - Loops and iteration

3. **Functions** → [04.Functions.md](../04.Functions/04.Functions.md)
   - Function declarations, expressions, arrow functions
   - Closures and scope

### Practice Projects

1. **Build a Form Validator**
   - Validate user input types
   - Provide descriptive error messages
   - Support custom validation rules

2. **Create a Type-Safe Storage Library**
   - Wrap `localStorage` with type conversion
   - Serialize/deserialize with type preservation
   - Handle errors gracefully

3. **Develop a Configuration Parser**
   - Read environment variables
   - Convert to appropriate types
   - Validate against schema

4. **Implement a Data Transformation Pipeline**
   - Accept various input types
   - Transform through multiple stages
   - Output type-safe results

---

## References

### Official Documentation

- [MDN: JavaScript Data Types and Data Structures](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures) - Comprehensive reference
- [MDN: var](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var) - Legacy variable declaration
- [MDN: let](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let) - Block-scoped variables
- [MDN: const](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const) - Constants
- [MDN: typeof operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof) - Type checking
- [ECMAScript Type System](https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values) - Official specification

### Type Conversion & Coercion

- [MDN: Type Coercion](https://developer.mozilla.org/en-US/docs/Glossary/Type_coercion) - Understanding automatic conversions
- [JavaScript Equality Table](https://dorey.github.io/JavaScript-Equality-Table/) - Interactive comparison visualizer
- [Abstract Equality Comparison Algorithm](https://262.ecma-international.org/5.1/#sec-11.9.3) - How `==` works internally

### Best Practices & Style Guides

- [Airbnb JavaScript Style Guide](https://github.com/airbnb/javascript#variables) - Industry-standard practices
- [Google JavaScript Style Guide](https://google.github.io/styleguide/jsguide.html#features-local-variable-declarations) - Google's conventions
- [JavaScript Standard Style](https://standardjs.com/) - Zero-configuration linter

### Advanced Topics

- [You Don't Know JS: Types & Grammar](https://github.com/getify/You-Dont-Know-JS/blob/1st-ed/types%20%26%20grammar/README.md) - Deep dive into types
- [IEEE 754 Floating Point](https://en.wikipedia.org/wiki/IEEE_754) - Understanding number precision
- [Temporal Dead Zone (TDZ)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#temporal_dead_zone_tdz) - let/const initialization

### Tools & Utilities

- [TypeScript Playground](https://www.typescriptlang.org/play) - Experiment with static typing
- [Babel REPL](https://babeljs.io/repl) - Test type coercion behavior
- [JS Comparison Table](https://felix-kling.de/js-loose-comparison/) - Visualize `==` vs `===`

### Books & Tutorials

- [Eloquent JavaScript - Chapter 1: Values, Types, and Operators](https://eloquentjavascript.net/01_values.html)
- [JavaScript.info - Data Types](https://javascript.info/types)
- [Exploring JS - Variables and Assignment](https://exploringjs.com/impatient-js/ch_variables-assignment.html)

---

**Last Updated:** 2025-11-22
**Curriculum Version:** 2.0.0
**Maintainer:** Code Galaxy Contributors

**Previous Lesson:** ← [Introduction to JavaScript](../00.Introduction_to_JavaScript/00.Introduction_to_JavaScript.md)
**Next Lesson:** [Operators](../02.Operators/02.Operators.md) →
