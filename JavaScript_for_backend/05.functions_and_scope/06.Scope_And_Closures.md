# Scope and Closures in JavaScript

**Difficulty:** Intermediate to Advanced
**Estimated Time:** 60-75 minutes
**Prerequisites:** Functions, variables (var/let/const), basic JavaScript
**Target:** Node.js 18+ LTS, Modern Browsers (ES2021+)

---

## Learning Objectives

By the end of this lesson, you will be able to:

1. Understand and distinguish between global, function, and block scope
2. Master lexical scoping and the scope chain mechanism
3. Implement and leverage closures for data privacy and encapsulation
4. Build factory functions and use the module pattern effectively
5. Apply closures for memoization and performance optimization
6. Understand memory implications of closures and avoid memory leaks
7. Debug scope and closure-related issues
8. Recognize and avoid common closure pitfalls

---

## Table of Contents

1. [Introduction](#introduction)
2. [Global Scope](#global-scope)
3. [Function Scope](#function-scope)
4. [Block Scope](#block-scope)
5. [Lexical Scoping](#lexical-scoping)
6. [Scope Chain](#scope-chain)
7. [Closures - Deep Dive](#closures-deep-dive)
8. [Data Privacy with Closures](#data-privacy-with-closures)
9. [Factory Functions](#factory-functions)
10. [Memoization with Closures](#memoization-with-closures)
11. [Module Pattern](#module-pattern)
12. [Memory Implications](#memory-implications)
13. [Common Closure Pitfalls](#common-closure-pitfalls)
14. [Worked Examples](#worked-examples)
15. [Exercises](#exercises)
16. [Testing & Debugging](#testing--debugging)
17. [Best Practices](#best-practices)
18. [Summary & Next Steps](#summary--next-steps)

---

## Introduction

**Scope** determines where variables and functions are accessible in your code. **Closures** are one of JavaScript's most powerful features, enabling data encapsulation, functional programming patterns, and elegant solutions to complex problems.

Understanding scope and closures is crucial for:
- Writing maintainable, bug-free code
- Implementing design patterns (module, factory, singleton)
- Managing state in applications
- Understanding asynchronous JavaScript
- Building frameworks and libraries

**Key Concepts:**
- Scope defines variable accessibility
- Closures allow functions to "remember" their lexical environment
- The scope chain determines variable resolution
- Memory management is important when using closures

---

## Global Scope

**Global scope** is the outermost scope in JavaScript. Variables declared in global scope are accessible everywhere in your program.

### Characteristics

```javascript
// Global variable
const appName = 'MyApp';
let userCount = 0;

function incrementUsers() {
  userCount++; // Can access global variable
}

function displayInfo() {
  console.log(appName); // Can access global variable
}

incrementUsers();
displayInfo(); // 'MyApp'
console.log(userCount); // 1
```

### Global Object

In browsers, global variables become properties of the `window` object. In Node.js, they're properties of `global`.

```javascript
// Browser environment
var globalVar = 'I am global';
console.log(window.globalVar); // 'I am global'

// Note: let and const don't create window properties
let modernVar = 'Also global, but not on window';
console.log(window.modernVar); // undefined
```

### Problems with Global Scope

```javascript
// Problem 1: Name collisions
var name = 'Alice';

// Another file or library
var name = 'Bob'; // Overwrites previous value!

// Problem 2: Unintended dependencies
function calculate() {
  return globalValue * 2; // Depends on global state
}

// Problem 3: Testing difficulties
// Global state makes unit testing harder

// Problem 4: Memory leaks
// Global variables never get garbage collected
```

### Best Practices

```javascript
// ❌ Avoid: Polluting global scope
var config = { /* ... */ };
var utils = { /* ... */ };

// ✅ Good: Use modules and encapsulation
const MyApp = {
  config: { /* ... */ },
  utils: { /* ... */ }
};

// ✅ Better: Use ES6 modules
// config.js
export const config = { /* ... */ };

// utils.js
export const utils = { /* ... */ };
```

---

## Function Scope

**Function scope** means variables declared inside a function are only accessible within that function.

### var and Function Scope

```javascript
function processOrder() {
  var orderId = 12345;
  var total = 99.99;

  console.log(orderId); // 12345 - accessible inside function

  if (total > 50) {
    var discount = 10; // var is function-scoped, not block-scoped
    console.log(discount); // 10
  }

  console.log(discount); // 10 - still accessible (var ignores block scope)
}

processOrder();
// console.log(orderId); // ReferenceError: orderId is not defined
```

### Nested Functions

```javascript
function outer() {
  const outerVar = 'I am outer';

  function inner() {
    const innerVar = 'I am inner';
    console.log(outerVar); // Can access outer variable
    console.log(innerVar); // Can access own variable
  }

  inner();
  // console.log(innerVar); // ReferenceError: innerVar is not defined
}

outer();
```

### Function Scope Isolation

```javascript
function createCounter() {
  let count = 0; // Private to this function

  return {
    increment() {
      count++;
      return count;
    },
    getCount() {
      return count;
    }
  };
}

const counter1 = createCounter();
const counter2 = createCounter();

counter1.increment(); // 1
counter1.increment(); // 2
counter2.increment(); // 1 - separate scope, separate count

// count is not accessible from outside
// console.log(count); // ReferenceError
```

---

## Block Scope

**Block scope** (introduced in ES6) means variables declared with `let` or `const` are only accessible within the block `{}` where they're defined.

### let and const

```javascript
if (true) {
  let blockVar = 'I am block scoped';
  const alsoBlockScoped = 'Me too';

  console.log(blockVar); // Works
}

// console.log(blockVar); // ReferenceError: blockVar is not defined
```

### Comparison: var vs let/const

```javascript
// var: Function-scoped
function testVar() {
  if (true) {
    var x = 10;
  }
  console.log(x); // 10 - accessible outside if block
}

// let: Block-scoped
function testLet() {
  if (true) {
    let y = 10;
  }
  // console.log(y); // ReferenceError: y is not defined
}
```

### Block Scope in Loops

```javascript
// var in loops (problematic)
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);
}
// Prints: 3, 3, 3 (var is not block-scoped)

// let in loops (correct)
for (let j = 0; j < 3; j++) {
  setTimeout(() => console.log(j), 100);
}
// Prints: 0, 1, 2 (let creates new binding for each iteration)
```

### Practical Block Scope Example

```javascript
function processItems(items) {
  const results = [];

  for (let i = 0; i < items.length; i++) {
    const item = items[i]; // Block-scoped to loop iteration

    if (item.active) {
      const processed = processItem(item); // Block-scoped to if block
      results.push(processed);
    }

    // processed is not accessible here
  }

  // item is not accessible here
  // i is not accessible here

  return results;
}
```

### Temporal Dead Zone (TDZ)

```javascript
function demonstrateTDZ() {
  // TDZ starts
  // console.log(x); // ReferenceError: Cannot access 'x' before initialization
  let x = 10; // TDZ ends
  console.log(x); // 10
}

// var doesn't have TDZ
function noTDZ() {
  console.log(y); // undefined (hoisted but not initialized)
  var y = 10;
  console.log(y); // 10
}
```

---

## Lexical Scoping

**Lexical scoping** (also called static scoping) means a function's scope is determined by where it's **written** in the code, not where it's **called**.

### Basic Lexical Scope

```javascript
const globalVar = 'global';

function outer() {
  const outerVar = 'outer';

  function inner() {
    const innerVar = 'inner';
    console.log(globalVar); // 'global'
    console.log(outerVar);  // 'outer'
    console.log(innerVar);  // 'inner'
  }

  inner();
}

outer();
```

### Lexical Scope vs Dynamic Scope

JavaScript uses lexical scope, not dynamic scope:

```javascript
const value = 'global';

function printValue() {
  console.log(value); // Looks up lexically, not dynamically
}

function caller1() {
  const value = 'caller1';
  printValue(); // Prints 'global', not 'caller1'
}

function caller2() {
  const value = 'caller2';
  printValue(); // Prints 'global', not 'caller2'
}

caller1(); // 'global'
caller2(); // 'global'
```

**Explanation:** `printValue` looks for `value` in its lexical scope (where it was defined), not in the scope where it's called.

### Nested Lexical Scopes

```javascript
function level1() {
  const a = 1;

  function level2() {
    const b = 2;

    function level3() {
      const c = 3;
      console.log(a, b, c); // 1 2 3 - can access all outer scopes
    }

    level3();
    // console.log(c); // ReferenceError - can't access inner scope
  }

  level2();
}

level1();
```

---

## Scope Chain

The **scope chain** is the mechanism JavaScript uses to resolve variable names. It searches the current scope, then outer scopes, until it finds the variable or reaches global scope.

### How Scope Chain Works

```javascript
const global = 'global';

function outer() {
  const outerVar = 'outer';

  function middle() {
    const middleVar = 'middle';

    function inner() {
      const innerVar = 'inner';

      // Scope chain resolution:
      console.log(innerVar);   // 1. Found in current scope
      console.log(middleVar);  // 2. Found in parent scope
      console.log(outerVar);   // 3. Found in grandparent scope
      console.log(global);     // 4. Found in global scope
    }

    inner();
  }

  middle();
}

outer();
```

### Scope Chain Visualization

```javascript
const a = 'global a';

function first() {
  const b = 'first b';

  function second() {
    const c = 'second c';

    function third() {
      const d = 'third d';
      console.log(a, b, c, d);

      // Scope chain: third → second → first → global
    }

    third();
  }

  second();
}

first();
```

### Variable Shadowing

When an inner scope declares a variable with the same name as an outer scope variable, it **shadows** the outer variable.

```javascript
const value = 'global';

function shadowExample() {
  const value = 'outer'; // Shadows global value

  function inner() {
    const value = 'inner'; // Shadows outer value
    console.log(value); // 'inner' - uses closest scope
  }

  inner();
  console.log(value); // 'outer'
}

shadowExample();
console.log(value); // 'global'
```

### Scope Chain and Performance

```javascript
// Less efficient: Deep scope chain
const config = { apiKey: 'xxx' };

function level1() {
  function level2() {
    function level3() {
      function level4() {
        console.log(config.apiKey); // Must traverse 4 scopes
      }
      level4();
    }
    level3();
  }
  level2();
}

// More efficient: Cache in local scope
function level1() {
  const apiKey = config.apiKey; // Cache in local scope
  function level2() {
    function level3() {
      function level4() {
        console.log(apiKey); // Direct access
      }
      level4();
    }
    level3();
  }
  level2();
}
```

---

## Closures - Deep Dive

A **closure** is a function that has access to variables from its outer (lexical) scope, even after the outer function has finished executing.

### Definition

Every function in JavaScript forms a closure. A closure has three scope chains:
1. Its own scope (variables defined between its curly braces)
2. Outer function's variables
3. Global variables

### Basic Closure

```javascript
function makeGreeting(greeting) {
  // greeting is captured by the closure
  return function(name) {
    return `${greeting}, ${name}!`;
  };
}

const sayHello = makeGreeting('Hello');
const sayHi = makeGreeting('Hi');

console.log(sayHello('Alice')); // 'Hello, Alice!'
console.log(sayHi('Bob'));      // 'Hi, Bob!'

// sayHello and sayHi each have their own closure
// with different values of 'greeting'
```

### Closure Mechanism

```javascript
function createCounter() {
  let count = 0; // This variable is "closed over"

  return function() {
    count++; // Inner function maintains reference to count
    return count;
  };
}

const counter = createCounter();

console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3

// count persists between calls!
// It's not in global scope, and createCounter has finished executing
// But the closure keeps count alive
```

### Multiple Closures

```javascript
function createAccount(initialBalance) {
  let balance = initialBalance;

  return {
    deposit(amount) {
      balance += amount;
      return balance;
    },

    withdraw(amount) {
      if (amount > balance) {
        throw new Error('Insufficient funds');
      }
      balance -= amount;
      return balance;
    },

    getBalance() {
      return balance;
    }
  };
}

const account1 = createAccount(1000);
const account2 = createAccount(500);

account1.deposit(200);   // 1200
account2.withdraw(100);  // 400

console.log(account1.getBalance()); // 1200
console.log(account2.getBalance()); // 400

// Each account has its own closure with its own balance
```

### Closure vs Object

```javascript
// Using closure
function createPersonClosure(name) {
  let age = 0;

  return {
    getName: () => name,
    getAge: () => age,
    birthday: () => age++
  };
}

// Using object
function createPersonObject(name) {
  return {
    name,
    age: 0,
    birthday() {
      this.age++;
    }
  };
}

const person1 = createPersonClosure('Alice');
const person2 = createPersonObject('Bob');

person1.birthday();
person2.birthday();

console.log(person1.getAge()); // 1 (private)
console.log(person2.age);       // 1 (public, can be modified directly)

// person2.age = 100; // Can be changed
// person1.age = 100; // No effect, age is private
```

---

## Data Privacy with Closures

Closures enable true data privacy in JavaScript by creating variables that are accessible only through specific methods.

### Private Variables

```javascript
function createUser(name, email) {
  // Private variables
  let _name = name;
  let _email = email;
  let _password = null;

  // Public interface
  return {
    getName() {
      return _name;
    },

    getEmail() {
      return _email;
    },

    setPassword(password) {
      if (password.length < 8) {
        throw new Error('Password must be at least 8 characters');
      }
      _password = hashPassword(password);
    },

    verifyPassword(password) {
      return hashPassword(password) === _password;
    }

    // Note: No direct access to _password
  };
}

function hashPassword(password) {
  // Simple hash for demo (use bcrypt in production)
  return password.split('').reverse().join('');
}

const user = createUser('Alice', 'alice@example.com');
user.setPassword('securepass123');

console.log(user.getName());           // 'Alice'
console.log(user.verifyPassword('securepass123')); // true
// console.log(user._password);        // undefined - truly private
```

### Encapsulation Example

```javascript
function createShoppingCart() {
  // Private state
  const items = [];

  // Private helper
  function findItem(productId) {
    return items.find(item => item.id === productId);
  }

  // Public API
  return {
    addItem(product, quantity = 1) {
      const existingItem = findItem(product.id);

      if (existingItem) {
        existingItem.quantity += quantity;
      } else {
        items.push({ ...product, quantity });
      }
    },

    removeItem(productId) {
      const index = items.findIndex(item => item.id === productId);
      if (index !== -1) {
        items.splice(index, 1);
      }
    },

    updateQuantity(productId, quantity) {
      const item = findItem(productId);
      if (item) {
        item.quantity = quantity;
      }
    },

    getItems() {
      // Return copy to prevent external modification
      return items.map(item => ({ ...item }));
    },

    getTotal() {
      return items.reduce((sum, item) => sum + (item.price * item.quantity), 0);
    },

    getItemCount() {
      return items.reduce((sum, item) => sum + item.quantity, 0);
    },

    clear() {
      items.length = 0;
    }
  };
}

const cart = createShoppingCart();

cart.addItem({ id: 1, name: 'Book', price: 20 }, 2);
cart.addItem({ id: 2, name: 'Pen', price: 5 }, 5);

console.log(cart.getTotal());      // 65
console.log(cart.getItemCount());  // 7
console.log(cart.getItems());      // Array of items (copy)

// cart.items is not accessible - truly private
```

---

## Factory Functions

**Factory functions** are functions that return objects. Combined with closures, they provide an elegant way to create multiple instances with private state.

### Basic Factory

```javascript
function createLogger(prefix) {
  return {
    log(message) {
      console.log(`[${prefix}] ${message}`);
    },

    error(message) {
      console.error(`[${prefix}] ERROR: ${message}`);
    },

    warn(message) {
      console.warn(`[${prefix}] WARNING: ${message}`);
    }
  };
}

const appLogger = createLogger('APP');
const dbLogger = createLogger('DATABASE');

appLogger.log('Application started');     // [APP] Application started
dbLogger.error('Connection failed');      // [DATABASE] ERROR: Connection failed
```

### Factory with Configuration

```javascript
function createValidator(config = {}) {
  const {
    minLength = 0,
    maxLength = Infinity,
    required = false,
    pattern = null,
    customValidator = null
  } = config;

  return function validate(value) {
    const errors = [];

    if (required && !value) {
      errors.push('This field is required');
    }

    if (value && value.length < minLength) {
      errors.push(`Minimum length is ${minLength}`);
    }

    if (value && value.length > maxLength) {
      errors.push(`Maximum length is ${maxLength}`);
    }

    if (pattern && !pattern.test(value)) {
      errors.push('Invalid format');
    }

    if (customValidator && !customValidator(value)) {
      errors.push('Custom validation failed');
    }

    return {
      isValid: errors.length === 0,
      errors
    };
  };
}

const emailValidator = createValidator({
  required: true,
  pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/
});

const passwordValidator = createValidator({
  required: true,
  minLength: 8,
  customValidator: (val) => /[A-Z]/.test(val) && /[0-9]/.test(val)
});

console.log(emailValidator('invalid-email'));
// { isValid: false, errors: ['Invalid format'] }

console.log(passwordValidator('weak'));
// { isValid: false, errors: ['Minimum length is 8'] }
```

### Factory for State Management

```javascript
function createStore(initialState = {}) {
  let state = { ...initialState };
  const listeners = [];

  return {
    getState() {
      return { ...state }; // Return copy
    },

    setState(updates) {
      state = { ...state, ...updates };
      listeners.forEach(listener => listener(state));
    },

    subscribe(listener) {
      listeners.push(listener);

      // Return unsubscribe function
      return function unsubscribe() {
        const index = listeners.indexOf(listener);
        if (index !== -1) {
          listeners.splice(index, 1);
        }
      };
    },

    reset() {
      state = { ...initialState };
      listeners.forEach(listener => listener(state));
    }
  };
}

const store = createStore({ count: 0, user: null });

const unsubscribe = store.subscribe(state => {
  console.log('State updated:', state);
});

store.setState({ count: 1 });
// State updated: { count: 1, user: null }

store.setState({ user: { name: 'Alice' } });
// State updated: { count: 1, user: { name: 'Alice' } }

unsubscribe(); // Stop listening
store.setState({ count: 2 }); // No log
```

---

## Memoization with Closures

**Memoization** is an optimization technique that caches function results based on inputs. Closures are perfect for implementing memoization.

### Basic Memoization

```javascript
function memoize(fn) {
  const cache = {};

  return function(...args) {
    const key = JSON.stringify(args);

    if (key in cache) {
      console.log('Returning cached result');
      return cache[key];
    }

    console.log('Computing result');
    const result = fn(...args);
    cache[key] = result;
    return result;
  };
}

// Expensive function
function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

const memoizedFib = memoize(fibonacci);

console.log(memoizedFib(40)); // Computing result (takes time)
console.log(memoizedFib(40)); // Returning cached result (instant)
```

### Advanced Memoization

```javascript
function createMemoizer() {
  const cache = new Map();
  let hits = 0;
  let misses = 0;

  return {
    memoize(fn) {
      return function(...args) {
        const key = JSON.stringify(args);

        if (cache.has(key)) {
          hits++;
          return cache.get(key);
        }

        misses++;
        const result = fn(...args);
        cache.set(key, result);
        return result;
      };
    },

    getStats() {
      return {
        hits,
        misses,
        hitRate: hits / (hits + misses) || 0,
        cacheSize: cache.size
      };
    },

    clear() {
      cache.clear();
      hits = 0;
      misses = 0;
    }
  };
}

const memoizer = createMemoizer();

const expensiveOperation = memoizer.memoize((a, b) => {
  // Simulate expensive computation
  let result = 0;
  for (let i = 0; i < 1000000; i++) {
    result += a * b;
  }
  return result;
});

expensiveOperation(5, 10);
expensiveOperation(5, 10); // Cached
expensiveOperation(3, 7);

console.log(memoizer.getStats());
// { hits: 1, misses: 2, hitRate: 0.33, cacheSize: 2 }
```

### Memoization with LRU Cache

```javascript
function createLRUMemoizer(maxSize = 100) {
  const cache = new Map();

  function memoize(fn) {
    return function(...args) {
      const key = JSON.stringify(args);

      if (cache.has(key)) {
        // Move to end (most recently used)
        const value = cache.get(key);
        cache.delete(key);
        cache.set(key, value);
        return value;
      }

      const result = fn(...args);

      // Evict least recently used if at capacity
      if (cache.size >= maxSize) {
        const firstKey = cache.keys().next().value;
        cache.delete(firstKey);
      }

      cache.set(key, result);
      return result;
    };
  }

  return { memoize };
}

const lruMemoizer = createLRUMemoizer(3);
const fn = lruMemoizer.memoize((x) => x * 2);

fn(1); fn(2); fn(3); // Cache: [1, 2, 3]
fn(4);               // Cache: [2, 3, 4] (1 evicted)
fn(2);               // Cache: [3, 4, 2] (2 moved to end)
```

---

## Module Pattern

The **module pattern** uses closures and IIFEs to create private and public members, similar to modules in other languages.

### Classic Module Pattern

```javascript
const Calculator = (function() {
  // Private variables
  let result = 0;
  const history = [];

  // Private functions
  function log(operation, value) {
    history.push({ operation, value, result });
  }

  // Public API
  return {
    add(value) {
      result += value;
      log('add', value);
      return this;
    },

    subtract(value) {
      result -= value;
      log('subtract', value);
      return this;
    },

    multiply(value) {
      result *= value;
      log('multiply', value);
      return this;
    },

    divide(value) {
      if (value === 0) {
        throw new Error('Cannot divide by zero');
      }
      result /= value;
      log('divide', value);
      return this;
    },

    getResult() {
      return result;
    },

    reset() {
      result = 0;
      history.length = 0;
      return this;
    },

    getHistory() {
      return [...history];
    }
  };
})();

Calculator.add(10).multiply(2).subtract(5);
console.log(Calculator.getResult()); // 15
console.log(Calculator.getHistory());
```

### Revealing Module Pattern

```javascript
const UserManager = (function() {
  // Private
  const users = [];
  let nextId = 1;

  function findById(id) {
    return users.find(user => user.id === id);
  }

  function validateUser(user) {
    if (!user.name || !user.email) {
      throw new Error('Name and email are required');
    }
  }

  // Public methods
  function addUser(name, email) {
    const user = { id: nextId++, name, email };
    validateUser(user);
    users.push(user);
    return user;
  }

  function getUser(id) {
    return findById(id);
  }

  function getAllUsers() {
    return [...users]; // Return copy
  }

  function updateUser(id, updates) {
    const user = findById(id);
    if (!user) {
      throw new Error('User not found');
    }
    Object.assign(user, updates);
    validateUser(user);
    return user;
  }

  function deleteUser(id) {
    const index = users.findIndex(user => user.id === id);
    if (index !== -1) {
      return users.splice(index, 1)[0];
    }
    return null;
  }

  // Reveal public interface
  return {
    add: addUser,
    get: getUser,
    getAll: getAllUsers,
    update: updateUser,
    delete: deleteUser
  };
})();

UserManager.add('Alice', 'alice@example.com');
UserManager.add('Bob', 'bob@example.com');
console.log(UserManager.getAll());
```

### Module with Configuration

```javascript
const ApiClient = (function(config) {
  const baseURL = config.baseURL;
  const apiKey = config.apiKey;
  const timeout = config.timeout || 5000;

  async function request(endpoint, options = {}) {
    const url = `${baseURL}${endpoint}`;
    const headers = {
      'Authorization': `Bearer ${apiKey}`,
      'Content-Type': 'application/json',
      ...options.headers
    };

    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);

    try {
      const response = await fetch(url, {
        ...options,
        headers,
        signal: controller.signal
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      return await response.json();
    } catch (error) {
      clearTimeout(timeoutId);
      throw error;
    }
  }

  return {
    get(endpoint) {
      return request(endpoint, { method: 'GET' });
    },

    post(endpoint, data) {
      return request(endpoint, {
        method: 'POST',
        body: JSON.stringify(data)
      });
    },

    put(endpoint, data) {
      return request(endpoint, {
        method: 'PUT',
        body: JSON.stringify(data)
      });
    },

    delete(endpoint) {
      return request(endpoint, { method: 'DELETE' });
    }
  };
})({
  baseURL: 'https://api.example.com',
  apiKey: 'your-api-key-here',
  timeout: 10000
});

// Usage
// ApiClient.get('/users').then(users => console.log(users));
```

---

## Memory Implications

Closures keep references to their outer scope variables, which has important memory implications.

### Memory Retention

```javascript
function createHeavyClosure() {
  const largeArray = new Array(1000000).fill('data'); // ~8MB

  return function() {
    // This closure keeps largeArray in memory
    return largeArray.length;
  };
}

const fn = createHeavyClosure();
// largeArray is still in memory, even though createHeavyClosure finished
```

### Memory Leak Example

```javascript
// Memory leak: Accumulating event listeners
function setupBadListeners() {
  const data = new Array(100000).fill('heavy data');

  document.getElementById('button').addEventListener('click', function() {
    console.log(data.length); // Closure keeps data in memory
  });

  // If this function is called multiple times,
  // multiple closures are created, each holding data
}

// Fix: Remove event listener when done
function setupGoodListeners() {
  const data = new Array(100000).fill('heavy data');

  function handleClick() {
    console.log(data.length);
  }

  const button = document.getElementById('button');
  button.addEventListener('click', handleClick);

  // Return cleanup function
  return function cleanup() {
    button.removeEventListener('click', handleClick);
    // Now data can be garbage collected
  };
}

const cleanup = setupGoodListeners();
// Later...
cleanup();
```

### Avoiding Unnecessary Closures

```javascript
// Bad: Closure created for each item (memory intensive)
function createItemHandlers(items) {
  return items.map(item => {
    return function() {
      console.log(item); // Closure over item
    };
  });
}

// Better: Share one function, use event delegation or pass data
function createItemHandlers(items) {
  function handleItem(item) {
    return function() {
      console.log(item);
    };
  }

  return items.map(item => handleItem(item));
}

// Best: Use event delegation (for DOM events)
function setupItemHandlers(items) {
  const container = document.getElementById('container');

  container.addEventListener('click', function(event) {
    const itemId = event.target.dataset.itemId;
    const item = items.find(i => i.id === itemId);
    console.log(item);
  });
}
```

### Best Practices for Memory

```javascript
// 1. Nullify references when done
function createProcessor() {
  let heavyData = loadHeavyData();

  function process() {
    // Use heavyData
    return heavyData.process();
  }

  function cleanup() {
    heavyData = null; // Allow garbage collection
  }

  return { process, cleanup };
}

// 2. Use WeakMap for private data (auto garbage collected)
const privateData = new WeakMap();

function createObject() {
  const obj = {};

  privateData.set(obj, {
    secret: 'private data'
  });

  return {
    getSecret() {
      return privateData.get(obj).secret;
    }
  };
}

// When obj is no longer referenced, private data is auto-collected

// 3. Limit closure scope
function processData() {
  const result = expensiveOperation();

  // Don't close over large data unnecessarily
  return function() {
    return result.summary; // Only close over what's needed
  };
}
```

---

## Common Closure Pitfalls

### Pitfall 1: Loop Variable Capture

```javascript
// Problem: All functions share the same 'i'
function createFunctionsWrong() {
  const functions = [];

  for (var i = 0; i < 3; i++) {
    functions.push(function() {
      console.log(i);
    });
  }

  return functions;
}

const fns = createFunctionsWrong();
fns[0](); // 3 (expected 0)
fns[1](); // 3 (expected 1)
fns[2](); // 3 (expected 2)

// Solution 1: Use let (block scope)
function createFunctionsLet() {
  const functions = [];

  for (let i = 0; i < 3; i++) { // let creates new binding each iteration
    functions.push(function() {
      console.log(i);
    });
  }

  return functions;
}

// Solution 2: IIFE
function createFunctionsIIFE() {
  const functions = [];

  for (var i = 0; i < 3; i++) {
    functions.push((function(index) {
      return function() {
        console.log(index);
      };
    })(i));
  }

  return functions;
}

// Solution 3: forEach
function createFunctionsForEach() {
  const functions = [];

  [0, 1, 2].forEach(i => {
    functions.push(function() {
      console.log(i);
    });
  });

  return functions;
}
```

### Pitfall 2: Accidental Global Variables

```javascript
function createCounter() {
  count = 0; // Oops! Forgot 'let' - creates global variable

  return {
    increment() {
      count++;
      return count;
    }
  };
}

const counter1 = createCounter();
const counter2 = createCounter();

counter1.increment(); // 1
counter2.increment(); // 2 (shares same global count!)

// Fix: Always use let/const
function createCounterFixed() {
  let count = 0; // Local to this closure

  return {
    increment() {
      count++;
      return count;
    }
  };
}
```

### Pitfall 3: Closure in Callbacks

```javascript
// Problem: Async callback references changed variable
function processItemsWrong(items) {
  for (var i = 0; i < items.length; i++) {
    setTimeout(function() {
      console.log(items[i]); // 'i' is items.length when timeout fires
    }, 1000);
  }
}

processItemsWrong(['a', 'b', 'c']);
// Prints: undefined, undefined, undefined

// Solution 1: Use let
function processItemsLet(items) {
  for (let i = 0; i < items.length; i++) {
    setTimeout(function() {
      console.log(items[i]);
    }, 1000);
  }
}

// Solution 2: forEach
function processItemsForEach(items) {
  items.forEach((item, i) => {
    setTimeout(function() {
      console.log(items[i]);
    }, 1000);
  });
}

// Solution 3: Pass value to closure
function processItemsIIFE(items) {
  for (var i = 0; i < items.length; i++) {
    (function(index) {
      setTimeout(function() {
        console.log(items[index]);
      }, 1000);
    })(i);
  }
}
```

### Pitfall 4: This in Closures

```javascript
const obj = {
  name: 'MyObject',
  regularFunction: function() {
    setTimeout(function() {
      console.log(this.name); // undefined - 'this' is not obj
    }, 100);
  },

  arrowFunction: function() {
    setTimeout(() => {
      console.log(this.name); // 'MyObject' - arrow function captures 'this'
    }, 100);
  },

  bindFunction: function() {
    setTimeout(function() {
      console.log(this.name); // 'MyObject' - bound 'this'
    }.bind(this), 100);
  }
};

obj.regularFunction(); // undefined
obj.arrowFunction();   // 'MyObject'
obj.bindFunction();    // 'MyObject'
```

---

## Worked Examples

### Example 1: Rate Limiter (Intermediate)

**Problem:** Create a rate limiter that allows a function to be called at most N times per time period.

**Solution:**

```javascript
function createRateLimiter(maxCalls, timeWindow) {
  const calls = [];

  return function rateLimited(fn) {
    return function(...args) {
      const now = Date.now();

      // Remove calls outside time window
      while (calls.length > 0 && calls[0] < now - timeWindow) {
        calls.shift();
      }

      if (calls.length >= maxCalls) {
        const oldestCall = calls[0];
        const retryAfter = oldestCall + timeWindow - now;
        throw new Error(`Rate limit exceeded. Retry after ${retryAfter}ms`);
      }

      calls.push(now);
      return fn(...args);
    };
  };
}

// Create rate limiter: 3 calls per 1000ms
const limiter = createRateLimiter(3, 1000);

const apiCall = limiter(function(endpoint) {
  console.log(`Calling ${endpoint}`);
  return { status: 'success' };
});

// Test
apiCall('/users');  // OK
apiCall('/posts');  // OK
apiCall('/comments'); // OK
// apiCall('/likes'); // Error: Rate limit exceeded

// After 1 second, calls are allowed again
setTimeout(() => {
  apiCall('/likes'); // OK
}, 1100);
```

---

### Example 2: Event Emitter (Advanced)

**Problem:** Implement an event emitter with on, off, and emit methods using closures.

**Solution:**

```javascript
function createEventEmitter() {
  const events = {};

  return {
    on(eventName, callback) {
      if (!events[eventName]) {
        events[eventName] = [];
      }
      events[eventName].push(callback);

      // Return unsubscribe function
      return function off() {
        const callbacks = events[eventName];
        const index = callbacks.indexOf(callback);
        if (index !== -1) {
          callbacks.splice(index, 1);
        }
      };
    },

    off(eventName, callback) {
      if (!events[eventName]) return;

      if (callback) {
        const callbacks = events[eventName];
        const index = callbacks.indexOf(callback);
        if (index !== -1) {
          callbacks.splice(index, 1);
        }
      } else {
        delete events[eventName];
      }
    },

    emit(eventName, ...args) {
      if (!events[eventName]) return;

      events[eventName].forEach(callback => {
        try {
          callback(...args);
        } catch (error) {
          console.error(`Error in ${eventName} handler:`, error);
        }
      });
    },

    once(eventName, callback) {
      const wrappedCallback = (...args) => {
        callback(...args);
        this.off(eventName, wrappedCallback);
      };

      return this.on(eventName, wrappedCallback);
    },

    getListenerCount(eventName) {
      return events[eventName] ? events[eventName].length : 0;
    }
  };
}

// Usage
const emitter = createEventEmitter();

const unsubscribe = emitter.on('userLogin', (user) => {
  console.log(`${user.name} logged in`);
});

emitter.once('appStart', () => {
  console.log('App started');
});

emitter.emit('appStart');           // 'App started'
emitter.emit('appStart');           // Nothing (once)
emitter.emit('userLogin', { name: 'Alice' }); // 'Alice logged in'

unsubscribe();
emitter.emit('userLogin', { name: 'Bob' });   // Nothing (unsubscribed)
```

---

### Example 3: Lazy Evaluation (Advanced)

**Problem:** Create a lazy evaluation system that computes values only when needed and caches results.

**Solution:**

```javascript
function createLazy(computation) {
  let cached = false;
  let value;

  return {
    get value() {
      if (!cached) {
        console.log('Computing value...');
        value = computation();
        cached = true;
      }
      return value;
    },

    reset() {
      cached = false;
      value = undefined;
    },

    isCached() {
      return cached;
    }
  };
}

// Expensive computation
const expensiveValue = createLazy(() => {
  let sum = 0;
  for (let i = 0; i < 1000000; i++) {
    sum += i;
  }
  return sum;
});

console.log(expensiveValue.isCached()); // false
console.log(expensiveValue.value);       // Computing value... 499999500000
console.log(expensiveValue.isCached()); // true
console.log(expensiveValue.value);       // 499999500000 (no computation)

expensiveValue.reset();
console.log(expensiveValue.isCached()); // false

// Chain lazy computations
function lazyMap(lazy, transform) {
  return createLazy(() => transform(lazy.value));
}

const doubled = lazyMap(expensiveValue, x => x * 2);
const stringified = lazyMap(doubled, x => `Result: ${x}`);

console.log(stringified.value); // Computes all at once
```

---

## Exercises

### Exercise 1: Counter with Limits (Easy)

Create a `createBoundedCounter(min, max, initial)` function that returns a counter object with:
- `increment()`: Increases count (max limit)
- `decrement()`: Decreases count (min limit)
- `getCount()`: Returns current count
- `reset()`: Resets to initial value

**Example:**
```javascript
const counter = createBoundedCounter(0, 10, 5);
counter.increment(); // 6
counter.increment(); // 7
counter.decrement(); // 6
counter.getCount();  // 6
counter.reset();     // Back to 5
```

---

### Exercise 2: Function Logger (Medium)

Create a `createLogger(fn)` function that wraps another function and logs:
- When the function is called
- Arguments passed
- Return value
- Execution time

**Example:**
```javascript
const add = (a, b) => a + b;
const loggedAdd = createLogger(add);

loggedAdd(5, 3);
// Logs:
// Calling function with arguments: [5, 3]
// Returned: 8
// Execution time: 0.5ms
```

---

### Exercise 3: Debounce Function (Medium)

Implement a `debounce(fn, delay)` function that delays executing `fn` until after `delay` milliseconds have passed since the last call.

**Example:**
```javascript
const debouncedLog = debounce(() => console.log('Executed'), 1000);

debouncedLog(); // Scheduled
debouncedLog(); // Cancelled previous, rescheduled
debouncedLog(); // Cancelled previous, rescheduled
// After 1 second: 'Executed' (only once)
```

---

### Exercise 4: Private State Manager (Hard)

Create a state management system with:
- `createState(initialState)`: Creates state manager
- `getState()`: Returns current state (copy)
- `setState(updates)`: Updates state
- `subscribe(listener)`: Listens to changes
- `getHistory()`: Returns all state changes
- Previous states should not be modifiable

**Example:**
```javascript
const state = createState({ count: 0 });

state.subscribe((newState) => {
  console.log('State changed:', newState);
});

state.setState({ count: 1 }); // Triggers listener
state.setState({ count: 2 }); // Triggers listener
console.log(state.getHistory()); // Array of all states
```

---

### Exercise 5: Lazy Cache (Hard)

Implement a caching system that:
- Computes values lazily (only when accessed)
- Caches computed values
- Supports invalidation
- Has a maximum cache size (LRU eviction)

**Example:**
```javascript
const cache = createLazyCache(3); // Max 3 items

cache.set('a', () => expensiveComputation('a'));
cache.set('b', () => expensiveComputation('b'));

cache.get('a'); // Computes
cache.get('a'); // Returns cached
cache.invalidate('a');
cache.get('a'); // Computes again
```

---

## Testing & Debugging

### Testing Closures

```javascript
function testClosure() {
  const counter = createCounter();

  console.assert(counter.increment() === 1, 'First increment should be 1');
  console.assert(counter.increment() === 2, 'Second increment should be 2');
  console.assert(counter.getCount() === 2, 'Count should be 2');

  counter.reset();
  console.assert(counter.getCount() === 0, 'Reset should return to 0');

  console.log('✓ All closure tests passed');
}

testClosure();
```

### Debugging Scope Issues

```javascript
function debugScope() {
  const outer = 'outer value';

  function inner() {
    const inner = 'inner value';

    debugger; // Browser will pause here
    console.log({ outer, inner });
  }

  inner();
}

// In browser console, you can inspect:
// - Local scope (inner variable)
// - Closure scope (outer variable)
// - Global scope
```

### Memory Profiling

```javascript
// Check if closures are causing memory leaks
function checkMemory() {
  const before = performance.memory?.usedJSHeapSize;

  const functions = [];
  for (let i = 0; i < 1000; i++) {
    functions.push(createHeavyClosure());
  }

  const after = performance.memory?.usedJSHeapSize;

  console.log(`Memory increase: ${(after - before) / 1024 / 1024} MB`);
}
```

---

## Best Practices

### 1. Use Closures for Encapsulation

```javascript
// Good: Private state
function createAccount() {
  let balance = 0;

  return {
    deposit: (amount) => balance += amount,
    getBalance: () => balance
  };
}
```

### 2. Be Mindful of Memory

```javascript
// Bad: Unnecessary closure over large data
function processData(largeArray) {
  return function() {
    return largeArray.length; // Keeps entire array in memory
  };
}

// Good: Extract only what's needed
function processData(largeArray) {
  const length = largeArray.length;
  return function() {
    return length; // Only keeps length in memory
  };
}
```

### 3. Use let/const in Loops

```javascript
// Always use let for loop variables
for (let i = 0; i < array.length; i++) {
  // Each iteration has its own 'i'
}
```

### 4. Clean Up Event Listeners

```javascript
function setupListener() {
  const handler = () => { /* ... */ };
  element.addEventListener('click', handler);

  // Return cleanup function
  return () => element.removeEventListener('click', handler);
}

const cleanup = setupListener();
// Later: cleanup();
```

### 5. Document Closure Behavior

```javascript
/**
 * Creates a counter with private state
 * @returns {Object} Counter interface
 * @property {Function} increment - Increases count
 * @property {Function} getCount - Returns current count
 * @closure Maintains private 'count' variable
 */
function createCounter() {
  let count = 0;
  return {
    increment: () => ++count,
    getCount: () => count
  };
}
```

---

## Summary & Next Steps

### Key Takeaways

- **Scope** determines variable accessibility: global, function, and block scope
- **Lexical scoping** means functions remember their definition environment
- **Scope chain** resolves variables from inner to outer scopes
- **Closures** enable functions to access outer scope variables after outer function returns
- **Module pattern** uses closures and IIFEs for encapsulation
- **Factory functions** combined with closures provide elegant object creation
- **Memoization** with closures optimizes expensive computations
- **Memory management** is important when using closures extensively
- Common pitfalls include loop variable capture and accidental globals

### Related Topics

- [Functions](./05.Functions.md) - Comprehensive function guide
- [Let and Const](../08.let_and_const/01.let_and_const.md) - Block scope and temporal dead zone
- [Async Programming](../async/) - Closures in asynchronous code
- [Design Patterns](../patterns/) - Advanced patterns using closures

### Practice Recommendations

1. Complete all exercises in this lesson
2. Refactor existing code to use closures for data privacy
3. Implement a mini state management library
4. Build a module using the module pattern
5. Profile and optimize closure-heavy code

### Further Reading

- [MDN: Closures](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures)
- [MDN: Scope](https://developer.mozilla.org/en-US/docs/Glossary/Scope)
- [JavaScript.info: Variable Scope](https://javascript.info/closure)
- [You Don't Know JS: Scope & Closures](https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/README.md)

---

**Next Lesson:** Continue to advanced topics like async/await, promises, and event-driven programming where closures play a crucial role.
