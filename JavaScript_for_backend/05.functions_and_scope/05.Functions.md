# Functions in JavaScript

**Difficulty:** Intermediate
**Estimated Time:** 45-60 minutes
**Prerequisites:** Basic JavaScript knowledge, variables, data types, control structures
**Target:** Node.js 18+ LTS, Modern Browsers (ES2021+)

---

## Learning Objectives

By the end of this lesson, you will be able to:

1. Understand and apply different function declaration styles (declarations, expressions, arrow functions)
2. Master parameter handling including default and rest parameters
3. Implement higher-order functions and callbacks effectively
4. Understand function hoisting and scope behavior
5. Write pure functions and avoid unintended side effects
6. Use IIFE for encapsulation and module patterns
7. Apply function best practices in production code
8. Debug common function-related issues

---

## Table of Contents

1. [Introduction](#introduction)
2. [Function Declarations](#function-declarations)
3. [Function Expressions](#function-expressions)
4. [Arrow Functions](#arrow-functions)
5. [Parameters and Arguments](#parameters-and-arguments)
6. [Return Values](#return-values)
7. [Default Parameters](#default-parameters)
8. [Rest Parameters](#rest-parameters)
9. [Function Hoisting](#function-hoisting)
10. [IIFE (Immediately Invoked Function Expressions)](#iife-immediately-invoked-function-expressions)
11. [Callback Functions](#callback-functions)
12. [Higher-Order Functions](#higher-order-functions)
13. [Closures - Basic Introduction](#closures-basic-introduction)
14. [Pure Functions vs Side Effects](#pure-functions-vs-side-effects)
15. [Worked Examples](#worked-examples)
16. [Exercises](#exercises)
17. [Testing & Debugging](#testing--debugging)
18. [Best Practices](#best-practices)
19. [Common Pitfalls](#common-pitfalls)
20. [Summary & Next Steps](#summary--next-steps)

---

## Introduction

Functions are the fundamental building blocks of JavaScript programs. They encapsulate reusable logic, enable abstraction, and form the basis of modular code design. In JavaScript, functions are **first-class citizens**, meaning they can be:

- Assigned to variables
- Passed as arguments to other functions
- Returned from other functions
- Stored in data structures

Understanding functions deeply is essential for writing clean, maintainable, and efficient JavaScript code.

**Why Functions Matter:**

- **Reusability:** Write once, use many times
- **Abstraction:** Hide complex implementation details
- **Organization:** Structure code into logical units
- **Maintainability:** Easier to debug and update
- **Testing:** Isolate and verify specific behaviors

---

## Function Declarations

A **function declaration** defines a named function using the `function` keyword.

### Syntax

```javascript
function functionName(parameter1, parameter2, ...parameterN) {
  // function body
  return value;
}
```

### Example

```javascript
function calculateArea(length, width) {
  return length * width;
}

const area = calculateArea(10, 5);
console.log(area); // 50
```

### Characteristics

- **Named:** The function has an identifier
- **Hoisted:** Can be called before declaration (see [Function Hoisting](#function-hoisting))
- **Function scope:** Creates its own scope
- **Can be used as constructor:** With `new` keyword (though classes are preferred)

### When to Use

- When you need hoisting behavior
- For top-level, named functions in modules
- When defining methods that might be called before declaration

---

## Function Expressions

A **function expression** defines a function as part of an expression, typically by assigning it to a variable.

### Syntax

```javascript
const functionName = function(parameter1, parameter2) {
  return value;
};
```

### Example

```javascript
const calculatePercentage = function(marks, total) {
  return (marks / total) * 100;
};

console.log(calculatePercentage(85, 100)); // 85
```

### Anonymous vs Named Function Expressions

```javascript
// Anonymous function expression
const greet = function(name) {
  return `Hello, ${name}`;
};

// Named function expression (useful for recursion and debugging)
const factorial = function fact(n) {
  if (n <= 1) return 1;
  return n * fact(n - 1); // Can call itself using 'fact'
};
```

### Characteristics

- **Not hoisted:** Must be defined before use
- **Can be anonymous:** Function doesn't need a name
- **First-class value:** Can be passed around like any other value
- **Better for callbacks:** Common in event handlers and array methods

### Key Differences from Declarations

| Feature | Declaration | Expression |
|---------|------------|------------|
| Hoisting | ✅ Yes | ❌ No |
| Naming | Required | Optional |
| Statement vs Expression | Statement | Expression |
| Common Use | Top-level functions | Callbacks, conditionally created functions |

---

## Arrow Functions

**Arrow functions** (introduced in ES6) provide a concise syntax for writing functions. They are especially powerful for callbacks and have lexical `this` binding.

### Syntax Variations

```javascript
// No parameters
const greet = () => "Hello, World!";

// Single parameter (parentheses optional)
const square = x => x * x;

// Multiple parameters
const add = (a, b) => a + b;

// Block body (explicit return needed)
const multiply = (a, b) => {
  const result = a * b;
  return result;
};

// Returning object literal (wrap in parentheses)
const createUser = (name, age) => ({ name, age });
```

### Example

```javascript
const numbers = [1, 2, 3, 4, 5];

// Traditional function
const doubled1 = numbers.map(function(n) {
  return n * 2;
});

// Arrow function (concise)
const doubled2 = numbers.map(n => n * 2);

console.log(doubled2); // [2, 4, 6, 8, 10]
```

### Key Characteristics

- **Concise syntax:** Shorter than traditional functions
- **Implicit return:** Single expressions return automatically
- **Lexical `this`:** Inherits `this` from surrounding scope
- **No `arguments` object:** Use rest parameters instead
- **Cannot be constructors:** Cannot use with `new`
- **No `prototype` property**

**Note:** Arrow functions are covered in detail in a separate lesson. See [09.arrow_functions.md](../09.arrow_functions/01.arrow_functions.md)

---

## Parameters and Arguments

**Parameters** are variables listed in the function definition. **Arguments** are the actual values passed when calling the function.

### Basic Example

```javascript
// 'a' and 'b' are parameters
function add(a, b) {
  return a + b;
}

// 5 and 3 are arguments
const result = add(5, 3); // 8
```

### Multiple Parameters

```javascript
function createStudent(name, age, course, semester) {
  return {
    name,
    age,
    course,
    semester,
    enrolled: true
  };
}

const student = createStudent('Alice', 20, 'Computer Science', 3);
console.log(student);
// { name: 'Alice', age: 20, course: 'Computer Science', semester: 3, enrolled: true }
```

### Arguments Object (Traditional Functions Only)

```javascript
function sumAll() {
  let total = 0;
  for (let i = 0; i < arguments.length; i++) {
    total += arguments[i];
  }
  return total;
}

console.log(sumAll(1, 2, 3, 4, 5)); // 15
```

**Note:** The `arguments` object is array-like but not a true array. Modern code should use rest parameters instead.

---

## Return Values

The `return` statement specifies the value a function sends back to its caller.

### Basic Return

```javascript
function multiply(a, b) {
  return a * b;
}

const product = multiply(6, 7);
console.log(product); // 42
```

### Multiple Return Paths

```javascript
function getGrade(score) {
  if (score >= 90) return 'A';
  if (score >= 80) return 'B';
  if (score >= 70) return 'C';
  if (score >= 60) return 'D';
  return 'F';
}

console.log(getGrade(85)); // 'B'
```

### Returning Objects

```javascript
function getUserInfo(id) {
  return {
    id,
    name: 'John Doe',
    email: 'john@example.com',
    active: true
  };
}

const user = getUserInfo(123);
console.log(user.name); // 'John Doe'
```

### Returning Functions

```javascript
function createMultiplier(factor) {
  return function(number) {
    return number * factor;
  };
}

const double = createMultiplier(2);
const triple = createMultiplier(3);

console.log(double(5)); // 10
console.log(triple(5)); // 15
```

### Default Return Value

If no `return` statement is executed, or `return` is used without a value, the function returns `undefined`.

```javascript
function doNothing() {
  // no return statement
}

function returnNothing() {
  return;
}

console.log(doNothing());      // undefined
console.log(returnNothing());  // undefined
```

---

## Default Parameters

Default parameters allow you to specify default values for parameters when no argument is provided.

### Syntax (ES6+)

```javascript
function greet(name = 'Guest', greeting = 'Hello') {
  return `${greeting}, ${name}!`;
}

console.log(greet());                    // 'Hello, Guest!'
console.log(greet('Alice'));             // 'Hello, Alice!'
console.log(greet('Bob', 'Hi'));         // 'Hi, Bob!'
```

### Complex Default Values

```javascript
function createPost(title, author = 'Anonymous', timestamp = Date.now()) {
  return {
    title,
    author,
    timestamp,
    published: true
  };
}

console.log(createPost('My First Post'));
// { title: 'My First Post', author: 'Anonymous', timestamp: 1700000000000, published: true }
```

### Using Previous Parameters in Defaults

```javascript
function calculatePrice(price, taxRate = 0.1, total = price + (price * taxRate)) {
  return total;
}

console.log(calculatePrice(100));        // 110
console.log(calculatePrice(100, 0.15));  // 115
```

### Pre-ES6 Pattern (Legacy Code)

```javascript
// Old way (still seen in legacy code)
function oldGreet(name) {
  name = name || 'Guest'; // Fallback to 'Guest' if name is falsy
  return 'Hello, ' + name;
}
```

**Warning:** The old pattern treats `0`, `''`, `false`, `null` as falsy, which may not be desired. Default parameters only activate for `undefined`.

---

## Rest Parameters

Rest parameters allow a function to accept an indefinite number of arguments as an array.

### Syntax

```javascript
function functionName(...restParam) {
  // restParam is an array
}
```

### Example

```javascript
function sum(...numbers) {
  return numbers.reduce((total, num) => total + num, 0);
}

console.log(sum(1, 2, 3));           // 6
console.log(sum(1, 2, 3, 4, 5));     // 15
console.log(sum());                  // 0
```

### Combining Regular and Rest Parameters

```javascript
function createTeam(teamName, coach, ...players) {
  return {
    name: teamName,
    coach,
    players,
    size: players.length
  };
}

const team = createTeam('Eagles', 'John Smith', 'Alice', 'Bob', 'Charlie', 'Diana');
console.log(team);
// {
//   name: 'Eagles',
//   coach: 'John Smith',
//   players: ['Alice', 'Bob', 'Charlie', 'Diana'],
//   size: 4
// }
```

### Rest vs Arguments

```javascript
// Using arguments (old way, not recommended)
function oldSum() {
  return Array.from(arguments).reduce((a, b) => a + b, 0);
}

// Using rest parameters (modern, recommended)
function modernSum(...numbers) {
  return numbers.reduce((a, b) => a + b, 0);
}
```

**Advantages of Rest Parameters:**
- True array (not array-like object)
- Works with arrow functions
- More readable and explicit
- Can be combined with named parameters

---

## Function Hoisting

**Hoisting** is JavaScript's behavior of moving declarations to the top of their scope during compilation.

### Function Declaration Hoisting

Function declarations are **fully hoisted**, meaning both the name and implementation are available before the declaration line.

```javascript
// This works!
console.log(add(5, 3)); // 8

function add(a, b) {
  return a + b;
}
```

**What JavaScript does internally:**

```javascript
// During compilation phase
function add(a, b) {
  return a + b;
}

// During execution phase
console.log(add(5, 3)); // 8
```

### Function Expression Hoisting

Function expressions are **not hoisted** as functions. Only the variable declaration is hoisted.

```javascript
// This throws an error!
console.log(multiply(5, 3)); // TypeError: multiply is not a function

const multiply = function(a, b) {
  return a * b;
};
```

**What JavaScript sees:**

```javascript
// During compilation
let multiply; // Variable is hoisted but not initialized

// During execution
console.log(multiply(5, 3)); // multiply is undefined at this point
multiply = function(a, b) {
  return a * b;
};
```

### Arrow Function Hoisting

Arrow functions behave like function expressions - not hoisted.

```javascript
// This throws an error!
console.log(square(5)); // ReferenceError or TypeError

const square = x => x * x;
```

### Best Practice

While function declaration hoisting allows calling functions before they're defined, it's better to:

1. Define functions before using them
2. Use function expressions/arrow functions for most cases
3. Reserve function declarations for module-level functions
4. Be explicit about execution order

---

## IIFE (Immediately Invoked Function Expressions)

An **IIFE** is a function that runs immediately after it's defined. It's used for encapsulation and avoiding global scope pollution.

### Syntax

```javascript
(function() {
  // code here
})();

// Or with arrow function
(() => {
  // code here
})();
```

### Basic Example

```javascript
(function() {
  const message = 'This is private';
  console.log(message);
})();

// console.log(message); // ReferenceError: message is not defined
```

### IIFE with Parameters

```javascript
(function(name, age) {
  console.log(`${name} is ${age} years old`);
})('Alice', 25);
// Alice is 25 years old
```

### IIFE Returning Values

```javascript
const result = (function() {
  const privateCounter = 0;
  return {
    increment() {
      return privateCounter + 1;
    },
    decrement() {
      return privateCounter - 1;
    }
  };
})();

console.log(result.increment()); // 1
```

### Module Pattern with IIFE

```javascript
const Calculator = (function() {
  // Private variables and functions
  let history = [];

  function log(operation) {
    history.push(operation);
  }

  // Public API
  return {
    add(a, b) {
      const result = a + b;
      log(`${a} + ${b} = ${result}`);
      return result;
    },

    multiply(a, b) {
      const result = a * b;
      log(`${a} * ${b} = ${result}`);
      return result;
    },

    getHistory() {
      return [...history]; // Return copy
    }
  };
})();

Calculator.add(5, 3);
Calculator.multiply(4, 2);
console.log(Calculator.getHistory());
// ['5 + 3 = 8', '4 * 2 = 8']
```

### Use Cases

- Creating private variables and functions
- Avoiding global namespace pollution
- Module pattern (pre-ES6 modules)
- One-time initialization code
- Protecting code from external interference

**Note:** With ES6 modules, IIFEs are less common but still useful for specific encapsulation needs.

---

## Callback Functions

A **callback function** is a function passed as an argument to another function, to be executed later.

### Basic Callback

```javascript
function processUserInput(callback) {
  const name = 'Alice';
  callback(name);
}

function greetUser(name) {
  console.log(`Hello, ${name}!`);
}

processUserInput(greetUser); // Hello, Alice!
```

### Inline Callback

```javascript
processUserInput(function(name) {
  console.log(`Welcome, ${name}!`);
});

// Or with arrow function
processUserInput(name => console.log(`Hi, ${name}!`));
```

### Array Methods with Callbacks

```javascript
const numbers = [1, 2, 3, 4, 5];

// map
const doubled = numbers.map(function(num) {
  return num * 2;
});

// filter
const evens = numbers.filter(function(num) {
  return num % 2 === 0;
});

// forEach
numbers.forEach(function(num, index) {
  console.log(`Index ${index}: ${num}`);
});

// Modern style with arrow functions
const tripled = numbers.map(num => num * 3);
const odds = numbers.filter(num => num % 2 !== 0);
```

### Asynchronous Callbacks

```javascript
function fetchData(callback) {
  setTimeout(() => {
    const data = { id: 1, name: 'Sample Data' };
    callback(data);
  }, 1000);
}

fetchData(data => {
  console.log('Data received:', data);
});
```

### Error-First Callbacks (Node.js Convention)

```javascript
function readFile(filename, callback) {
  // Simulate file reading
  setTimeout(() => {
    if (filename === 'error.txt') {
      callback(new Error('File not found'), null);
    } else {
      callback(null, 'File contents here');
    }
  }, 500);
}

readFile('data.txt', (error, data) => {
  if (error) {
    console.error('Error:', error.message);
    return;
  }
  console.log('Data:', data);
});
```

---

## Higher-Order Functions

A **higher-order function** is a function that:
- Takes one or more functions as arguments, OR
- Returns a function as its result

### Function as Argument

```javascript
function repeat(n, action) {
  for (let i = 0; i < n; i++) {
    action(i);
  }
}

repeat(3, console.log);
// 0
// 1
// 2

repeat(5, i => console.log(`Iteration ${i}`));
```

### Function as Return Value

```javascript
function createMultiplier(multiplier) {
  return function(number) {
    return number * multiplier;
  };
}

const double = createMultiplier(2);
const triple = createMultiplier(3);

console.log(double(5));  // 10
console.log(triple(5));  // 15
```

### Practical Example: Function Composition

```javascript
function compose(f, g) {
  return function(x) {
    return f(g(x));
  };
}

const addOne = x => x + 1;
const multiplyByTwo = x => x * 2;

const addOneThenDouble = compose(multiplyByTwo, addOne);
console.log(addOneThenDouble(5)); // 12 (5 + 1 = 6, then 6 * 2 = 12)
```

### Built-in Higher-Order Functions

JavaScript arrays have many built-in higher-order functions:

```javascript
const numbers = [1, 2, 3, 4, 5];

// map: transforms each element
const squared = numbers.map(n => n * n);
// [1, 4, 9, 16, 25]

// filter: selects elements based on condition
const evens = numbers.filter(n => n % 2 === 0);
// [2, 4]

// reduce: accumulates values
const sum = numbers.reduce((acc, n) => acc + n, 0);
// 15

// find: returns first matching element
const firstEven = numbers.find(n => n % 2 === 0);
// 2

// some: tests if any element matches
const hasEven = numbers.some(n => n % 2 === 0);
// true

// every: tests if all elements match
const allPositive = numbers.every(n => n > 0);
// true
```

---

## Closures - Basic Introduction

A **closure** is a function that has access to variables from its outer (enclosing) scope, even after the outer function has returned.

### Simple Closure

```javascript
function outerFunction() {
  const outerVariable = 'I am from outer scope';

  function innerFunction() {
    console.log(outerVariable); // Can access outerVariable
  }

  return innerFunction;
}

const myFunction = outerFunction();
myFunction(); // 'I am from outer scope'
```

### Practical Example: Counter

```javascript
function createCounter() {
  let count = 0; // Private variable

  return {
    increment() {
      count++;
      return count;
    },
    decrement() {
      count--;
      return count;
    },
    getCount() {
      return count;
    }
  };
}

const counter = createCounter();
console.log(counter.increment()); // 1
console.log(counter.increment()); // 2
console.log(counter.decrement()); // 1
console.log(counter.getCount());  // 1
// console.log(counter.count);    // undefined - count is private
```

### Data Privacy with Closures

```javascript
function createBankAccount(initialBalance) {
  let balance = initialBalance; // Private

  return {
    deposit(amount) {
      if (amount > 0) {
        balance += amount;
        return balance;
      }
      throw new Error('Deposit amount must be positive');
    },

    withdraw(amount) {
      if (amount > balance) {
        throw new Error('Insufficient funds');
      }
      balance -= amount;
      return balance;
    },

    getBalance() {
      return balance;
    }
  };
}

const myAccount = createBankAccount(1000);
console.log(myAccount.getBalance()); // 1000
myAccount.deposit(500);
console.log(myAccount.getBalance()); // 1500
// myAccount.balance = 1000000; // Won't work - balance is private
```

**Note:** Closures are covered in depth in [06.Scope_And_Closures.md](./06.Scope_And_Closures.md)

---

## Pure Functions vs Side Effects

### Pure Functions

A **pure function** is a function that:
1. Always returns the same output for the same input
2. Has no side effects (doesn't modify external state)

```javascript
// Pure function
function add(a, b) {
  return a + b;
}

// Pure function
function multiply(a, b) {
  return a * b;
}

// Pure function
function calculateArea(length, width) {
  return length * width;
}
```

**Benefits of Pure Functions:**
- Predictable and easy to test
- Can be cached (memoized)
- Easier to reason about
- Safe for parallel execution
- No unexpected behavior

### Impure Functions (With Side Effects)

A function with **side effects** modifies state outside its scope or has observable interactions beyond returning a value.

```javascript
let total = 0;

// Impure: modifies external variable
function addToTotal(value) {
  total += value;
  return total;
}

// Impure: depends on external state
function getTotal() {
  return total;
}

// Impure: modifies input parameter
function addProperty(obj) {
  obj.newProp = 'value';
  return obj;
}

// Impure: I/O operation
function logMessage(message) {
  console.log(message); // Side effect
}

// Impure: depends on external state (time)
function getCurrentTime() {
  return new Date();
}

// Impure: random output
function getRandomNumber() {
  return Math.random();
}
```

### Converting Impure to Pure

```javascript
// Impure
let count = 0;
function incrementCount() {
  count++;
  return count;
}

// Pure alternative
function increment(value) {
  return value + 1;
}

// Usage
let count = 0;
count = increment(count);
```

### When Side Effects Are Necessary

Some operations inherently require side effects:
- I/O operations (reading files, network requests)
- DOM manipulation
- Logging
- Database operations

**Best Practice:** Isolate side effects and keep most of your code pure.

```javascript
// Pure business logic
function calculateDiscount(price, discountPercent) {
  return price - (price * discountPercent / 100);
}

// Impure I/O layer
function applyDiscountAndSave(product, discount) {
  const newPrice = calculateDiscount(product.price, discount); // Pure
  product.price = newPrice; // Side effect
  saveToDatabase(product);  // Side effect
  return product;
}
```

---

## Worked Examples

### Example 1: Student Grade Calculator (Simple)

**Problem:** Create a function that calculates a student's final grade based on assignments, midterm, and final exam scores.

**Solution:**

```javascript
/**
 * Calculates final grade with weighted scoring
 * @param {number} assignments - Assignments average (0-100)
 * @param {number} midterm - Midterm exam score (0-100)
 * @param {number} finalExam - Final exam score (0-100)
 * @returns {number} Weighted final grade
 */
function calculateFinalGrade(assignments, midterm, finalExam) {
  const WEIGHTS = {
    assignments: 0.40,  // 40%
    midterm: 0.30,      // 30%
    finalExam: 0.30     // 30%
  };

  const finalGrade =
    (assignments * WEIGHTS.assignments) +
    (midterm * WEIGHTS.midterm) +
    (finalExam * WEIGHTS.finalExam);

  return Math.round(finalGrade * 100) / 100; // Round to 2 decimals
}

// Test the function
console.log(calculateFinalGrade(85, 90, 88)); // 87.5
console.log(calculateFinalGrade(95, 85, 90)); // 90.5

// Get letter grade
function getLetterGrade(numericGrade) {
  if (numericGrade >= 90) return 'A';
  if (numericGrade >= 80) return 'B';
  if (numericGrade >= 70) return 'C';
  if (numericGrade >= 60) return 'D';
  return 'F';
}

const studentGrade = calculateFinalGrade(85, 90, 88);
const letterGrade = getLetterGrade(studentGrade);
console.log(`Final Grade: ${studentGrade} (${letterGrade})`);
// Final Grade: 87.5 (B)
```

---

### Example 2: Array Processing Pipeline (Intermediate)

**Problem:** Process an array of student records to find top performers, apply a bonus, and generate a report.

**Solution:**

```javascript
const students = [
  { name: 'Alice', score: 85, attendance: 95 },
  { name: 'Bob', score: 92, attendance: 88 },
  { name: 'Charlie', score: 78, attendance: 92 },
  { name: 'Diana', score: 95, attendance: 100 },
  { name: 'Eve', score: 88, attendance: 85 }
];

/**
 * Process students and generate performance report
 */
function generatePerformanceReport(students) {
  // 1. Filter top performers (score >= 85)
  const topPerformers = students.filter(student => student.score >= 85);

  // 2. Apply attendance bonus (max 5 points)
  const withBonus = topPerformers.map(student => ({
    ...student,
    originalScore: student.score,
    bonusPoints: Math.floor(student.attendance / 20), // 5 points max
    finalScore: Math.min(100, student.score + Math.floor(student.attendance / 20))
  }));

  // 3. Sort by final score (descending)
  const sorted = withBonus.sort((a, b) => b.finalScore - a.finalScore);

  // 4. Create report
  return sorted.map((student, index) => ({
    rank: index + 1,
    name: student.name,
    originalScore: student.originalScore,
    bonusPoints: student.bonusPoints,
    finalScore: student.finalScore,
    award: index === 0 ? 'Gold' : index === 1 ? 'Silver' : index === 2 ? 'Bronze' : 'Merit'
  }));
}

const report = generatePerformanceReport(students);
console.log(report);

/*
Output:
[
  { rank: 1, name: 'Diana', originalScore: 95, bonusPoints: 5, finalScore: 100, award: 'Gold' },
  { rank: 2, name: 'Bob', originalScore: 92, bonusPoints: 4, finalScore: 96, award: 'Silver' },
  { rank: 3, name: 'Eve', originalScore: 88, bonusPoints: 4, finalScore: 92, award: 'Bronze' },
  { rank: 4, name: 'Alice', originalScore: 85, bonusPoints: 4, finalScore: 89, award: 'Merit' }
]
*/
```

---

### Example 3: Function Factory with Closures (Advanced)

**Problem:** Create a configurable validator factory that generates custom validation functions.

**Solution:**

```javascript
/**
 * Creates a validator function based on rules
 * @param {Object} rules - Validation rules
 * @returns {Function} Validator function
 */
function createValidator(rules) {
  return function(value) {
    const errors = [];

    if (rules.required && !value) {
      errors.push('This field is required');
    }

    if (rules.minLength && value.length < rules.minLength) {
      errors.push(`Minimum length is ${rules.minLength}`);
    }

    if (rules.maxLength && value.length > rules.maxLength) {
      errors.push(`Maximum length is ${rules.maxLength}`);
    }

    if (rules.pattern && !rules.pattern.test(value)) {
      errors.push(`Value must match pattern: ${rules.pattern}`);
    }

    if (rules.custom && !rules.custom(value)) {
      errors.push(rules.customMessage || 'Custom validation failed');
    }

    return {
      isValid: errors.length === 0,
      errors
    };
  };
}

// Create specific validators
const usernameValidator = createValidator({
  required: true,
  minLength: 3,
  maxLength: 20,
  pattern: /^[a-zA-Z0-9_]+$/,
  custom: value => !value.startsWith('_'),
  customMessage: 'Username cannot start with underscore'
});

const emailValidator = createValidator({
  required: true,
  pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/
});

const passwordValidator = createValidator({
  required: true,
  minLength: 8,
  custom: value => /[A-Z]/.test(value) && /[0-9]/.test(value),
  customMessage: 'Password must contain at least one uppercase letter and one number'
});

// Test validators
console.log(usernameValidator('alice_123'));
// { isValid: true, errors: [] }

console.log(usernameValidator('_invalid'));
// { isValid: false, errors: ['Username cannot start with underscore'] }

console.log(passwordValidator('weak'));
// { isValid: false, errors: ['Minimum length is 8'] }

console.log(passwordValidator('StrongPass123'));
// { isValid: true, errors: [] }
```

---

## Exercises

### Exercise 1: Temperature Converter (Easy)

Create a function `convertTemperature(value, fromUnit, toUnit)` that converts temperatures between Celsius, Fahrenheit, and Kelvin.

**Requirements:**
- Support 'C', 'F', 'K' as unit parameters
- Return the converted value rounded to 2 decimal places
- Handle invalid units by returning null

**Formulas:**
- C to F: (C × 9/5) + 32
- F to C: (F - 32) × 5/9
- C to K: C + 273.15
- K to C: K - 273.15

**Example:**
```javascript
convertTemperature(0, 'C', 'F');    // 32
convertTemperature(100, 'C', 'K');  // 373.15
convertTemperature(32, 'F', 'C');   // 0
```

---

### Exercise 2: Array Statistics (Medium)

Create a function `calculateStats(numbers)` that takes an array of numbers and returns an object containing:
- `min`: minimum value
- `max`: maximum value
- `mean`: average value
- `median`: middle value (or average of two middle values)
- `mode`: most frequent value (or null if all values appear once)

**Example:**
```javascript
calculateStats([1, 2, 2, 3, 4, 4, 4, 5]);
// {
//   min: 1,
//   max: 5,
//   mean: 3.125,
//   median: 3.5,
//   mode: 4
// }
```

---

### Exercise 3: Curry Function (Medium)

Implement a `curry` function that transforms a function with multiple arguments into a sequence of functions, each taking a single argument.

**Example:**
```javascript
function add(a, b, c) {
  return a + b + c;
}

const curriedAdd = curry(add);
console.log(curriedAdd(1)(2)(3));    // 6
console.log(curriedAdd(1, 2)(3));    // 6
console.log(curriedAdd(1)(2, 3));    // 6
```

---

### Exercise 4: Memoization (Hard)

Create a `memoize` function that caches the results of expensive function calls.

**Requirements:**
- Cache results based on function arguments
- Support functions with multiple arguments
- Return cached result if same arguments are provided again

**Example:**
```javascript
function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

const memoizedFib = memoize(fibonacci);
console.log(memoizedFib(40)); // Fast, even for large numbers
```

---

### Exercise 5: Function Composition (Hard)

Implement a `pipe` function that performs left-to-right function composition, and a `compose` function that performs right-to-left composition.

**Example:**
```javascript
const addOne = x => x + 1;
const double = x => x * 2;
const square = x => x * x;

const pipeline = pipe(addOne, double, square);
console.log(pipeline(2)); // ((2 + 1) * 2)^2 = 36

const composition = compose(square, double, addOne);
console.log(composition(2)); // ((2 + 1) * 2)^2 = 36
```

---

### Exercise 6: Throttle Function (Advanced)

Create a `throttle` function that limits how often a function can be called.

**Requirements:**
- Accept a function and a time limit (in milliseconds)
- Return a throttled version of the function
- Ensure the function is called at most once per time limit

**Example:**
```javascript
const logMessage = () => console.log('Scrolling...');
const throttledLog = throttle(logMessage, 1000);

// Call throttledLog many times rapidly
// It will only execute once per second
```

---

## Testing & Debugging

### Writing Testable Functions

```javascript
// Good: Pure, testable function
function calculateTax(amount, rate) {
  return amount * rate;
}

// Test
function testCalculateTax() {
  const result = calculateTax(100, 0.1);
  console.assert(result === 10, 'Tax calculation failed');
  console.log('✓ Tax calculation test passed');
}

testCalculateTax();
```

### Using Console for Debugging

```javascript
function complexCalculation(a, b, c) {
  console.log('Inputs:', { a, b, c });

  const step1 = a + b;
  console.log('Step 1 (a + b):', step1);

  const step2 = step1 * c;
  console.log('Step 2 (step1 * c):', step2);

  return step2;
}
```

### Debugging Closures

```javascript
function createCounter() {
  let count = 0;

  return {
    increment() {
      count++;
      console.log('Count after increment:', count);
      return count;
    },
    debug() {
      console.log('Current count:', count);
    }
  };
}

const counter = createCounter();
counter.increment();
counter.debug(); // View internal state
```

### Common Debugging Techniques

```javascript
// 1. Type checking
function safeDivide(a, b) {
  console.log(typeof a, typeof b);
  if (typeof a !== 'number' || typeof b !== 'number') {
    throw new TypeError('Arguments must be numbers');
  }
  if (b === 0) {
    throw new Error('Cannot divide by zero');
  }
  return a / b;
}

// 2. Stack trace
function trace() {
  console.trace('Function call trace');
}

// 3. Performance timing
function measurePerformance(fn, ...args) {
  const start = performance.now();
  const result = fn(...args);
  const end = performance.now();
  console.log(`Execution time: ${end - start}ms`);
  return result;
}
```

---

## Best Practices

### 1. Use Descriptive Names

```javascript
// Bad
function calc(a, b) {
  return a * b * 0.15;
}

// Good
function calculateSalesTax(price, quantity) {
  const TAX_RATE = 0.15;
  return price * quantity * TAX_RATE;
}
```

### 2. Keep Functions Small and Focused

```javascript
// Bad: Function does too many things
function processUser(user) {
  validateUser(user);
  const normalized = normalizeUserData(user);
  saveToDatabase(normalized);
  sendWelcomeEmail(user.email);
  logUserCreation(user);
  return normalized;
}

// Good: Break into smaller, focused functions
function processUser(user) {
  const validatedUser = validateUser(user);
  const normalizedUser = normalizeUserData(validatedUser);
  return normalizedUser;
}

function createUser(user) {
  const processedUser = processUser(user);
  saveToDatabase(processedUser);
  notifyUserCreation(processedUser);
  return processedUser;
}
```

### 3. Prefer Pure Functions

```javascript
// Bad: Mutates input
function addProperty(obj, key, value) {
  obj[key] = value;
  return obj;
}

// Good: Returns new object
function addProperty(obj, key, value) {
  return { ...obj, [key]: value };
}
```

### 4. Use Default Parameters

```javascript
// Bad
function createUser(name, role) {
  role = role || 'user';
  return { name, role };
}

// Good
function createUser(name, role = 'user') {
  return { name, role };
}
```

### 5. Use Arrow Functions for Callbacks

```javascript
// Less concise
[1, 2, 3].map(function(n) {
  return n * 2;
});

// More concise
[1, 2, 3].map(n => n * 2);
```

### 6. Document Complex Functions

```javascript
/**
 * Calculates the Levenshtein distance between two strings
 * @param {string} str1 - First string
 * @param {string} str2 - Second string
 * @returns {number} Edit distance between strings
 */
function levenshteinDistance(str1, str2) {
  // Implementation...
}
```

### 7. Handle Errors Gracefully

```javascript
function parseJSON(jsonString) {
  try {
    return JSON.parse(jsonString);
  } catch (error) {
    console.error('Invalid JSON:', error.message);
    return null;
  }
}
```

### 8. Avoid Deep Nesting

```javascript
// Bad
function processData(data) {
  if (data) {
    if (data.items) {
      if (data.items.length > 0) {
        // Process items
      }
    }
  }
}

// Good: Early returns
function processData(data) {
  if (!data) return;
  if (!data.items) return;
  if (data.items.length === 0) return;

  // Process items
}
```

---

## Common Pitfalls

### 1. Forgetting to Return

```javascript
// Bug: No return statement
function add(a, b) {
  a + b; // Result is lost
}

console.log(add(2, 3)); // undefined

// Fix
function add(a, b) {
  return a + b;
}
```

### 2. Modifying Function Parameters

```javascript
// Bad: Mutates input
function updateUser(user) {
  user.lastUpdated = Date.now();
  return user;
}

const originalUser = { name: 'Alice' };
const updatedUser = updateUser(originalUser);
// originalUser is also modified!

// Good: Create new object
function updateUser(user) {
  return {
    ...user,
    lastUpdated: Date.now()
  };
}
```

### 3. Arrow Function `this` Confusion

```javascript
// Doesn't work as expected
const user = {
  name: 'Alice',
  greet: () => {
    console.log(`Hello, ${this.name}`); // this is not user
  }
};

// Fix: Use regular function for methods
const user = {
  name: 'Alice',
  greet() {
    console.log(`Hello, ${this.name}`);
  }
};
```

### 4. Not Understanding Closure Scope

```javascript
// Bug
function createFunctions() {
  const functions = [];
  for (var i = 0; i < 3; i++) {
    functions.push(function() {
      console.log(i);
    });
  }
  return functions;
}

const fns = createFunctions();
fns[0](); // 3 (expected 0)
fns[1](); // 3 (expected 1)

// Fix: Use let or IIFE
function createFunctions() {
  const functions = [];
  for (let i = 0; i < 3; i++) { // let creates block scope
    functions.push(function() {
      console.log(i);
    });
  }
  return functions;
}
```

### 5. Callback Hell

```javascript
// Bad: Nested callbacks
getData(function(data) {
  processData(data, function(processed) {
    saveData(processed, function(saved) {
      sendNotification(saved, function(sent) {
        console.log('Done');
      });
    });
  });
});

// Better: Use promises or async/await (covered in later lessons)
```

---

## Summary & Next Steps

### Key Takeaways

- **Functions** are first-class citizens in JavaScript - they can be assigned, passed, and returned
- **Function declarations** are hoisted; **function expressions** and **arrow functions** are not
- **Arrow functions** provide concise syntax and lexical `this` binding
- **Default parameters** and **rest parameters** make functions more flexible
- **Higher-order functions** enable powerful abstractions and functional programming
- **Closures** allow functions to remember their lexical scope
- **Pure functions** are predictable, testable, and maintainable
- **IIFE** patterns provide encapsulation and module-like behavior
- **Best practices** include keeping functions small, focused, and well-documented

### Related Topics

- [Scope and Closures](./06.Scope_And_Closures.md) - Deep dive into scope and closure concepts
- [Arrow Functions](../09.arrow_functions/01.arrow_functions.md) - Detailed arrow function guide
- [Array Methods](../06.array_and_objects/02.array_methods.md) - Higher-order array operations
- [Async Programming](../async/) - Promises, async/await, and asynchronous patterns

### Practice Recommendations

1. Solve all exercises in this lesson
2. Refactor old code to use modern function syntax
3. Practice writing pure functions
4. Build a small project using higher-order functions and closures
5. Review production code for function anti-patterns

### Further Reading

- [MDN: Functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions)
- [MDN: Arrow Functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions)
- [MDN: Closures](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures)
- [JavaScript.info: Functions](https://javascript.info/function-basics)
- [Eloquent JavaScript: Functions](https://eloquentjavascript.net/03_functions.html)

---

**Next Lesson:** [06.Scope_And_Closures.md](./06.Scope_And_Closures.md) - Master scope chains, closures, and the module pattern
