# Iterators and Generators in JavaScript

**Difficulty:** Intermediate to Advanced
**Estimated Time:** 60-75 minutes
**Prerequisites:** Functions, arrays, objects, ES6 syntax, async/await basics
**Target:** Node.js 18+ LTS, Modern Browsers (ES2021+)

---

## Learning Objectives

By the end of this lesson, you will be able to:

1. Understand the iterator protocol and how JavaScript iteration works
2. Implement custom iterators for any data structure
3. Master generator functions and the `yield` keyword
4. Use generator delegation with `yield*`
5. Create async generators for asynchronous iteration
6. Apply iterators and generators for lazy evaluation
7. Build infinite sequences efficiently
8. Implement practical use cases like pagination and data streaming
9. Optimize performance with iterator patterns
10. Debug common iterator and generator issues

---

## Table of Contents

1. [Introduction](#introduction)
2. [The Iterator Protocol](#the-iterator-protocol)
3. [The Iterable Protocol](#the-iterable-protocol)
4. [Built-in Iterables](#built-in-iterables)
5. [Custom Iterators](#custom-iterators)
6. [Generator Functions](#generator-functions)
7. [The `yield` Keyword](#the-yield-keyword)
8. [Generator Delegation (yield*)](#generator-delegation-yield)
9. [Async Generators](#async-generators)
10. [Lazy Evaluation](#lazy-evaluation)
11. [Infinite Sequences](#infinite-sequences)
12. [Practical Use Cases](#practical-use-cases)
13. [Worked Examples](#worked-examples)
14. [Exercises](#exercises)
15. [Testing & Verification](#testing--verification)
16. [Best Practices](#best-practices)
17. [Common Pitfalls](#common-pitfalls)
18. [Performance Considerations](#performance-considerations)
19. [Summary & Next Steps](#summary--next-steps)
20. [References](#references)

---

## Introduction

**Iterators** and **Generators** are powerful features in JavaScript that provide controlled, sequential access to data. They enable lazy evaluation, memory efficiency, and elegant solutions to complex iteration problems.

**Why Iterators and Generators Matter:**

- **Memory Efficiency:** Process large datasets without loading everything into memory
- **Lazy Evaluation:** Compute values only when needed
- **Infinite Sequences:** Represent endless data streams
- **Clean Syntax:** More readable than traditional loops for complex iterations
- **Async Iteration:** Handle asynchronous data streams naturally
- **Control Flow:** Pause and resume execution

**Real-World Applications:**

- **Data Streaming:** Process large files chunk by chunk
- **Pagination:** Fetch data page by page from APIs
- **Infinite Scrolling:** Load content as user scrolls
- **State Machines:** Model state transitions
- **Async Workflows:** Coordinate asynchronous operations
- **Tree Traversal:** Navigate complex data structures

---

## The Iterator Protocol

The **iterator protocol** defines a standard way to produce a sequence of values. An object is an iterator when it implements a `next()` method with specific behavior.

### Iterator Requirements

An iterator must have a `next()` method that returns an object with:
- `value`: The current value (any type)
- `done`: Boolean indicating if iteration is complete

```javascript
const iterator = {
  current: 0,
  last: 3,

  next() {
    if (this.current <= this.last) {
      return { value: this.current++, done: false };
    } else {
      return { value: undefined, done: true };
    }
  }
};

console.log(iterator.next());  // { value: 0, done: false }
console.log(iterator.next());  // { value: 1, done: false }
console.log(iterator.next());  // { value: 2, done: false }
console.log(iterator.next());  // { value: 3, done: false }
console.log(iterator.next());  // { value: undefined, done: true }
```

### Manual Iterator Usage

```javascript
function makeRangeIterator(start = 0, end = Infinity, step = 1) {
  let nextIndex = start;
  let iterationCount = 0;

  const rangeIterator = {
    next() {
      let result;

      if (nextIndex < end) {
        result = { value: nextIndex, done: false };
        nextIndex += step;
        iterationCount++;
        return result;
      }

      return { value: iterationCount, done: true };
    }
  };

  return rangeIterator;
}

const iterator = makeRangeIterator(1, 10, 2);

let result = iterator.next();
while (!result.done) {
  console.log(result.value);  // 1, 3, 5, 7, 9
  result = iterator.next();
}
```

---

## The Iterable Protocol

The **iterable protocol** allows objects to define their iteration behavior. An object is iterable when it implements the `@@iterator` method via `Symbol.iterator`.

### Making Objects Iterable

```javascript
const myIterable = {
  data: [1, 2, 3, 4, 5],

  [Symbol.iterator]() {
    let index = 0;
    const data = this.data;

    return {
      next() {
        if (index < data.length) {
          return { value: data[index++], done: false };
        } else {
          return { value: undefined, done: true };
        }
      }
    };
  }
};

// Can now use for...of
for (const value of myIterable) {
  console.log(value);  // 1, 2, 3, 4, 5
}

// Can use spread operator
const array = [...myIterable];  // [1, 2, 3, 4, 5]
```

### Iterable vs Iterator

```javascript
// Iterable: has Symbol.iterator method
const iterable = {
  [Symbol.iterator]() {
    return iterator;  // Returns an iterator
  }
};

// Iterator: has next() method
const iterator = {
  next() {
    return { value: something, done: boolean };
  }
};

// An object can be both iterable and iterator
const combined = {
  current: 0,
  last: 3,

  [Symbol.iterator]() {
    return this;  // Returns itself
  },

  next() {
    if (this.current <= this.last) {
      return { value: this.current++, done: false };
    }
    return { value: undefined, done: true };
  }
};
```

---

## Built-in Iterables

JavaScript has many built-in iterable objects.

### Arrays

```javascript
const arr = ['a', 'b', 'c'];

// Get iterator
const iterator = arr[Symbol.iterator]();

console.log(iterator.next());  // { value: 'a', done: false }
console.log(iterator.next());  // { value: 'b', done: false }
console.log(iterator.next());  // { value: 'c', done: false }
console.log(iterator.next());  // { value: undefined, done: true }

// for...of uses iterator internally
for (const item of arr) {
  console.log(item);  // 'a', 'b', 'c'
}
```

### Strings

```javascript
const str = 'hello';

for (const char of str) {
  console.log(char);  // 'h', 'e', 'l', 'l', 'o'
}

const chars = [...str];  // ['h', 'e', 'l', 'l', 'o']
```

### Maps and Sets

```javascript
const map = new Map([
  ['key1', 'value1'],
  ['key2', 'value2']
]);

for (const [key, value] of map) {
  console.log(key, value);
}

const set = new Set([1, 2, 3, 2, 1]);

for (const value of set) {
  console.log(value);  // 1, 2, 3 (duplicates removed)
}
```

### Map/Set Iterator Methods

```javascript
const map = new Map([['a', 1], ['b', 2]]);

// Keys iterator
for (const key of map.keys()) {
  console.log(key);  // 'a', 'b'
}

// Values iterator
for (const value of map.values()) {
  console.log(value);  // 1, 2
}

// Entries iterator
for (const [key, value] of map.entries()) {
  console.log(key, value);  // 'a' 1, 'b' 2
}
```

---

## Custom Iterators

Create iterators for any custom data structure.

### Range Iterator

```javascript
class Range {
  constructor(start, end, step = 1) {
    this.start = start;
    this.end = end;
    this.step = step;
  }

  [Symbol.iterator]() {
    let current = this.start;
    const end = this.end;
    const step = this.step;

    return {
      next() {
        if (current < end) {
          const value = current;
          current += step;
          return { value, done: false };
        }
        return { value: undefined, done: true };
      }
    };
  }
}

const range = new Range(0, 10, 2);

for (const num of range) {
  console.log(num);  // 0, 2, 4, 6, 8
}

const numbers = [...new Range(1, 6)];  // [1, 2, 3, 4, 5]
```

### Linked List Iterator

```javascript
class Node {
  constructor(value, next = null) {
    this.value = value;
    this.next = next;
  }
}

class LinkedList {
  constructor() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  append(value) {
    const node = new Node(value);

    if (!this.head) {
      this.head = node;
      this.tail = node;
    } else {
      this.tail.next = node;
      this.tail = node;
    }

    this.length++;
  }

  [Symbol.iterator]() {
    let current = this.head;

    return {
      next() {
        if (current) {
          const value = current.value;
          current = current.next;
          return { value, done: false };
        }
        return { value: undefined, done: true };
      }
    };
  }
}

const list = new LinkedList();
list.append(1);
list.append(2);
list.append(3);

for (const value of list) {
  console.log(value);  // 1, 2, 3
}
```

### Tree Iterator (Depth-First)

```javascript
class TreeNode {
  constructor(value, children = []) {
    this.value = value;
    this.children = children;
  }

  *[Symbol.iterator]() {
    // Depth-first traversal
    yield this.value;

    for (const child of this.children) {
      yield* child;  // Delegate to child's iterator
    }
  }
}

const tree = new TreeNode('root', [
  new TreeNode('child1', [
    new TreeNode('grandchild1'),
    new TreeNode('grandchild2')
  ]),
  new TreeNode('child2')
]);

for (const value of tree) {
  console.log(value);
  // root, child1, grandchild1, grandchild2, child2
}
```

---

## Generator Functions

Generator functions provide an easier way to create iterators. They use the `function*` syntax and `yield` keyword.

### Basic Generator

```javascript
function* numberGenerator() {
  yield 1;
  yield 2;
  yield 3;
}

const gen = numberGenerator();

console.log(gen.next());  // { value: 1, done: false }
console.log(gen.next());  // { value: 2, done: false }
console.log(gen.next());  // { value: 3, done: false }
console.log(gen.next());  // { value: undefined, done: true }

// Generators are iterable
for (const num of numberGenerator()) {
  console.log(num);  // 1, 2, 3
}
```

### Generator with Logic

```javascript
function* fibonacci() {
  let [prev, curr] = [0, 1];

  while (true) {
    yield curr;
    [prev, curr] = [curr, prev + curr];
  }
}

const fib = fibonacci();

console.log(fib.next().value);  // 1
console.log(fib.next().value);  // 1
console.log(fib.next().value);  // 2
console.log(fib.next().value);  // 3
console.log(fib.next().value);  // 5
console.log(fib.next().value);  // 8
```

### Generator with Parameters

```javascript
function* range(start, end, step = 1) {
  for (let i = start; i < end; i += step) {
    yield i;
  }
}

const numbers = [...range(0, 10, 2)];
console.log(numbers);  // [0, 2, 4, 6, 8]

for (const num of range(1, 6)) {
  console.log(num);  // 1, 2, 3, 4, 5
}
```

### Generator Methods

```javascript
class Collection {
  constructor(items) {
    this.items = items;
  }

  *values() {
    for (const item of this.items) {
      yield item;
    }
  }

  *keys() {
    for (let i = 0; i < this.items.length; i++) {
      yield i;
    }
  }

  *entries() {
    for (let i = 0; i < this.items.length; i++) {
      yield [i, this.items[i]];
    }
  }

  [Symbol.iterator]() {
    return this.values();
  }
}

const collection = new Collection(['a', 'b', 'c']);

for (const value of collection.values()) {
  console.log(value);  // 'a', 'b', 'c'
}

for (const [index, value] of collection.entries()) {
  console.log(index, value);  // 0 'a', 1 'b', 2 'c'
}
```

---

## The `yield` Keyword

The `yield` keyword pauses generator execution and returns a value.

### Basic Yield

```javascript
function* example() {
  console.log('Start');
  yield 1;
  console.log('Middle');
  yield 2;
  console.log('End');
  yield 3;
}

const gen = example();

gen.next();  // Logs: 'Start', returns { value: 1, done: false }
gen.next();  // Logs: 'Middle', returns { value: 2, done: false }
gen.next();  // Logs: 'End', returns { value: 3, done: false }
gen.next();  // Returns { value: undefined, done: true }
```

### Yield Expressions

```javascript
function* twoWayGenerator() {
  const x = yield 'First yield';
  console.log('Received:', x);

  const y = yield 'Second yield';
  console.log('Received:', y);

  return 'Done';
}

const gen = twoWayGenerator();

console.log(gen.next());        // { value: 'First yield', done: false }
console.log(gen.next('Value1')); // Logs: 'Received: Value1'
                                 // { value: 'Second yield', done: false }
console.log(gen.next('Value2')); // Logs: 'Received: Value2'
                                 // { value: 'Done', done: true }
```

### Yield with Return Value

```javascript
function* generatorWithReturn() {
  yield 1;
  yield 2;
  return 'Final value';
}

const gen = generatorWithReturn();

console.log(gen.next());  // { value: 1, done: false }
console.log(gen.next());  // { value: 2, done: false }
console.log(gen.next());  // { value: 'Final value', done: true }

// Return value is NOT included in iteration
const values = [...generatorWithReturn()];
console.log(values);  // [1, 2] - return value excluded!
```

---

## Generator Delegation (yield*)

The `yield*` expression delegates to another generator or iterable.

### Delegating to Another Generator

```javascript
function* generator1() {
  yield 1;
  yield 2;
}

function* generator2() {
  yield 'a';
  yield* generator1();  // Delegate to generator1
  yield 'b';
}

const gen = generator2();

console.log([...gen]);  // ['a', 1, 2, 'b']
```

### Delegating to Iterables

```javascript
function* delegateToArray() {
  yield 'start';
  yield* [1, 2, 3];  // Delegate to array
  yield* 'hi';        // Delegate to string
  yield 'end';
}

console.log([...delegateToArray()]);
// ['start', 1, 2, 3, 'h', 'i', 'end']
```

### Recursive Generators with yield*

```javascript
function* flatten(array) {
  for (const item of array) {
    if (Array.isArray(item)) {
      yield* flatten(item);  // Recursively flatten
    } else {
      yield item;
    }
  }
}

const nested = [1, [2, [3, 4], 5], 6, [7, 8]];
const flat = [...flatten(nested)];

console.log(flat);  // [1, 2, 3, 4, 5, 6, 7, 8]
```

### Tree Traversal with yield*

```javascript
class TreeNode {
  constructor(value, left = null, right = null) {
    this.value = value;
    this.left = left;
    this.right = right;
  }

  *inorder() {
    if (this.left) yield* this.left.inorder();
    yield this.value;
    if (this.right) yield* this.right.inorder();
  }

  *preorder() {
    yield this.value;
    if (this.left) yield* this.left.preorder();
    if (this.right) yield* this.right.preorder();
  }

  *postorder() {
    if (this.left) yield* this.left.postorder();
    if (this.right) yield* this.right.postorder();
    yield this.value;
  }
}

const tree = new TreeNode(4,
  new TreeNode(2,
    new TreeNode(1),
    new TreeNode(3)
  ),
  new TreeNode(6,
    new TreeNode(5),
    new TreeNode(7)
  )
);

console.log([...tree.inorder()]);    // [1, 2, 3, 4, 5, 6, 7]
console.log([...tree.preorder()]);   // [4, 2, 1, 3, 6, 5, 7]
console.log([...tree.postorder()]);  // [1, 3, 2, 5, 7, 6, 4]
```

---

## Async Generators

Async generators combine generators with async/await for asynchronous iteration.

### Basic Async Generator

```javascript
async function* asyncGenerator() {
  yield await Promise.resolve(1);
  yield await Promise.resolve(2);
  yield await Promise.resolve(3);
}

(async () => {
  for await (const value of asyncGenerator()) {
    console.log(value);  // 1, 2, 3
  }
})();
```

### Async Generator for API Pagination

```javascript
async function* fetchPages(url, maxPages = Infinity) {
  let page = 1;

  while (page <= maxPages) {
    const response = await fetch(`${url}?page=${page}`);
    const data = await response.json();

    if (data.items.length === 0) break;

    yield data.items;
    page++;
  }
}

// Usage
(async () => {
  for await (const items of fetchPages('https://api.example.com/users', 5)) {
    console.log(`Processing ${items.length} items`);
    items.forEach(item => console.log(item.name));
  }
})();
```

### Async Generator for Streams

```javascript
async function* readFileChunks(filename, chunkSize = 1024) {
  const file = await open(filename);

  try {
    let chunk;
    while ((chunk = await file.read(chunkSize)) !== null) {
      yield chunk;
    }
  } finally {
    await file.close();
  }
}

// Process file in chunks
(async () => {
  for await (const chunk of readFileChunks('large-file.txt')) {
    processChunk(chunk);
  }
})();
```

### Combining Async Generators

```javascript
async function* mergeAsyncIterators(...iterators) {
  for (const iterator of iterators) {
    for await (const value of iterator) {
      yield value;
    }
  }
}

async function* numbers() {
  yield 1;
  yield 2;
  yield 3;
}

async function* letters() {
  yield 'a';
  yield 'b';
  yield 'c';
}

(async () => {
  for await (const value of mergeAsyncIterators(numbers(), letters())) {
    console.log(value);  // 1, 2, 3, 'a', 'b', 'c'
  }
})();
```

---

## Lazy Evaluation

Generators enable lazy evaluation: values are computed only when needed.

### Lazy Map

```javascript
function* lazyMap(iterable, mapper) {
  for (const value of iterable) {
    yield mapper(value);
  }
}

const numbers = [1, 2, 3, 4, 5];
const doubled = lazyMap(numbers, x => {
  console.log(`Computing ${x} * 2`);
  return x * 2;
});

// Nothing computed yet!

for (const value of doubled) {
  console.log(value);
  if (value >= 6) break;  // Stop early
}
// Only computes: 1*2, 2*2, 3*2
// Doesn't compute 4*2, 5*2
```

### Lazy Filter

```javascript
function* lazyFilter(iterable, predicate) {
  for (const value of iterable) {
    if (predicate(value)) {
      yield value;
    }
  }
}

function* lazyRange(start, end) {
  for (let i = start; i < end; i++) {
    console.log(`Generating ${i}`);
    yield i;
  }
}

const numbers = lazyRange(1, 1000000);
const evens = lazyFilter(numbers, x => x % 2 === 0);

// Take only first 5 even numbers
const first5Evens = [];
for (const num of evens) {
  first5Evens.push(num);
  if (first5Evens.length === 5) break;
}

console.log(first5Evens);  // [2, 4, 6, 8, 10]
// Only generated numbers 1-10, not all 1 million!
```

### Composing Lazy Operations

```javascript
function* pipe(iterable, ...operations) {
  let result = iterable;
  for (const operation of operations) {
    result = operation(result);
  }
  yield* result;
}

const numbers = lazyRange(1, 100);

const result = pipe(
  numbers,
  iter => lazyFilter(iter, x => x % 2 === 0),
  iter => lazyMap(iter, x => x * x),
  iter => lazyFilter(iter, x => x > 100)
);

console.log([...result].slice(0, 5));
// First 5 even squares greater than 100
```

---

## Infinite Sequences

Generators can represent infinite sequences efficiently.

### Infinite Counter

```javascript
function* counter(start = 0, step = 1) {
  let count = start;
  while (true) {
    yield count;
    count += step;
  }
}

const numbers = counter();

console.log(numbers.next().value);  // 0
console.log(numbers.next().value);  // 1
console.log(numbers.next().value);  // 2

// Take first 10
const first10 = [];
const counting = counter(1);
for (const num of counting) {
  first10.push(num);
  if (first10.length === 10) break;
}
console.log(first10);  // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

### Random Number Generator

```javascript
function* randomNumbers(min = 0, max = 1) {
  while (true) {
    yield Math.random() * (max - min) + min;
  }
}

const randoms = randomNumbers(1, 100);

console.log(randoms.next().value);  // Random number between 1-100
console.log(randoms.next().value);  // Another random number
```

### ID Generator

```javascript
function* idGenerator(prefix = 'ID') {
  let id = 1;
  while (true) {
    yield `${prefix}_${String(id++).padStart(6, '0')}`;
  }
}

const ids = idGenerator('USER');

console.log(ids.next().value);  // USER_000001
console.log(ids.next().value);  // USER_000002
console.log(ids.next().value);  // USER_000003
```

### Cycle Iterator

```javascript
function* cycle(iterable) {
  const cache = [];

  for (const value of iterable) {
    cache.push(value);
    yield value;
  }

  while (cache.length > 0) {
    for (const value of cache) {
      yield value;
    }
  }
}

const colors = cycle(['red', 'green', 'blue']);

// Cycles through colors forever
for (let i = 0; i < 10; i++) {
  console.log(colors.next().value);
}
// red, green, blue, red, green, blue, red, green, blue, red
```

---

## Practical Use Cases

### Pagination Helper

```javascript
class Paginator {
  constructor(items, pageSize = 10) {
    this.items = items;
    this.pageSize = pageSize;
  }

  *pages() {
    for (let i = 0; i < this.items.length; i += this.pageSize) {
      yield this.items.slice(i, i + this.pageSize);
    }
  }

  *pageInfo() {
    const totalPages = Math.ceil(this.items.length / this.pageSize);

    for (let i = 0; i < this.items.length; i += this.pageSize) {
      const currentPage = Math.floor(i / this.pageSize) + 1;
      const items = this.items.slice(i, i + this.pageSize);

      yield {
        page: currentPage,
        totalPages,
        items,
        hasNext: currentPage < totalPages,
        hasPrev: currentPage > 1
      };
    }
  }
}

const items = Array.from({ length: 95 }, (_, i) => `Item ${i + 1}`);
const paginator = new Paginator(items, 10);

for (const page of paginator.pages()) {
  console.log(page);  // 10 items per page
}

for (const info of paginator.pageInfo()) {
  console.log(`Page ${info.page} of ${info.totalPages}`);
}
```

### Batch Processor

```javascript
function* batch(iterable, size) {
  let currentBatch = [];

  for (const item of iterable) {
    currentBatch.push(item);

    if (currentBatch.length === size) {
      yield currentBatch;
      currentBatch = [];
    }
  }

  if (currentBatch.length > 0) {
    yield currentBatch;
  }
}

// Process large dataset in batches
const data = Array.from({ length: 1000 }, (_, i) => i);

for (const dataBatch of batch(data, 100)) {
  processBatch(dataBatch);  // Process 100 items at a time
}

function processBatch(items) {
  console.log(`Processing batch of ${items.length} items`);
  // Database insert, API call, etc.
}
```

### Debounced Event Stream

```javascript
async function* debounce(asyncIterable, delay) {
  let lastValue;
  let timer;

  for await (const value of asyncIterable) {
    lastValue = value;

    clearTimeout(timer);

    await new Promise(resolve => {
      timer = setTimeout(() => {
        resolve();
      }, delay);
    });

    yield lastValue;
  }
}

// Usage with async events
async function* userInput() {
  // Simulated user typing
  yield 'h';
  await sleep(50);
  yield 'he';
  await sleep(50);
  yield 'hel';
  await sleep(50);
  yield 'hell';
  await sleep(50);
  yield 'hello';
  await sleep(500);  // User stops typing
}

(async () => {
  for await (const value of debounce(userInput(), 200)) {
    console.log('Search for:', value);  // Only logs 'hello'
  }
})();
```

---

## Worked Examples

### Example 1: CSV Parser

```javascript
function* parseCSV(text) {
  const lines = text.split('\n');
  const headers = lines[0].split(',').map(h => h.trim());

  for (let i = 1; i < lines.length; i++) {
    const line = lines[i].trim();
    if (!line) continue;

    const values = line.split(',').map(v => v.trim());
    const row = {};

    headers.forEach((header, index) => {
      row[header] = values[index];
    });

    yield row;
  }
}

const csv = `
name,age,city
Alice,30,New York
Bob,25,San Francisco
Charlie,35,Los Angeles
`;

for (const row of parseCSV(csv)) {
  console.log(row);
}
// { name: 'Alice', age: '30', city: 'New York' }
// { name: 'Bob', age: '25', city: 'San Francisco' }
// { name: 'Charlie', age: '35', city: 'Los Angeles' }
```

### Example 2: Sliding Window

```javascript
function* slidingWindow(iterable, size) {
  const window = [];

  for (const item of iterable) {
    window.push(item);

    if (window.length === size) {
      yield [...window];
      window.shift();
    }
  }
}

const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

for (const window of slidingWindow(numbers, 3)) {
  console.log(window);
}
// [1, 2, 3]
// [2, 3, 4]
// [3, 4, 5]
// [4, 5, 6]
// [5, 6, 7]
// [6, 7, 8]
// [7, 8, 9]
// [8, 9, 10]

// Calculate moving average
function* movingAverage(numbers, windowSize) {
  for (const window of slidingWindow(numbers, windowSize)) {
    const sum = window.reduce((a, b) => a + b, 0);
    yield sum / windowSize;
  }
}

const averages = [...movingAverage(numbers, 3)];
console.log(averages);
```

### Example 3: Permutations Generator

```javascript
function* permutations(array) {
  if (array.length <= 1) {
    yield array;
    return;
  }

  for (let i = 0; i < array.length; i++) {
    const current = array[i];
    const remaining = array.slice(0, i).concat(array.slice(i + 1));

    for (const perm of permutations(remaining)) {
      yield [current, ...perm];
    }
  }
}

const items = ['A', 'B', 'C'];

for (const perm of permutations(items)) {
  console.log(perm.join(''));
}
// ABC, ACB, BAC, BCA, CAB, CBA
```

---

## Exercises

### Exercise 1: Custom Range Iterator (Easy)

Create a `Range` class that is iterable and supports different step values.

**Requirements:**
- Constructor: `Range(start, end, step = 1)`
- Should be iterable with `for...of`
- Support negative steps (count backwards)
- Method: `toArray()` returns array of all values
- Method: `includes(value)` checks if value is in range
- Should work with spread operator

**Example:**
```javascript
const range = new Range(0, 10, 2);
console.log([...range]);  // [0, 2, 4, 6, 8]

const backwards = new Range(10, 0, -1);
console.log([...backwards]);  // [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]

console.log(range.includes(4));  // true
```

---

### Exercise 2: Fibonacci Generator (Easy)

Create a fibonacci number generator with various utility methods.

**Requirements:**
- Function: `fibonacci()` - infinite generator
- Function: `fibonacciUpTo(max)` - generator up to max value
- Function: `fibonacciN(n)` - generator for first n numbers
- Function: `fibonacciRange(start, end)` - fibonacci numbers in range
- All should be generators

**Example:**
```javascript
const fib = fibonacci();
console.log(fib.next().value);  // 1
console.log(fib.next().value);  // 1
console.log(fib.next().value);  // 2

console.log([...fibonacciN(10)]);  // First 10 fibonacci numbers
console.log([...fibonacciUpTo(100)]);  // All fibonacci numbers ≤ 100
```

---

### Exercise 3: Async Data Fetcher (Medium)

Build an async generator that fetches paginated data from an API.

**Requirements:**
- Async generator: `fetchAllPages(url, options = {})`
- Options: `maxPages`, `pageSize`, `delay` (between requests)
- Should handle:
  - Pagination automatically
  - Rate limiting with delay
  - Error handling and retries
  - Stopping when no more data
- Yield each page's data
- Track stats: pages fetched, total items, errors

**Example:**
```javascript
for await (const data of fetchAllPages('https://api.example.com/users', {
  maxPages: 10,
  pageSize: 50,
  delay: 1000
})) {
  console.log(`Received ${data.items.length} items`);
  processItems(data.items);
}
```

---

### Exercise 4: Tree Traversal (Medium)

Implement multiple tree traversal strategies using generators.

**Requirements:**
- Class: `TreeNode` with value and children array
- Generator methods:
  - `breadthFirst()` - BFS traversal
  - `depthFirst()` - DFS traversal
  - `preorder()` - Pre-order traversal
  - `postorder()` - Post-order traversal
  - `leaves()` - Only leaf nodes
  - `atLevel(level)` - Nodes at specific level
- Should work with any tree depth

**Example:**
```javascript
const tree = new TreeNode(1, [
  new TreeNode(2, [
    new TreeNode(4),
    new TreeNode(5)
  ]),
  new TreeNode(3, [
    new TreeNode(6)
  ])
]);

console.log([...tree.breadthFirst()]);  // [1, 2, 3, 4, 5, 6]
console.log([...tree.depthFirst()]);    // [1, 2, 4, 5, 3, 6]
console.log([...tree.leaves()]);        // [4, 5, 6]
```

---

### Exercise 5: Stream Processor (Hard)

Create a stream processing system using generators for data transformations.

**Requirements:**
- Class: `Stream` with chainable transformations
- Methods:
  - `map(fn)` - transform each value
  - `filter(fn)` - filter values
  - `take(n)` - take first n values
  - `skip(n)` - skip first n values
  - `reduce(fn, initial)` - reduce to single value
  - `forEach(fn)` - execute for each value
  - `toArray()` - collect to array
- Should support method chaining
- Lazy evaluation (only compute when needed)

**Example:**
```javascript
const stream = Stream.from([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
  .filter(x => x % 2 === 0)
  .map(x => x * x)
  .skip(1)
  .take(2);

console.log(stream.toArray());  // [16, 36]
```

---

### Exercise 6: Infinite Grid Walker (Advanced)

Create a generator that walks an infinite 2D grid in a spiral pattern.

**Requirements:**
- Generator: `spiralWalk(startX = 0, startY = 0)`
- Yields coordinates in spiral: (0,0), (1,0), (1,1), (0,1), (-1,1), (-1,0), (-1,-1), (0,-1), (1,-1), (2,-1), ...
- Should be truly infinite
- Method: `spiralValues(grid)` - yields values from actual grid in spiral order
- Should handle sparse grids (not all coordinates have values)

**Example:**
```javascript
const spiral = spiralWalk();

for (let i = 0; i < 10; i++) {
  const { value } = spiral.next();
  console.log(value);  // [0,0], [1,0], [1,1], [0,1], ...
}

const grid = new Map([
  ['0,0', 'center'],
  ['1,0', 'right'],
  ['0,1', 'top']
]);

for (const value of spiralValues(grid)) {
  console.log(value);  // 'center', 'right', 'top'
}
```

---

## Testing & Verification

### Testing Generators

```javascript
import { describe, it, expect } from 'vitest';

function* range(start, end) {
  for (let i = start; i < end; i++) {
    yield i;
  }
}

describe('range generator', () => {
  it('should generate sequence', () => {
    const result = [...range(1, 5)];
    expect(result).toEqual([1, 2, 3, 4]);
  });

  it('should work with for...of', () => {
    const values = [];
    for (const value of range(0, 3)) {
      values.push(value);
    }
    expect(values).toEqual([0, 1, 2]);
  });

  it('should support manual iteration', () => {
    const gen = range(1, 3);
    expect(gen.next()).toEqual({ value: 1, done: false });
    expect(gen.next()).toEqual({ value: 2, done: false });
    expect(gen.next()).toEqual({ value: undefined, done: true });
  });
});
```

---

## Best Practices

### 1. Use Generators for Lazy Sequences

```javascript
// ✅ GOOD: Lazy evaluation
function* lazyFilter(iterable, predicate) {
  for (const value of iterable) {
    if (predicate(value)) yield value;
  }
}

// ❌ AVOID: Eager evaluation for large datasets
function eagerFilter(array, predicate) {
  return array.filter(predicate);  // Processes entire array
}
```

### 2. Prefer Generators for Complex Iteration

```javascript
// ✅ GOOD: Clear, concise
function* fibonacci() {
  let [a, b] = [0, 1];
  while (true) {
    yield b;
    [a, b] = [b, a + b];
  }
}

// ❌ AVOID: Complex iterator object
function fibonacciIterator() {
  let a = 0, b = 1;
  return {
    next() {
      const value = b;
      [a, b] = [b, a + b];
      return { value, done: false };
    }
  };
}
```

### 3. Handle Infinite Generators Safely

```javascript
// ✅ GOOD: Controlled iteration
function* infiniteSequence() {
  let n = 0;
  while (true) yield n++;
}

const first10 = [];
for (const value of infiniteSequence()) {
  first10.push(value);
  if (first10.length === 10) break;  // Always have exit condition
}

// ❌ WRONG: No exit condition
// [...infiniteSequence()]  // Infinite loop!
```

---

## Common Pitfalls

### 1. Forgetting to Iterate Generator

```javascript
function* numbers() {
  yield 1;
  yield 2;
}

// ❌ WRONG: Generator function, not values
const nums = numbers;
console.log(nums);  // [Function: numbers]

// ✅ CORRECT: Call and iterate
const nums = [...numbers()];
console.log(nums);  // [1, 2]
```

### 2. Generator Exhaustion

```javascript
function* numbers() {
  yield 1;
  yield 2;
  yield 3;
}

const gen = numbers();

// First iteration
console.log([...gen]);  // [1, 2, 3]

// Second iteration
console.log([...gen]);  // [] - Generator exhausted!

// ✅ SOLUTION: Create new generator
console.log([...numbers()]);  // [1, 2, 3]
```

### 3. Modifying Iterated Collection

```javascript
const arr = [1, 2, 3, 4, 5];

// ❌ DANGEROUS: Modifying while iterating
for (const value of arr) {
  if (value % 2 === 0) {
    arr.splice(arr.indexOf(value), 1);  // Modifies array during iteration
  }
}

// ✅ BETTER: Create new array
const filtered = arr.filter(value => value % 2 !== 0);
```

---

## Performance Considerations

### Memory Efficiency

```javascript
// ❌ MEMORY INTENSIVE: Creates entire array
function range(n) {
  return Array.from({ length: n }, (_, i) => i);
}
const millionNumbers = range(1000000);  // 1M array in memory

// ✅ MEMORY EFFICIENT: Generates on demand
function* range(n) {
  for (let i = 0; i < n; i++) yield i;
}
const millionNumbers = range(1000000);  // Minimal memory
```

### Processing Large Data

```javascript
// Generator for large file processing
async function* processLargeFile(filename) {
  const stream = createReadStream(filename);
  let buffer = '';

  for await (const chunk of stream) {
    buffer += chunk;
    const lines = buffer.split('\n');
    buffer = lines.pop();  // Keep incomplete line

    for (const line of lines) {
      yield processLine(line);
    }
  }

  if (buffer) yield processLine(buffer);
}
```

---

## Summary & Next Steps

### Key Takeaways

- Iterators define how to traverse sequences
- Generators simplify iterator creation with `function*` and `yield`
- Lazy evaluation improves memory efficiency
- Async generators handle asynchronous data streams
- `yield*` delegates to other iterators
- Generators enable infinite sequences

### When to Use

- **Iterators:** Custom iteration over data structures
- **Generators:** Lazy sequences, complex iterations
- **Async Generators:** Streaming data, API pagination, file processing

### Related Topics

- [Async/Await](../async/async-await.md)
- [Promises](../async/promises.md)
- [Modules](./20.Modules.md)

### Further Reading

- [MDN: Iterators and Generators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators)
- [JavaScript.info: Generators](https://javascript.info/generators)
- [Exploring ES6: Generators](https://exploringjs.com/es6/ch_generators.html)

---

## References

- **ECMAScript Specification:** [Generator Functions](https://tc39.es/ecma262/#sec-generator-function-definitions)
- **MDN Web Docs:** [function*](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*)
- **MDN Web Docs:** [yield](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield)
- **MDN Web Docs:** [for await...of](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of)

---

**Practice Exercise:** Build a data processing pipeline that fetches paginated API data, transforms it with generators, and streams results to a database.

**Next Steps:** Apply iterators and generators to real-world projects like file processing, API pagination, and data streaming.
