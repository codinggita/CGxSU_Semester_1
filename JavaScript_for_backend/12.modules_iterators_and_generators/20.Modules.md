# ES6 Modules in JavaScript

**Difficulty:** Intermediate
**Estimated Time:** 60-75 minutes
**Prerequisites:** Functions, objects, classes, file system basics
**Target:** Node.js 18+ LTS (with ESM support), Modern Browsers (ES2021+)

---

## Learning Objectives

By the end of this lesson, you will be able to:

1. Understand the difference between ES Modules (ESM) and CommonJS
2. Use named exports and imports effectively
3. Implement default exports and imports
4. Master re-exporting patterns for module aggregation
5. Use dynamic imports for code splitting and lazy loading
6. Apply module patterns for code organization
7. Handle circular dependencies safely
8. Follow module best practices and conventions
9. Configure Node.js projects for ES Modules
10. Debug common module-related issues

---

## Table of Contents

1. [Introduction](#introduction)
2. [ES Modules vs CommonJS](#es-modules-vs-commonjs)
3. [Named Exports and Imports](#named-exports-and-imports)
4. [Default Exports and Imports](#default-exports-and-imports)
5. [Mixed Exports](#mixed-exports)
6. [Re-exporting](#re-exporting)
7. [Dynamic Imports](#dynamic-imports)
8. [Module Patterns](#module-patterns)
9. [Circular Dependencies](#circular-dependencies)
10. [Module Configuration](#module-configuration)
11. [Worked Examples](#worked-examples)
12. [Exercises](#exercises)
13. [Testing & Verification](#testing--verification)
14. [Best Practices](#best-practices)
15. [Common Pitfalls](#common-pitfalls)
16. [Summary & Next Steps](#summary--next-steps)
17. [References](#references)

---

## Introduction

**Modules** are self-contained units of code that encapsulate related functionality, making it reusable across different parts of an application. JavaScript modules solve the problem of global scope pollution and enable better code organization.

**Why Modules Matter:**

- **Encapsulation:** Keep variables and functions private
- **Reusability:** Import code where needed
- **Maintainability:** Easier to understand and modify
- **Dependency Management:** Clear dependency graphs
- **Performance:** Tree-shaking and code splitting
- **Namespace:** Avoid naming conflicts

**Real-World Applications:**

- **Backend APIs:** Separate routes, controllers, services, models
- **Utilities:** Shared helper functions across projects
- **Configuration:** Environment-specific settings
- **Libraries:** Publish reusable packages
- **Code Organization:** Large applications split into modules

---

## ES Modules vs CommonJS

JavaScript has two major module systems: **ES Modules (ESM)** and **CommonJS (CJS)**.

### ES Modules (Modern, Recommended)

```javascript
// math.js - ES Module
export const add = (a, b) => a + b;
export const multiply = (a, b) => a * b;

// main.js
import { add, multiply } from './math.js';
console.log(add(2, 3));  // 5
```

### CommonJS (Legacy Node.js)

```javascript
// math.js - CommonJS
const add = (a, b) => a + b;
const multiply = (a, b) => a * b;

module.exports = { add, multiply };

// main.js
const { add, multiply } = require('./math.js');
console.log(add(2, 3));  // 5
```

### Key Differences

| Feature | ES Modules | CommonJS |
|---------|-----------|----------|
| Syntax | `import`/`export` | `require()`/`module.exports` |
| When loaded | Compile time (static) | Runtime (dynamic) |
| Asynchronous | Yes | No |
| Tree-shaking | Supported | Not supported |
| Top-level await | Supported | Not supported |
| Browser support | Native | Requires bundler |
| File extension | `.mjs` or `.js` (with `"type": "module"`) | `.cjs` or `.js` (default) |
| `this` in module | `undefined` | `exports` object |

### When to Use Each

**Use ES Modules (ESM):**
- ✅ New projects
- ✅ Browser and Node.js code
- ✅ Need tree-shaking
- ✅ Prefer static analysis

**Use CommonJS (CJS):**
- ⚠️ Legacy Node.js projects
- ⚠️ Package compatibility requirements
- ⚠️ Dynamic requires needed

---

## Named Exports and Imports

Named exports allow you to export multiple values from a module.

### Inline Named Exports

```javascript
// utils.js
export const PI = 3.14159;

export function calculateCircleArea(radius) {
  return PI * radius ** 2;
}

export function calculateCircleCircumference(radius) {
  return 2 * PI * radius;
}

export class Circle {
  constructor(radius) {
    this.radius = radius;
  }

  getArea() {
    return calculateCircleArea(this.radius);
  }
}
```

### Export List (At Bottom)

```javascript
// utils.js
const PI = 3.14159;

function calculateCircleArea(radius) {
  return PI * radius ** 2;
}

function calculateCircleCircumference(radius) {
  return 2 * PI * radius;
}

class Circle {
  constructor(radius) {
    this.radius = radius;
  }
}

// Export at the end
export { PI, calculateCircleArea, calculateCircleCircumference, Circle };
```

### Importing Named Exports

```javascript
// main.js

// Import specific exports
import { PI, calculateCircleArea } from './utils.js';
console.log(PI);  // 3.14159
console.log(calculateCircleArea(5));  // 78.54

// Import all named exports
import * as utils from './utils.js';
console.log(utils.PI);  // 3.14159
console.log(utils.calculateCircleArea(5));  // 78.54

// Import with aliases
import { calculateCircleArea as getArea } from './utils.js';
console.log(getArea(5));  // 78.54
```

### Multiple Imports

```javascript
// Import from multiple modules
import { add, subtract } from './math.js';
import { capitalize, reverse } from './string-utils.js';
import { User, Product } from './models.js';

const result = add(10, 5);
const name = capitalize('alice');
const user = new User(name);
```

---

## Default Exports and Imports

Default exports are used when a module exports a single main value.

### Default Export Syntax

```javascript
// logger.js - Function as default
export default function log(message) {
  console.log(`[LOG] ${message}`);
}

// calculator.js - Class as default
export default class Calculator {
  add(a, b) {
    return a + b;
  }

  multiply(a, b) {
    return a * b;
  }
}

// config.js - Object as default
export default {
  apiUrl: 'https://api.example.com',
  timeout: 5000,
  retries: 3
};
```

### Importing Default Exports

```javascript
// Import with any name (no curly braces)
import log from './logger.js';
log('Application started');

import Calculator from './calculator.js';
const calc = new Calculator();

import config from './config.js';
console.log(config.apiUrl);

// Can name it anything
import myLogger from './logger.js';
myLogger('Different name');
```

### Anonymous Default Exports

```javascript
// Unnamed function
export default function(x, y) {
  return x + y;
}

// Unnamed class
export default class {
  constructor(value) {
    this.value = value;
  }
}
```

---

## Mixed Exports

A module can have both named and default exports.

### Exporting Both

```javascript
// http-client.js
export default class HttpClient {
  constructor(baseUrl) {
    this.baseUrl = baseUrl;
  }

  async get(endpoint) {
    const response = await fetch(`${this.baseUrl}${endpoint}`);
    return response.json();
  }

  async post(endpoint, data) {
    const response = await fetch(`${this.baseUrl}${endpoint}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    });
    return response.json();
  }
}

// Named exports for utilities
export const HTTP_METHODS = {
  GET: 'GET',
  POST: 'POST',
  PUT: 'PUT',
  DELETE: 'DELETE'
};

export function createHeaders(token) {
  return {
    'Authorization': `Bearer ${token}`,
    'Content-Type': 'application/json'
  };
}
```

### Importing Mixed Exports

```javascript
// Import default and named in one statement
import HttpClient, { HTTP_METHODS, createHeaders } from './http-client.js';

const client = new HttpClient('https://api.example.com');
const headers = createHeaders('my-token');

console.log(HTTP_METHODS.GET);  // 'GET'
```

### Best Practices for Mixed Exports

```javascript
// ✅ GOOD: Default export is the main functionality
export default class UserService {
  // Main class
}

export const USER_ROLES = ['admin', 'user', 'guest'];  // Supporting constant
export function validateUser(user) { /* ... */ }       // Supporting function

// ❌ AVOID: Too many exports makes default unclear
export default function something() {}
export const a = 1;
export const b = 2;
export const c = 3;
export const d = 4;
// ... too many named exports dilutes the "default"
```

---

## Re-exporting

Re-exporting allows you to aggregate exports from multiple modules into a single module.

### Basic Re-exporting

```javascript
// models/user.js
export class User {
  constructor(name) {
    this.name = name;
  }
}

// models/product.js
export class Product {
  constructor(name, price) {
    this.name = name;
    this.price = price;
  }
}

// models/index.js - Aggregates all models
export { User } from './user.js';
export { Product } from './product.js';

// Now you can import from one place
import { User, Product } from './models/index.js';
```

### Re-export All

```javascript
// utils/string.js
export const capitalize = (str) => str.charAt(0).toUpperCase() + str.slice(1);
export const reverse = (str) => str.split('').reverse().join('');

// utils/number.js
export const isEven = (n) => n % 2 === 0;
export const isOdd = (n) => n % 2 !== 0;

// utils/index.js - Re-export everything
export * from './string.js';
export * from './number.js';

// Usage
import { capitalize, isEven } from './utils/index.js';
```

### Re-export with Rename

```javascript
// shapes/rectangle.js
export class Rectangle { /* ... */ }

// shapes/circle.js
export class Circle { /* ... */ }

// shapes/index.js
export { Rectangle as Rect } from './rectangle.js';
export { Circle } from './circle.js';

// Usage
import { Rect, Circle } from './shapes/index.js';
```

### Re-export Default as Named

```javascript
// logger.js
export default function log(message) {
  console.log(message);
}

// index.js - Re-export default as named
export { default as logger } from './logger.js';

// Usage
import { logger } from './index.js';
logger('Hello');
```

### Barrel Pattern

```javascript
// services/auth.service.js
export class AuthService { /* ... */ }

// services/user.service.js
export class UserService { /* ... */ }

// services/product.service.js
export class ProductService { /* ... */ }

// services/index.js - Barrel file
export * from './auth.service.js';
export * from './user.service.js';
export * from './product.service.js';

// Clean imports
import { AuthService, UserService, ProductService } from './services/index.js';
```

---

## Dynamic Imports

Dynamic imports allow you to load modules on-demand at runtime, enabling code splitting and lazy loading.

### Basic Dynamic Import

```javascript
// Static import (loaded immediately)
import { heavyFunction } from './heavy-module.js';

// Dynamic import (loaded when needed)
async function loadModule() {
  const module = await import('./heavy-module.js');
  module.heavyFunction();
}
```

### Conditional Loading

```javascript
async function loadFeature(featureName) {
  if (featureName === 'charts') {
    const chartModule = await import('./charts.js');
    return chartModule.createChart();
  } else if (featureName === 'maps') {
    const mapModule = await import('./maps.js');
    return mapModule.createMap();
  }
}

// Usage
const feature = await loadFeature('charts');
```

### Lazy Loading for Performance

```javascript
// Button click handler that loads module on demand
document.getElementById('loadData').addEventListener('click', async () => {
  // Module is only loaded when button is clicked
  const { processData } = await import('./data-processor.js');

  const data = await fetch('/api/data').then(r => r.json());
  const result = processData(data);

  console.log(result);
});
```

### Dynamic Import with Variables

```javascript
async function loadLanguage(lang) {
  try {
    const messages = await import(`./locales/${lang}.js`);
    return messages.default;
  } catch (error) {
    console.error(`Failed to load language: ${lang}`);
    return await import('./locales/en.js').then(m => m.default);
  }
}

const translations = await loadLanguage('es');
console.log(translations.greeting);
```

### Error Handling

```javascript
async function safeImport(modulePath) {
  try {
    const module = await import(modulePath);
    return { success: true, module };
  } catch (error) {
    console.error(`Failed to import ${modulePath}:`, error);
    return { success: false, error };
  }
}

const result = await safeImport('./optional-feature.js');
if (result.success) {
  result.module.initialize();
}
```

### Code Splitting Example

```javascript
// router.js
const routes = {
  '/home': () => import('./pages/home.js'),
  '/about': () => import('./pages/about.js'),
  '/contact': () => import('./pages/contact.js')
};

async function navigateTo(path) {
  const loadPage = routes[path];
  if (loadPage) {
    const page = await loadPage();
    page.render();
  }
}

// Only the current page is loaded
navigateTo('/home');
```

---

## Module Patterns

### Singleton Pattern

```javascript
// database.js - Singleton
class Database {
  constructor() {
    if (Database.instance) {
      return Database.instance;
    }

    this.connection = null;
    this.connected = false;
    Database.instance = this;
  }

  connect(connectionString) {
    if (!this.connected) {
      console.log(`Connecting to ${connectionString}`);
      this.connected = true;
    }
  }

  query(sql) {
    if (!this.connected) {
      throw new Error('Not connected to database');
    }
    console.log(`Executing: ${sql}`);
  }
}

// Export singleton instance
export default new Database();

// Usage
import db from './database.js';
db.connect('mongodb://localhost');
db.query('SELECT * FROM users');
```

### Factory Pattern

```javascript
// user-factory.js
class User {
  constructor(name, email) {
    this.name = name;
    this.email = email;
    this.role = 'user';
  }
}

class Admin extends User {
  constructor(name, email) {
    super(name, email);
    this.role = 'admin';
    this.permissions = ['read', 'write', 'delete'];
  }
}

export class UserFactory {
  static createUser(type, name, email) {
    switch (type) {
      case 'admin':
        return new Admin(name, email);
      case 'user':
      default:
        return new User(name, email);
    }
  }
}

// Usage
import { UserFactory } from './user-factory.js';
const admin = UserFactory.createUser('admin', 'Alice', 'alice@example.com');
```

### Module Revealing Pattern

```javascript
// analytics.js
const events = [];
let sessionId = null;

function generateSessionId() {
  return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

function trackEvent(eventName, data) {
  events.push({
    eventName,
    data,
    timestamp: Date.now(),
    sessionId: sessionId || (sessionId = generateSessionId())
  });
}

function getEvents() {
  return [...events];  // Return copy
}

function clearEvents() {
  events.length = 0;
}

// Only expose what should be public
export { trackEvent, getEvents, clearEvents };

// generateSessionId and events array are private
```

### Namespace Pattern

```javascript
// constants.js
export const HTTP_STATUS = {
  OK: 200,
  CREATED: 201,
  BAD_REQUEST: 400,
  UNAUTHORIZED: 401,
  NOT_FOUND: 404,
  SERVER_ERROR: 500
};

export const COLORS = {
  PRIMARY: '#007bff',
  SUCCESS: '#28a745',
  DANGER: '#dc3545',
  WARNING: '#ffc107'
};

export const ROUTES = {
  HOME: '/',
  LOGIN: '/login',
  DASHBOARD: '/dashboard',
  PROFILE: '/profile'
};

// Usage
import { HTTP_STATUS, COLORS, ROUTES } from './constants.js';
console.log(HTTP_STATUS.OK);  // 200
```

---

## Circular Dependencies

Circular dependencies occur when two modules import each other. While ES Modules handle this better than CommonJS, it's still best to avoid.

### Circular Dependency Problem

```javascript
// a.js
import { b } from './b.js';
export const a = 'A';
console.log('In a.js:', b);  // undefined (b.js not fully loaded yet)

// b.js
import { a } from './a.js';
export const b = 'B';
console.log('In b.js:', a);  // undefined (a.js not fully loaded yet)

// main.js
import { a } from './a.js';
import { b } from './b.js';
// Both may be undefined due to circular dependency
```

### Solution 1: Restructure Code

```javascript
// shared.js - Extract common dependency
export const shared = 'Shared value';

// a.js
import { shared } from './shared.js';
export const a = `A uses ${shared}`;

// b.js
import { shared } from './shared.js';
export const b = `B uses ${shared}`;

// No circular dependency
```

### Solution 2: Dependency Injection

```javascript
// a.js
export class ServiceA {
  constructor(serviceB = null) {
    this.serviceB = serviceB;
  }

  setServiceB(serviceB) {
    this.serviceB = serviceB;
  }

  doSomething() {
    if (this.serviceB) {
      return this.serviceB.helper();
    }
  }
}

// b.js
export class ServiceB {
  helper() {
    return 'Helper result';
  }
}

// main.js - Wire dependencies
import { ServiceA } from './a.js';
import { ServiceB } from './b.js';

const serviceB = new ServiceB();
const serviceA = new ServiceA();
serviceA.setServiceB(serviceB);
```

### Solution 3: Use Events/Observers

```javascript
// event-bus.js
class EventBus {
  constructor() {
    this.listeners = new Map();
  }

  on(event, callback) {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, []);
    }
    this.listeners.get(event).push(callback);
  }

  emit(event, data) {
    const callbacks = this.listeners.get(event) || [];
    callbacks.forEach(callback => callback(data));
  }
}

export default new EventBus();

// a.js
import eventBus from './event-bus.js';

export function doA() {
  eventBus.emit('a-done', { message: 'A completed' });
}

// b.js
import eventBus from './event-bus.js';

eventBus.on('a-done', (data) => {
  console.log('B received:', data);
});

export function doB() {
  // Do something
}

// No direct circular dependency
```

---

## Module Configuration

### Node.js ESM Setup

**package.json:**
```json
{
  "name": "my-project",
  "version": "1.0.0",
  "type": "module",
  "main": "index.js",
  "scripts": {
    "start": "node index.js"
  }
}
```

### File Extensions

```javascript
// With "type": "module" in package.json

// .js files are ES Modules
import { something } from './module.js';

// .cjs files are CommonJS
const something = require('./legacy.cjs');

// .mjs files are explicitly ES Modules
import { explicit } from './explicit.mjs';
```

### Mixed CJS and ESM

```javascript
// esm-wrapper.mjs
import { createRequire } from 'module';
const require = createRequire(import.meta.url);

// Now can require CommonJS modules
const cjsModule = require('./legacy-module.cjs');

export default cjsModule;
```

### Import Maps (Browser)

```html
<!-- index.html -->
<script type="importmap">
{
  "imports": {
    "lodash": "https://cdn.skypack.dev/lodash",
    "@/utils": "/src/utils/index.js",
    "@/components": "/src/components/index.js"
  }
}
</script>

<script type="module">
  import _ from 'lodash';
  import { formatDate } from '@/utils';
</script>
```

---

## Worked Examples

### Example 1: Express API with Modules

```javascript
// config/database.js
export const dbConfig = {
  host: process.env.DB_HOST || 'localhost',
  port: process.env.DB_PORT || 5432,
  database: process.env.DB_NAME || 'myapp',
  user: process.env.DB_USER || 'postgres',
  password: process.env.DB_PASSWORD || 'password'
};

// models/user.model.js
export class User {
  constructor(data) {
    this.id = data.id;
    this.username = data.username;
    this.email = data.email;
  }

  static async findById(id) {
    // Database query logic
    return new User({ id, username: 'alice', email: 'alice@example.com' });
  }

  static async create(userData) {
    // Create user logic
    return new User({ id: Date.now(), ...userData });
  }
}

// services/user.service.js
import { User } from '../models/user.model.js';

export class UserService {
  async getUser(id) {
    return await User.findById(id);
  }

  async createUser(userData) {
    const user = await User.create(userData);
    // Send welcome email, etc.
    return user;
  }
}

// controllers/user.controller.js
import { UserService } from '../services/user.service.js';

const userService = new UserService();

export const getUser = async (req, res) => {
  try {
    const user = await userService.getUser(req.params.id);
    res.json(user);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

export const createUser = async (req, res) => {
  try {
    const user = await userService.createUser(req.body);
    res.status(201).json(user);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
};

// routes/user.routes.js
import express from 'express';
import { getUser, createUser } from '../controllers/user.controller.js';

const router = express.Router();

router.get('/:id', getUser);
router.post('/', createUser);

export default router;

// app.js
import express from 'express';
import userRoutes from './routes/user.routes.js';

const app = express();

app.use(express.json());
app.use('/api/users', userRoutes);

export default app;

// index.js
import app from './app.js';
import { dbConfig } from './config/database.js';

const PORT = process.env.PORT || 3000;

app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
  console.log('Database:', dbConfig.database);
});
```

### Example 2: Plugin System

```javascript
// plugin-system.js
export class PluginSystem {
  constructor() {
    this.plugins = new Map();
  }

  async loadPlugin(name, path) {
    try {
      const plugin = await import(path);

      if (typeof plugin.default?.initialize !== 'function') {
        throw new Error('Plugin must export initialize function');
      }

      this.plugins.set(name, plugin.default);
      await plugin.default.initialize();

      console.log(`Plugin "${name}" loaded successfully`);
    } catch (error) {
      console.error(`Failed to load plugin "${name}":`, error);
    }
  }

  getPlugin(name) {
    return this.plugins.get(name);
  }

  async executePlugin(name, method, ...args) {
    const plugin = this.plugins.get(name);

    if (!plugin) {
      throw new Error(`Plugin "${name}" not found`);
    }

    if (typeof plugin[method] !== 'function') {
      throw new Error(`Method "${method}" not found in plugin "${name}"`);
    }

    return await plugin[method](...args);
  }
}

// plugins/logger-plugin.js
export default {
  name: 'Logger',

  async initialize() {
    console.log('Logger plugin initialized');
  },

  log(message) {
    console.log(`[PLUGIN-LOG] ${message}`);
  },

  error(message) {
    console.error(`[PLUGIN-ERROR] ${message}`);
  }
};

// plugins/analytics-plugin.js
export default {
  name: 'Analytics',
  events: [],

  async initialize() {
    console.log('Analytics plugin initialized');
  },

  track(eventName, data) {
    this.events.push({ eventName, data, timestamp: Date.now() });
    console.log(`Tracked: ${eventName}`);
  },

  getEvents() {
    return [...this.events];
  }
};

// main.js
import { PluginSystem } from './plugin-system.js';

const plugins = new PluginSystem();

await plugins.loadPlugin('logger', './plugins/logger-plugin.js');
await plugins.loadPlugin('analytics', './plugins/analytics-plugin.js');

// Use plugins
await plugins.executePlugin('logger', 'log', 'Application started');
await plugins.executePlugin('analytics', 'track', 'app.start', { user: 'alice' });

const events = await plugins.executePlugin('analytics', 'getEvents');
console.log('Events:', events);
```

### Example 3: Multi-Environment Configuration

```javascript
// config/base.js
export default {
  app: {
    name: 'MyApp',
    version: '1.0.0'
  },
  server: {
    port: 3000
  }
};

// config/development.js
export default {
  database: {
    host: 'localhost',
    port: 5432,
    name: 'myapp_dev'
  },
  logging: {
    level: 'debug'
  },
  cache: {
    enabled: false
  }
};

// config/production.js
export default {
  database: {
    host: process.env.DB_HOST,
    port: process.env.DB_PORT,
    name: process.env.DB_NAME
  },
  logging: {
    level: 'error'
  },
  cache: {
    enabled: true,
    ttl: 3600
  }
};

// config/index.js
import base from './base.js';

const env = process.env.NODE_ENV || 'development';

async function loadConfig() {
  const envConfig = await import(`./${env}.js`);

  return {
    ...base,
    ...envConfig.default,
    env
  };
}

export default await loadConfig();

// app.js
import config from './config/index.js';

console.log('Environment:', config.env);
console.log('Database:', config.database.host);
console.log('Logging level:', config.logging.level);
```

---

## Exercises

### Exercise 1: Math Utilities Module (Easy)

Create a math utilities module with named and default exports.

**Requirements:**
- File: `math-utils.js`
- Named exports:
  - `add(a, b)` - returns sum
  - `subtract(a, b)` - returns difference
  - `multiply(a, b)` - returns product
  - `divide(a, b)` - returns quotient (handle division by zero)
  - `MATH_CONSTANTS` object with `PI`, `E`, `GOLDEN_RATIO`
- Default export: `Calculator` class with methods for all operations
- Create `main.js` that imports and uses both named and default exports

**Example:**
```javascript
import Calculator, { add, MATH_CONSTANTS } from './math-utils.js';

console.log(add(5, 3));  // 8
console.log(MATH_CONSTANTS.PI);  // 3.14159...

const calc = new Calculator();
console.log(calc.add(5, 3));  // 8
```

---

### Exercise 2: User Management System (Medium)

Build a modular user management system with separate concerns.

**Requirements:**
- `models/user.js`: User class with properties and validation
- `services/user-service.js`: UserService class with CRUD operations
- `utils/validators.js`: Validation functions (email, password, username)
- `utils/formatters.js`: Format user data for display
- `index.js`: Barrel file re-exporting everything
- `app.js`: Demo using the system

Must handle:
- User creation with validation
- Email format validation
- Password strength validation (min 8 chars, 1 uppercase, 1 number)
- Username uniqueness
- User listing and search

**Example:**
```javascript
import { UserService, validators } from './index.js';

const service = new UserService();
const user = service.createUser({
  username: 'alice',
  email: 'alice@example.com',
  password: 'SecurePass123'
});
```

---

### Exercise 3: Plugin Architecture (Medium)

Create a plugin system that dynamically loads and executes plugins.

**Requirements:**
- `plugin-manager.js`: PluginManager class
  - `loadPlugin(name, path)` - dynamic import
  - `unloadPlugin(name)`
  - `executePlugin(name, method, ...args)`
  - `listPlugins()`
- Create 3 plugins:
  - `logger-plugin.js`: Logging with different levels
  - `cache-plugin.js`: Simple key-value cache with TTL
  - `validator-plugin.js`: Data validation rules
- Each plugin must export: `name`, `version`, `initialize()`, and custom methods
- Handle plugin errors gracefully

**Example:**
```javascript
const manager = new PluginManager();
await manager.loadPlugin('logger', './plugins/logger.js');
await manager.executePlugin('logger', 'info', 'App started');
```

---

### Exercise 4: Multi-Environment Config System (Hard)

Build a configuration system that loads different configs based on environment.

**Requirements:**
- `config/base.js`: Base configuration (shared across all environments)
- `config/development.js`: Development-specific config
- `config/staging.js`: Staging-specific config
- `config/production.js`: Production-specific config
- `config/loader.js`: Dynamic config loader
  - Merges base with environment-specific
  - Validates required fields
  - Supports config overrides via environment variables
  - Type checking for config values
- `config/index.js`: Exports loaded config
- Should support: database, server, logging, cache, api settings

**Example:**
```javascript
import config from './config/index.js';

console.log(config.database.host);  // Different per environment
console.log(config.server.port);    // 3000 (dev) or 8080 (prod)
```

---

### Exercise 5: Module Bundle Analyzer (Hard)

Create a tool that analyzes module dependencies in a project.

**Requirements:**
- `analyzer.js`: Main analyzer class
  - `analyzefile(path)` - parse imports/exports
  - `buildDependencyGraph()` - create graph
  - `findCircularDependencies()` - detect cycles
  - `getModuleStats()` - count imports/exports per module
  - `generateReport()` - formatted report
- Parse both `import` and `export` statements
- Handle named, default, and dynamic imports
- Detect circular dependencies
- Count direct and transitive dependencies
- Generate visual tree or graph representation

**Example:**
```javascript
const analyzer = new ModuleAnalyzer('./src');
await analyzer.analyze();

const circular = analyzer.findCircularDependencies();
console.log('Circular dependencies:', circular);

const report = analyzer.generateReport();
console.log(report);
```

---

### Exercise 6: Lazy Loading Router (Advanced)

Build a simple router with lazy-loaded route modules.

**Requirements:**
- `router.js`: Router class
  - `register(path, loader)` - register route with dynamic import
  - `navigate(path, params)` - load and execute route
  - `preload(path)` - pre-fetch route module
  - `getLoadedRoutes()` - list currently loaded routes
- Route modules should export: `handler`, `beforeEnter`, `afterLeave`
- Support route parameters: `/users/:id`
- Cache loaded modules
- Handle navigation errors
- Support route guards (authentication, etc.)

**Example:**
```javascript
const router = new Router();

router.register('/home', () => import('./routes/home.js'));
router.register('/users/:id', () => import('./routes/user-detail.js'));

await router.navigate('/home');
await router.navigate('/users/123', { id: 123 });
```

---

## Testing & Verification

### Testing Modules

```javascript
// math.js
export const add = (a, b) => a + b;
export const multiply = (a, b) => a * b;

// math.test.js
import { describe, it, expect } from 'vitest';
import { add, multiply } from './math.js';

describe('Math utilities', () => {
  describe('add()', () => {
    it('should add two numbers', () => {
      expect(add(2, 3)).toBe(5);
    });
  });

  describe('multiply()', () => {
    it('should multiply two numbers', () => {
      expect(multiply(4, 5)).toBe(20);
    });
  });
});
```

### Mocking Modules

```javascript
// user-service.test.js
import { describe, it, expect, vi } from 'vitest';
import { UserService } from './user-service.js';

// Mock database module
vi.mock('./database.js', () => ({
  query: vi.fn(() => Promise.resolve([{ id: 1, name: 'Alice' }]))
}));

describe('UserService', () => {
  it('should fetch users', async () => {
    const service = new UserService();
    const users = await service.getUsers();

    expect(users).toHaveLength(1);
    expect(users[0].name).toBe('Alice');
  });
});
```

---

## Best Practices

### 1. One Module, One Responsibility

```javascript
// ✅ GOOD: Focused module
// user-validator.js
export function validateEmail(email) { /* ... */ }
export function validatePassword(password) { /* ... */ }

// ❌ AVOID: Too many responsibilities
// utils.js
export function validateEmail() {}
export function formatDate() {}
export function calculateTax() {}
export function makeHttpRequest() {}
```

### 2. Use Barrel Files for Clean Imports

```javascript
// ✅ GOOD: Barrel file
// components/index.js
export { Button } from './button.js';
export { Input } from './input.js';
export { Modal } from './modal.js';

// Usage
import { Button, Input, Modal } from './components/index.js';

// ❌ AVOID: Multiple import statements
import { Button } from './components/button.js';
import { Input } from './components/input.js';
import { Modal } from './components/modal.js';
```

### 3. Prefer Named Exports

```javascript
// ✅ GOOD: Named exports are explicit
export const config = { /* ... */ };
export function initialize() { /* ... */ }

// ⚠️ OK: Default export for main module export
export default class UserService { /* ... */ }
```

### 4. Avoid Deep Relative Imports

```javascript
// ❌ AVOID: Deep relative paths
import { utils } from '../../../utils/helpers.js';

// ✅ BETTER: Use path aliases or barrel files
import { utils } from '@/utils';
```

### 5. Always Include File Extensions

```javascript
// ✅ CORRECT: Include .js extension
import { add } from './math.js';

// ❌ WRONG: Missing extension (may work in Node with bundlers, but not standard)
import { add } from './math';
```

---

## Common Pitfalls

### 1. Circular Dependencies

```javascript
// ❌ PROBLEM
// a.js
import { b } from './b.js';
export const a = b + 1;

// b.js
import { a } from './a.js';
export const b = a + 1;

// ✅ SOLUTION: Restructure to avoid cycle
```

### 2. Mixing Default and Named Exports Unclearly

```javascript
// ⚠️ CONFUSING
export default function main() {}
export const helper1 = () => {};
export const helper2 = () => {};
export const helper3 = () => {};

// ✅ CLEARER: Make intent obvious
export default class MainService {
  // Main functionality
}

// Supporting utilities
export const CONSTANTS = {};
export function helper() {}
```

### 3. Side Effects in Modules

```javascript
// ❌ AVOID: Side effects on import
// config.js
console.log('Config loaded');  // Runs on import!
export const config = loadConfig();

// ✅ BETTER: Explicit initialization
export function initialize() {
  console.log('Config loaded');
}

export const config = loadConfig();
```

### 4. Forgetting 'type': 'module' in Node.js

```javascript
// Without "type": "module" in package.json:
// ❌ SyntaxError: Cannot use import statement outside a module

// Solutions:
// 1. Add "type": "module" to package.json
// 2. Use .mjs extension
// 3. Use CommonJS (require)
```

---

## Summary & Next Steps

### Key Takeaways

- ES Modules provide clean syntax for code organization
- Named exports for multiple values, default for main export
- Re-exporting enables module aggregation
- Dynamic imports enable code splitting and lazy loading
- Circular dependencies should be avoided through restructuring
- Proper module patterns improve maintainability

### When to Use Each Pattern

- **Named exports:** Multiple utilities, clear API
- **Default exports:** Single main class/function per module
- **Re-exporting:** Barrel files, public API definition
- **Dynamic imports:** Code splitting, conditional loading

### Related Topics

- [Classes](../11.Classes_and_inheritance/18.Classes.md)
- [Iterators and Generators](./21.Iterators_And_Generators.md)
- [Async/Await](../async/async-await.md)

### Further Reading

- [MDN: JavaScript Modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules)
- [Node.js ESM Documentation](https://nodejs.org/api/esm.html)
- [ES Modules: A Cartoon Deep Dive](https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/)

---

## References

- **ECMAScript Specification:** [Modules](https://tc39.es/ecma262/#sec-modules)
- **MDN Web Docs:** [import](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import)
- **MDN Web Docs:** [export](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export)
- **Node.js:** [ES Modules](https://nodejs.org/api/esm.html)

---

**Practice Exercise:** Build a complete REST API backend using ES Modules with proper separation of routes, controllers, services, and models.

**Next Lesson:** [21.Iterators_And_Generators.md](./21.Iterators_And_Generators.md) - Master iteration protocols and generator functions.
