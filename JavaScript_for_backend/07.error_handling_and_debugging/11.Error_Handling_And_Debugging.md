# Error Handling and Debugging

**Difficulty:** Intermediate
**Estimated Time:** 45-60 minutes
**Prerequisites:** Node.js 18+, understanding of functions, async/await, and promises
**Target:** Node.js 18+ LTS, Browsers (Chrome 90+, Firefox 88+, Safari 14+)

---

## Learning Objectives

By the end of this lesson, you will be able to:

1. Understand JavaScript error types and when each occurs
2. Implement robust error handling using try-catch-finally blocks
3. Create custom error classes for domain-specific error handling
4. Handle errors in asynchronous code (promises and async/await)
5. Debug code effectively using browser and Node.js tools
6. Read and interpret stack traces to locate bugs
7. Apply defensive programming and input validation patterns
8. Implement error logging and monitoring for production applications
9. Use error recovery strategies and graceful degradation
10. Test error paths in your application code

---

## Table of Contents

1. [Introduction](#introduction)
2. [Types of Errors in JavaScript](#types-of-errors-in-javascript)
3. [Try-Catch-Finally](#try-catch-finally)
4. [Throwing Errors](#throwing-errors)
5. [Custom Error Classes](#custom-error-classes)
6. [Error Propagation](#error-propagation)
7. [Async Error Handling](#async-error-handling)
8. [Global Error Handlers](#global-error-handlers)
9. [Debugging Tools and Techniques](#debugging-tools-and-techniques)
10. [Reading Stack Traces](#reading-stack-traces)
11. [Error Recovery Strategies](#error-recovery-strategies)
12. [Input Validation and Defensive Programming](#input-validation-and-defensive-programming)
13. [Production Error Logging](#production-error-logging)
14. [Worked Examples](#worked-examples)
15. [Exercises](#exercises)
16. [Common Pitfalls](#common-pitfalls)
17. [Testing Error Cases](#testing-error-cases)
18. [Summary & Next Steps](#summary--next-steps)
19. [References](#references)

---

## Introduction

Error handling is one of the most critical aspects of professional software development. Well-written error handling code:

- **Prevents crashes** - Applications continue running even when errors occur
- **Improves user experience** - Users see helpful messages instead of cryptic errors
- **Aids debugging** - Developers can quickly identify and fix issues
- **Ensures data integrity** - Failed operations don't corrupt application state
- **Enables monitoring** - Teams can track and address production issues

JavaScript errors come in many forms: syntax errors caught before execution, runtime errors that crash your code, logical errors producing wrong results, and asynchronous errors that may go unnoticed. This lesson teaches you to handle all of them professionally.

---

## Types of Errors in JavaScript

JavaScript has several built-in error types, each indicating a different kind of problem:

### 1. SyntaxError

Occurs when code violates JavaScript syntax rules. These are caught during parsing, before execution.

```javascript
// SyntaxError: Unexpected token
const broken = ;

// SyntaxError: missing ) after argument list
console.log("hello";

// SyntaxError: Unexpected end of input
if (true) {
  console.log("missing closing brace");
```

### 2. ReferenceError

Occurs when accessing a variable or function that doesn't exist.

```javascript
console.log(nonExistentVariable); // ReferenceError: nonExistentVariable is not defined

const user = { name: 'Alice' };
console.log(user.address.city); // ReferenceError if address is undefined
```

### 3. TypeError

Occurs when a value is not of the expected type or an operation is invalid.

```javascript
const num = 42;
num.toUpperCase(); // TypeError: num.toUpperCase is not a function

const obj = null;
obj.property; // TypeError: Cannot read property 'property' of null

const notAFunction = 'hello';
notAFunction(); // TypeError: notAFunction is not a function
```

### 4. RangeError

Occurs when a numeric value is outside the allowed range.

```javascript
const arr = new Array(-1); // RangeError: Invalid array length

const num = (100).toPrecision(500); // RangeError: toPrecision() argument must be between 1 and 100

function recurse() {
  recurse();
}
recurse(); // RangeError: Maximum call stack size exceeded
```

### 5. URIError

Occurs when global URI handling functions are used incorrectly.

```javascript
decodeURIComponent('%'); // URIError: URI malformed
```

### 6. EvalError

Historically used for errors with `eval()`, rarely seen in modern JavaScript.

---

## Try-Catch-Finally

The `try-catch-finally` statement lets you handle errors gracefully without crashing your program.

### Basic Syntax

```javascript
try {
  // Code that might throw an error
  const result = riskyOperation();
} catch (error) {
  // Handle the error
  console.error('An error occurred:', error.message);
} finally {
  // Always executes, regardless of error
  cleanup();
}
```

### The Error Object

When an error is caught, the error object contains useful properties:

```javascript
try {
  throw new Error('Something went wrong');
} catch (error) {
  console.log(error.name);      // "Error"
  console.log(error.message);   // "Something went wrong"
  console.log(error.stack);     // Stack trace string
}
```

### Finally Block

The `finally` block always executes, even if there's a `return` statement:

```javascript
const divide = (a, b) => {
  try {
    if (b === 0) throw new Error('Division by zero');
    return a / b;
  } catch (error) {
    console.error('Error:', error.message);
    return null;
  } finally {
    console.log('Division operation completed');
  }
};

divide(10, 2);  // Logs "Division operation completed", returns 5
divide(10, 0);  // Logs error and "Division operation completed", returns null
```

### Nested Try-Catch

```javascript
try {
  try {
    throw new Error('Inner error');
  } catch (innerError) {
    console.log('Caught inner:', innerError.message);
    throw new Error('Outer error'); // Re-throw or throw new error
  }
} catch (outerError) {
  console.log('Caught outer:', outerError.message);
}
```

---

## Throwing Errors

You can manually throw errors using the `throw` statement.

### Throwing Built-in Errors

```javascript
const validateAge = age => {
  if (typeof age !== 'number') {
    throw new TypeError('Age must be a number');
  }

  if (age < 0 || age > 150) {
    throw new RangeError('Age must be between 0 and 150');
  }

  return true;
};

try {
  validateAge('25'); // Throws TypeError
} catch (error) {
  console.error(error.name, ':', error.message);
}
```

### Throwing Custom Messages

```javascript
const withdraw = (balance, amount) => {
  if (amount > balance) {
    throw new Error(`Insufficient funds. Balance: ${balance}, Requested: ${amount}`);
  }
  return balance - amount;
};
```

---

## Custom Error Classes

Creating custom error classes helps you handle different error types specifically.

### Basic Custom Error

```javascript
class ValidationError extends Error {
  constructor(message) {
    super(message);
    this.name = 'ValidationError';
  }
}

class DatabaseError extends Error {
  constructor(message, query) {
    super(message);
    this.name = 'DatabaseError';
    this.query = query;
  }
}

// Usage
try {
  throw new ValidationError('Email format is invalid');
} catch (error) {
  if (error instanceof ValidationError) {
    console.log('Validation failed:', error.message);
  } else {
    console.log('Unknown error:', error);
  }
}
```

### Advanced Custom Error with Metadata

```javascript
class APIError extends Error {
  constructor(message, statusCode, endpoint) {
    super(message);
    this.name = 'APIError';
    this.statusCode = statusCode;
    this.endpoint = endpoint;
    this.timestamp = new Date().toISOString();
  }

  toJSON() {
    return {
      name: this.name,
      message: this.message,
      statusCode: this.statusCode,
      endpoint: this.endpoint,
      timestamp: this.timestamp,
    };
  }
}

// Usage
try {
  throw new APIError('Not Found', 404, '/api/users/123');
} catch (error) {
  if (error instanceof APIError) {
    console.error('API Error:', error.toJSON());
  }
}
```

---

## Error Propagation

Errors propagate up the call stack until caught. Understanding this is crucial.

```javascript
const level3 = () => {
  throw new Error('Error at level 3');
};

const level2 = () => {
  level3(); // Error propagates from here
};

const level1 = () => {
  try {
    level2(); // Error propagates through here
  } catch (error) {
    console.log('Caught at level 1:', error.message);
  }
};

level1(); // Error caught here
```

### Strategic Error Catching

Don't catch errors too early. Let them propagate to where they can be handled meaningfully.

```javascript
// ❌ WRONG: Catching too early
const readUserData = userId => {
  try {
    const data = fetchFromDatabase(userId);
    return data;
  } catch (error) {
    console.log('Error reading user'); // Too generic, loses context
    return null;
  }
};

// ✅ CORRECT: Let errors propagate
const readUserData = userId => {
  // Let errors propagate to caller who has more context
  return fetchFromDatabase(userId);
};

// Handle at application level
try {
  const user = readUserData(123);
  displayUser(user);
} catch (error) {
  if (error instanceof DatabaseError) {
    showUserMessage('Database temporarily unavailable');
  } else {
    showUserMessage('Unable to load user data');
  }
  logError(error);
}
```

---

## Async Error Handling

Asynchronous code requires special error handling techniques.

### Promises with .catch()

```javascript
const fetchUser = userId => {
  return fetch(`/api/users/${userId}`)
    .then(response => {
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
      return response.json();
    })
    .catch(error => {
      console.error('Failed to fetch user:', error);
      throw error; // Re-throw if needed
    });
};
```

### Async/Await with Try-Catch

```javascript
const fetchUser = async userId => {
  try {
    const response = await fetch(`/api/users/${userId}`);

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }

    const data = await response.json();
    return data;
  } catch (error) {
    console.error('Failed to fetch user:', error);
    throw error;
  }
};
```

### Handling Multiple Async Operations

```javascript
const fetchAllData = async () => {
  try {
    // Parallel execution
    const [users, posts, comments] = await Promise.all([
      fetch('/api/users').then(r => r.json()),
      fetch('/api/posts').then(r => r.json()),
      fetch('/api/comments').then(r => r.json()),
    ]);

    return { users, posts, comments };
  } catch (error) {
    // If any request fails, all fail
    console.error('Failed to fetch data:', error);
    throw error;
  }
};

// Alternative: Continue even if some fail
const fetchAllDataSafe = async () => {
  const [usersResult, postsResult, commentsResult] = await Promise.allSettled([
    fetch('/api/users').then(r => r.json()),
    fetch('/api/posts').then(r => r.json()),
    fetch('/api/comments').then(r => r.json()),
  ]);

  return {
    users: usersResult.status === 'fulfilled' ? usersResult.value : [],
    posts: postsResult.status === 'fulfilled' ? postsResult.value : [],
    comments: commentsResult.status === 'fulfilled' ? commentsResult.value : [],
  };
};
```

### Unhandled Promise Rejections

```javascript
// ❌ WRONG: Unhandled rejection
const fetchData = async () => {
  const response = await fetch('/api/data');
  return response.json();
};

fetchData(); // If this fails, unhandled rejection!

// ✅ CORRECT: Always handle errors
fetchData().catch(error => {
  console.error('Failed to fetch data:', error);
});
```

---

## Global Error Handlers

### Browser: window.onerror

```javascript
window.onerror = (message, source, lineno, colno, error) => {
  console.error('Global error caught:', {
    message,
    source,
    lineno,
    colno,
    error,
  });

  // Send to error tracking service
  logErrorToService(error);

  // Return true to prevent default browser error handling
  return true;
};
```

### Browser: unhandledrejection

```javascript
window.addEventListener('unhandledrejection', event => {
  console.error('Unhandled promise rejection:', event.reason);

  // Log to error tracking service
  logErrorToService(event.reason);

  // Prevent default (console error)
  event.preventDefault();
});
```

### Node.js: uncaughtException

```javascript
process.on('uncaughtException', error => {
  console.error('Uncaught exception:', error);

  // Log error
  logErrorToService(error);

  // Graceful shutdown
  process.exit(1);
});
```

### Node.js: unhandledRejection

```javascript
process.on('unhandledRejection', (reason, promise) => {
  console.error('Unhandled rejection at:', promise, 'reason:', reason);

  // Log error
  logErrorToService(reason);
});
```

---

## Debugging Tools and Techniques

### Console Methods

```javascript
// Basic logging
console.log('Basic message');
console.info('Info message');
console.warn('Warning message');
console.error('Error message');

// Structured data
const user = { name: 'Alice', age: 30, roles: ['admin', 'user'] };
console.table(user); // Displays as table
console.dir(user, { depth: null }); // Deep object inspection

// Grouping
console.group('User Details');
console.log('Name:', user.name);
console.log('Age:', user.age);
console.groupEnd();

// Stack trace
console.trace('Execution path');

// Performance timing
console.time('operation');
const result = expensiveOperation();
console.timeEnd('operation'); // Logs: "operation: 45.2ms"

// Assertions
console.assert(user.age > 18, 'User must be adult'); // Only logs if false

// Count occurrences
for (let i = 0; i < 5; i++) {
  console.count('loop'); // Logs: "loop: 1", "loop: 2", etc.
}
```

### Debugger Statement

```javascript
const calculateTotal = items => {
  let total = 0;

  debugger; // Execution pauses here if DevTools is open

  for (const item of items) {
    total += item.price * item.quantity;
  }

  return total;
};
```

### Browser DevTools

**Setting Breakpoints:**
1. Open DevTools (F12)
2. Go to Sources tab
3. Click line number to set breakpoint
4. Refresh page to trigger breakpoint

**Useful Features:**
- **Step Over (F10):** Execute current line, don't enter functions
- **Step Into (F11):** Enter function calls
- **Step Out (Shift+F11):** Exit current function
- **Watch:** Monitor specific variables
- **Call Stack:** See function call chain
- **Scope:** View local and global variables

### Node.js Debugging

```bash
# Built-in inspector
node inspect script.js

# Chrome DevTools for Node.js
node --inspect script.js
# Then open chrome://inspect in Chrome

# Break on start
node --inspect-brk script.js
```

**VS Code Debugging:**

Create `.vscode/launch.json`:

```json
{
  "version": "0.2.0",
  "configurations": [
    {
      "type": "node",
      "request": "launch",
      "name": "Debug Program",
      "program": "${workspaceFolder}/app.js",
      "skipFiles": ["<node_internals>/**"]
    }
  ]
}
```

---

## Reading Stack Traces

Stack traces show the path of execution leading to an error.

```javascript
const level3 = () => {
  throw new Error('Something went wrong');
};

const level2 = () => {
  level3();
};

const level1 = () => {
  level2();
};

try {
  level1();
} catch (error) {
  console.error(error.stack);
}
```

**Output:**
```
Error: Something went wrong
    at level3 (file.js:2:9)
    at level2 (file.js:6:3)
    at level1 (file.js:10:3)
    at file.js:14:3
```

**Reading the trace:**
- **Bottom to top:** Execution order
- **Each line:** Function name, file, line:column
- **Top line:** Where error occurred

---

## Error Recovery Strategies

### Retry with Exponential Backoff

```javascript
const retryWithBackoff = async (fn, maxRetries = 3, baseDelay = 1000) => {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error) {
      const isLastAttempt = i === maxRetries - 1;

      if (isLastAttempt) {
        throw error;
      }

      const delay = baseDelay * Math.pow(2, i);
      console.log(`Attempt ${i + 1} failed, retrying in ${delay}ms...`);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
};

// Usage
const fetchData = () => fetch('/api/data').then(r => r.json());
const data = await retryWithBackoff(fetchData, 3, 1000);
```

### Fallback Values

```javascript
const getUserName = userId => {
  try {
    const user = fetchUser(userId);
    return user.name;
  } catch (error) {
    console.error('Failed to fetch user:', error);
    return 'Anonymous User'; // Fallback
  }
};
```

### Circuit Breaker Pattern

```javascript
class CircuitBreaker {
  constructor(threshold = 5, timeout = 60000) {
    this.failureCount = 0;
    this.threshold = threshold;
    this.timeout = timeout;
    this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN
    this.nextAttempt = Date.now();
  }

  async execute(fn) {
    if (this.state === 'OPEN') {
      if (Date.now() < this.nextAttempt) {
        throw new Error('Circuit breaker is OPEN');
      }
      this.state = 'HALF_OPEN';
    }

    try {
      const result = await fn();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }

  onSuccess() {
    this.failureCount = 0;
    this.state = 'CLOSED';
  }

  onFailure() {
    this.failureCount++;
    if (this.failureCount >= this.threshold) {
      this.state = 'OPEN';
      this.nextAttempt = Date.now() + this.timeout;
    }
  }
}
```

---

## Input Validation and Defensive Programming

### Input Validation Pattern

```javascript
const createUser = userInput => {
  // Validate required fields
  if (!userInput || typeof userInput !== 'object') {
    throw new ValidationError('User input must be an object');
  }

  const { email, age, username } = userInput;

  // Email validation
  if (!email || typeof email !== 'string') {
    throw new ValidationError('Email is required and must be a string');
  }

  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailRegex.test(email)) {
    throw new ValidationError('Email format is invalid');
  }

  // Age validation
  if (age !== undefined) {
    if (typeof age !== 'number' || !Number.isInteger(age)) {
      throw new ValidationError('Age must be an integer');
    }
    if (age < 0 || age > 150) {
      throw new ValidationError('Age must be between 0 and 150');
    }
  }

  // Username validation
  if (username && typeof username !== 'string') {
    throw new ValidationError('Username must be a string');
  }

  if (username && (username.length < 3 || username.length > 20)) {
    throw new ValidationError('Username must be 3-20 characters');
  }

  return {
    email: email.toLowerCase().trim(),
    age: age || null,
    username: username?.trim() || null,
  };
};
```

### Defensive Programming

```javascript
// ✅ CORRECT: Check for null/undefined
const getUserCity = user => {
  return user?.address?.city || 'Unknown';
};

// ✅ CORRECT: Validate array operations
const getFirstItem = arr => {
  if (!Array.isArray(arr) || arr.length === 0) {
    return null;
  }
  return arr[0];
};

// ✅ CORRECT: Type checking
const formatPrice = price => {
  if (typeof price !== 'number' || !isFinite(price)) {
    throw new TypeError('Price must be a finite number');
  }
  return `$${price.toFixed(2)}`;
};
```

---

## Production Error Logging

### Basic Error Logger

```javascript
class ErrorLogger {
  constructor(config = {}) {
    this.endpoint = config.endpoint || '/api/errors';
    this.appVersion = config.appVersion || '1.0.0';
    this.environment = config.environment || 'production';
  }

  log(error, context = {}) {
    const errorData = {
      message: error.message,
      stack: error.stack,
      name: error.name,
      timestamp: new Date().toISOString(),
      appVersion: this.appVersion,
      environment: this.environment,
      userAgent: typeof navigator !== 'undefined' ? navigator.userAgent : 'N/A',
      url: typeof window !== 'undefined' ? window.location.href : 'N/A',
      context,
    };

    // Send to logging service
    this.sendToService(errorData);

    // Also log to console in development
    if (this.environment === 'development') {
      console.error('Error logged:', errorData);
    }
  }

  async sendToService(errorData) {
    try {
      await fetch(this.endpoint, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(errorData),
      });
    } catch (sendError) {
      // Fallback: log to console if service is down
      console.error('Failed to send error to logging service:', sendError);
      console.error('Original error:', errorData);
    }
  }
}

// Usage
const logger = new ErrorLogger({
  endpoint: 'https://errors.example.com/api/log',
  appVersion: '2.1.0',
  environment: process.env.NODE_ENV,
});

try {
  riskyOperation();
} catch (error) {
  logger.log(error, { userId: currentUser.id, action: 'checkout' });
}
```

---

## Worked Examples

### Example 1: Custom Error Class with Validation

**Scenario:** Building a user registration system with comprehensive error handling.

```javascript
// Custom error classes
class ValidationError extends Error {
  constructor(field, message) {
    super(message);
    this.name = 'ValidationError';
    this.field = field;
  }
}

class DuplicateUserError extends Error {
  constructor(email) {
    super(`User with email ${email} already exists`);
    this.name = 'DuplicateUserError';
    this.email = email;
  }
}

// User registration service
class UserService {
  constructor() {
    this.users = new Map(); // Simulated database
  }

  validateEmail(email) {
    if (!email || typeof email !== 'string') {
      throw new ValidationError('email', 'Email is required');
    }

    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      throw new ValidationError('email', 'Invalid email format');
    }

    return email.toLowerCase().trim();
  }

  validatePassword(password) {
    if (!password || typeof password !== 'string') {
      throw new ValidationError('password', 'Password is required');
    }

    if (password.length < 8) {
      throw new ValidationError('password', 'Password must be at least 8 characters');
    }

    if (!/[A-Z]/.test(password)) {
      throw new ValidationError('password', 'Password must contain uppercase letter');
    }

    if (!/[0-9]/.test(password)) {
      throw new ValidationError('password', 'Password must contain a number');
    }

    return password;
  }

  async register(email, password) {
    try {
      // Validate inputs
      const validEmail = this.validateEmail(email);
      const validPassword = this.validatePassword(password);

      // Check for duplicate
      if (this.users.has(validEmail)) {
        throw new DuplicateUserError(validEmail);
      }

      // Create user
      const user = {
        id: Date.now().toString(),
        email: validEmail,
        password: validPassword, // In reality, hash this!
        createdAt: new Date().toISOString(),
      };

      this.users.set(validEmail, user);
      return { success: true, userId: user.id };

    } catch (error) {
      if (error instanceof ValidationError) {
        return {
          success: false,
          error: 'VALIDATION_ERROR',
          field: error.field,
          message: error.message,
        };
      }

      if (error instanceof DuplicateUserError) {
        return {
          success: false,
          error: 'DUPLICATE_USER',
          message: error.message,
        };
      }

      // Unexpected error
      console.error('Unexpected error during registration:', error);
      return {
        success: false,
        error: 'INTERNAL_ERROR',
        message: 'An unexpected error occurred',
      };
    }
  }
}

// Usage demonstration
const userService = new UserService();

const testRegistration = async () => {
  // Test 1: Valid registration
  console.log(await userService.register('alice@example.com', 'SecurePass123'));
  // { success: true, userId: '...' }

  // Test 2: Invalid email
  console.log(await userService.register('invalid-email', 'SecurePass123'));
  // { success: false, error: 'VALIDATION_ERROR', field: 'email', ... }

  // Test 3: Weak password
  console.log(await userService.register('bob@example.com', 'weak'));
  // { success: false, error: 'VALIDATION_ERROR', field: 'password', ... }

  // Test 4: Duplicate user
  console.log(await userService.register('alice@example.com', 'AnotherPass456'));
  // { success: false, error: 'DUPLICATE_USER', ... }
};

testRegistration();
```

### Example 2: Retry Logic with Exponential Backoff

**Scenario:** API calls that may fail temporarily need retry logic.

```javascript
class RetryableError extends Error {
  constructor(message, isRetryable = true) {
    super(message);
    this.name = 'RetryableError';
    this.isRetryable = isRetryable;
  }
}

class APIClient {
  constructor(baseURL, options = {}) {
    this.baseURL = baseURL;
    this.maxRetries = options.maxRetries || 3;
    this.baseDelay = options.baseDelay || 1000;
    this.timeout = options.timeout || 5000;
  }

  async retryWithBackoff(fn, attempt = 0) {
    try {
      return await fn();
    } catch (error) {
      const isLastAttempt = attempt >= this.maxRetries - 1;

      // Don't retry on non-retryable errors
      if (error instanceof RetryableError && !error.isRetryable) {
        throw error;
      }

      // Don't retry on client errors (4xx)
      if (error.statusCode >= 400 && error.statusCode < 500) {
        throw error;
      }

      if (isLastAttempt) {
        throw new Error(`Failed after ${this.maxRetries} attempts: ${error.message}`);
      }

      // Calculate delay with exponential backoff and jitter
      const exponentialDelay = this.baseDelay * Math.pow(2, attempt);
      const jitter = Math.random() * 1000;
      const delay = exponentialDelay + jitter;

      console.log(`Attempt ${attempt + 1} failed, retrying in ${Math.round(delay)}ms...`);
      console.log(`Error: ${error.message}`);

      await new Promise(resolve => setTimeout(resolve, delay));
      return this.retryWithBackoff(fn, attempt + 1);
    }
  }

  async fetch(endpoint, options = {}) {
    const url = `${this.baseURL}${endpoint}`;

    return this.retryWithBackoff(async () => {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), this.timeout);

      try {
        const response = await fetch(url, {
          ...options,
          signal: controller.signal,
        });

        clearTimeout(timeoutId);

        if (!response.ok) {
          const error = new RetryableError(
            `HTTP ${response.status}: ${response.statusText}`,
            response.status >= 500 // Only retry server errors
          );
          error.statusCode = response.status;
          throw error;
        }

        return await response.json();

      } catch (error) {
        clearTimeout(timeoutId);

        if (error.name === 'AbortError') {
          throw new RetryableError('Request timeout', true);
        }

        throw error;
      }
    });
  }
}

// Usage
const client = new APIClient('https://api.example.com', {
  maxRetries: 3,
  baseDelay: 1000,
  timeout: 5000,
});

const fetchUserData = async () => {
  try {
    const data = await client.fetch('/users/123');
    console.log('Success:', data);
  } catch (error) {
    console.error('Final error:', error.message);
    // Handle final failure (show user message, use cached data, etc.)
  }
};

fetchUserData();
```

### Example 3: Error Boundary Pattern (React-inspired for vanilla JS)

**Scenario:** Isolate errors to prevent entire application crashes.

```javascript
class ErrorBoundary {
  constructor(componentName, fallbackUI) {
    this.componentName = componentName;
    this.fallbackUI = fallbackUI;
    this.hasError = false;
    this.error = null;
  }

  execute(fn, context = {}) {
    try {
      this.hasError = false;
      this.error = null;
      return fn();
    } catch (error) {
      this.hasError = true;
      this.error = error;

      console.error(`Error in ${this.componentName}:`, error);

      // Log to error tracking service
      this.logError(error, context);

      // Return fallback UI or value
      if (typeof this.fallbackUI === 'function') {
        return this.fallbackUI(error);
      }
      return this.fallbackUI;
    }
  }

  async executeAsync(fn, context = {}) {
    try {
      this.hasError = false;
      this.error = null;
      return await fn();
    } catch (error) {
      this.hasError = true;
      this.error = error;

      console.error(`Error in ${this.componentName}:`, error);
      this.logError(error, context);

      if (typeof this.fallbackUI === 'function') {
        return this.fallbackUI(error);
      }
      return this.fallbackUI;
    }
  }

  logError(error, context) {
    const errorData = {
      component: this.componentName,
      error: {
        message: error.message,
        stack: error.stack,
        name: error.name,
      },
      context,
      timestamp: new Date().toISOString(),
    };

    // Send to logging service
    console.log('Logging error:', errorData);
  }

  reset() {
    this.hasError = false;
    this.error = null;
  }
}

// Usage in application modules
const userProfileBoundary = new ErrorBoundary(
  'UserProfile',
  error => ({ error: true, message: 'Unable to load user profile' })
);

const commentsBoundary = new ErrorBoundary(
  'Comments',
  '<div class="error">Comments temporarily unavailable</div>'
);

// Render user profile with error boundary
const renderUserProfile = userId => {
  return userProfileBoundary.execute(() => {
    const user = fetchUser(userId); // May throw error

    if (!user) {
      throw new Error('User not found');
    }

    return `
      <div class="profile">
        <h2>${user.name}</h2>
        <p>${user.email}</p>
      </div>
    `;
  }, { userId });
};

// Async example with comments
const renderComments = async postId => {
  return await commentsBoundary.executeAsync(async () => {
    const comments = await fetchComments(postId); // May fail

    return comments.map(c => `
      <div class="comment">
        <strong>${c.author}</strong>
        <p>${c.text}</p>
      </div>
    `).join('');
  }, { postId });
};

// Application continues even if one component fails
const renderPage = async () => {
  const profile = renderUserProfile(123); // May return fallback
  const comments = await renderComments(456); // May return fallback

  return `
    <div class="page">
      ${profile}
      ${comments}
    </div>
  `;
};
```

---

## Exercises

### Exercise 1: Custom Error Class Implementation (Easy)

Create a custom error class `NetworkError` that includes:
- Status code
- Request URL
- Retry count
- A `toJSON()` method for serialization

**Starter Code:**
```javascript
class NetworkError extends Error {
  // Your implementation here
}

// Test your implementation
const error = new NetworkError('Request failed', 404, '/api/users', 2);
console.log(error.toJSON());
```

**Solution:** See `/solutions/exercise-01-custom-error.js`

---

### Exercise 2: Retry Mechanism with Exponential Backoff (Medium)

Implement a `retry` function that:
- Accepts an async function to retry
- Maximum retry attempts (default 3)
- Base delay in ms (default 1000)
- Uses exponential backoff (delay = baseDelay * 2^attempt)
- Adds random jitter to prevent thundering herd
- Returns result on success, throws on final failure

**Starter Code:**
```javascript
const retry = async (fn, options = {}) => {
  // Your implementation here
};

// Test
const unreliableAPI = () => {
  const random = Math.random();
  if (random < 0.7) throw new Error('API failed');
  return { data: 'success' };
};

retry(unreliableAPI, { maxRetries: 5, baseDelay: 500 })
  .then(result => console.log('Success:', result))
  .catch(error => console.error('Failed:', error.message));
```

**Solution:** See `/solutions/exercise-02-retry-mechanism.js`

---

### Exercise 3: Error Logging System (Medium)

Create an `ErrorLogger` class that:
- Queues errors in memory
- Batches errors and sends them to a server every 5 seconds
- Includes error metadata (timestamp, user agent, URL, etc.)
- Handles cases where the logging endpoint is down
- Provides a `flush()` method to immediately send queued errors

**Starter Code:**
```javascript
class ErrorLogger {
  // Your implementation here
}

// Test
const logger = new ErrorLogger('/api/errors');
logger.log(new Error('Test error 1'));
logger.log(new Error('Test error 2'));
// Errors should batch and send after 5 seconds
```

**Solution:** See `/solutions/exercise-03-error-logger.js`

---

### Exercise 4: Debugging Challenge - Fix the Broken Code (Easy)

Debug and fix this broken code:

```javascript
const calculateDiscount = (price, discountPercent) => {
  const discount = price * discountPercent / 100;
  const finalPrice = price - discount;
  return finalPrice;
};

const processOrder = async (orderId) => {
  const order = await fetchOrder(orderId);
  const items = order.items;

  let total = 0;
  for (let i = 0; i <= items.length; i++) {
    const item = items[i];
    const discountedPrice = calculateDiscount(item.price, item.discount);
    total += discountedPrice * item.quantity;
  }

  return {
    orderId: order.id,
    total: total.toFixed(2),
    itemCount: items.length,
  };
};

// Test
processOrder('ORDER-123')
  .then(result => console.log(result))
  .catch(error => console.error(error));
```

**Issues to find:**
1. Loop boundary error
2. Missing error handling
3. Potential null/undefined errors
4. Missing validation

**Solution:** See `/solutions/exercise-04-debug-fix.js`

---

### Exercise 5: Error Boundary Pattern (Hard)

Create an `ErrorBoundary` class that:
- Wraps component rendering logic
- Catches and logs errors
- Displays fallback UI on error
- Supports error recovery/reset
- Tracks error count and prevents infinite error loops
- Works with both sync and async functions

**Starter Code:**
```javascript
class ErrorBoundary {
  // Your implementation here
}

// Test with a component that sometimes fails
const UserProfile = ({ userId }) => {
  if (Math.random() < 0.3) {
    throw new Error('Random failure');
  }
  return `<div>User ${userId}</div>`;
};

const boundary = new ErrorBoundary(UserProfile, '<div>Error loading profile</div>');
const result = boundary.render({ userId: 123 });
console.log(result);
```

**Solution:** See `/solutions/exercise-05-error-boundary.js`

---

### Exercise 6: Production Error Tracker (Hard)

Build a production-ready error tracking system that:
- Captures all unhandled errors and promise rejections
- Groups similar errors together
- Rate limits error reporting (max 10 errors per minute)
- Includes source maps support (simulated)
- Filters out known/ignored errors
- Provides statistics (error count, error rate, etc.)

**Starter Code:**
```javascript
class ErrorTracker {
  // Your implementation here
}

// Usage
const tracker = new ErrorTracker({
  endpoint: '/api/errors',
  rateLimit: { maxErrors: 10, windowMs: 60000 },
  ignoreErrors: ['ResizeObserver loop limit exceeded'],
});

tracker.install(); // Set up global handlers
```

**Solution:** See `/solutions/exercise-06-error-tracker.js`

---

## Common Pitfalls

### 1. Swallowing Errors

```javascript
// ❌ WRONG: Silent failures
try {
  riskyOperation();
} catch (error) {
  // Nothing - error is swallowed!
}

// ✅ CORRECT: At minimum, log the error
try {
  riskyOperation();
} catch (error) {
  console.error('Operation failed:', error);
  // Re-throw if appropriate
  throw error;
}
```

### 2. Catching Too Broadly

```javascript
// ❌ WRONG: Catching everything
try {
  validateUser();
  saveToDatabase();
  sendEmail();
} catch (error) {
  // Which operation failed? Hard to tell!
  console.error('Something failed');
}

// ✅ CORRECT: Specific error handling
try {
  validateUser();
} catch (error) {
  handleValidationError(error);
}

try {
  saveToDatabase();
} catch (error) {
  handleDatabaseError(error);
}

try {
  sendEmail();
} catch (error) {
  handleEmailError(error);
}
```

### 3. Not Handling Async Errors

```javascript
// ❌ WRONG: Unhandled promise rejection
const fetchData = async () => {
  const response = await fetch('/api/data');
  return response.json();
};

fetchData(); // If this fails, unhandled rejection!

// ✅ CORRECT: Always handle promise errors
fetchData()
  .then(data => console.log(data))
  .catch(error => console.error('Failed to fetch:', error));
```

### 4. Returning Wrong Values on Error

```javascript
// ❌ WRONG: Returning undefined on error
const getUser = userId => {
  try {
    return fetchUser(userId);
  } catch (error) {
    return undefined; // Caller can't distinguish error from missing user
  }
};

// ✅ CORRECT: Let error propagate or return explicit error state
const getUser = userId => {
  try {
    return { success: true, user: fetchUser(userId) };
  } catch (error) {
    return { success: false, error: error.message };
  }
};
```

### 5. Not Cleaning Up Resources

```javascript
// ❌ WRONG: File handle not closed on error
const file = openFile('data.txt');
const data = processFile(file); // May throw
closeFile(file);

// ✅ CORRECT: Use finally for cleanup
let file;
try {
  file = openFile('data.txt');
  const data = processFile(file);
} catch (error) {
  console.error('Processing failed:', error);
} finally {
  if (file) {
    closeFile(file);
  }
}
```

### 6. Creating Error Instances Without Throwing

```javascript
// ❌ WRONG: Creating error but not throwing
const validateAge = age => {
  if (age < 0) {
    new Error('Age cannot be negative'); // Created but not thrown!
    return false;
  }
  return true;
};

// ✅ CORRECT: Throw the error
const validateAge = age => {
  if (age < 0) {
    throw new Error('Age cannot be negative');
  }
  return true;
};
```

---

## Testing Error Cases

Error paths must be tested just like success paths.

### Testing Thrown Errors

```javascript
import { describe, it, expect } from 'vitest';

describe('validateAge', () => {
  it('should throw TypeError for non-number input', () => {
    expect(() => validateAge('25')).toThrow(TypeError);
    expect(() => validateAge('25')).toThrow('Age must be a number');
  });

  it('should throw RangeError for negative age', () => {
    expect(() => validateAge(-5)).toThrow(RangeError);
  });

  it('should accept valid age', () => {
    expect(() => validateAge(25)).not.toThrow();
  });
});
```

### Testing Async Errors

```javascript
describe('fetchUser', () => {
  it('should throw error for invalid userId', async () => {
    await expect(fetchUser(null)).rejects.toThrow('Invalid user ID');
  });

  it('should throw error for non-existent user', async () => {
    await expect(fetchUser(99999)).rejects.toThrow('User not found');
  });

  it('should return user for valid ID', async () => {
    const user = await fetchUser(123);
    expect(user).toHaveProperty('name');
  });
});
```

### Testing Error Recovery

```javascript
describe('retryWithBackoff', () => {
  it('should succeed after retries', async () => {
    let attempts = 0;
    const flaky = () => {
      attempts++;
      if (attempts < 3) throw new Error('Failed');
      return 'success';
    };

    const result = await retryWithBackoff(flaky, 5);
    expect(result).toBe('success');
    expect(attempts).toBe(3);
  });

  it('should fail after max retries', async () => {
    const alwaysFails = () => {
      throw new Error('Always fails');
    };

    await expect(retryWithBackoff(alwaysFails, 3)).rejects.toThrow();
  });
});
```

---

## Summary & Next Steps

### Key Takeaways

- **Error Types:** JavaScript has built-in error types (SyntaxError, TypeError, ReferenceError, RangeError) - use the right one
- **Try-Catch-Finally:** Use try-catch to handle errors gracefully, finally for cleanup
- **Custom Errors:** Create custom error classes for domain-specific error handling
- **Async Errors:** Always handle promise rejections and use try-catch with async/await
- **Error Propagation:** Let errors bubble up to where they can be handled meaningfully
- **Debugging Tools:** Master console methods, debugger statement, and browser/Node DevTools
- **Stack Traces:** Learn to read stack traces from bottom to top
- **Recovery Strategies:** Implement retry logic, fallbacks, and circuit breakers for resilience
- **Input Validation:** Validate all external input and practice defensive programming
- **Production Logging:** Log errors with context for debugging production issues
- **Testing:** Test error paths as thoroughly as success paths

### Related Topics

- [Async/Await and Promises](../10.major_es6_features/02.promises.md)
- [Testing with Vitest](../testing/01.unit-testing.md)
- [Input Validation](../validation/01.input-validation.md)
- [Logging Best Practices](../logging/01.logging.md)

### Further Reading

- [MDN: Error](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error)
- [MDN: try...catch](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch)
- [Node.js Error Handling Best Practices](https://nodejs.org/en/docs/guides/error-handling/)
- [Chrome DevTools: Debug JavaScript](https://developer.chrome.com/docs/devtools/javascript/)
- [Error Handling in JavaScript: Best Practices](https://www.freecodecamp.org/news/error-handling-in-javascript/)

---

**End of Lesson**

Practice these patterns consistently, and error handling will become second nature. Remember: good error handling is what separates professional code from hobby projects.
