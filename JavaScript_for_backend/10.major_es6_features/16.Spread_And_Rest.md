# Spread and Rest Operators - Flexible Data Manipulation in JavaScript

## Metadata

- **Topic**: Spread and Rest Operators (`...`)
- **Difficulty**: Beginner to Advanced
- **Prerequisites**: Arrays, objects, functions, destructuring
- **ES Version**: ES6 (ES2015) for arrays, ES2018 for objects
- **Estimated Time**: 100 minutes
- **Learning Objectives**:
  - Understand the dual nature of the `...` operator
  - Master spread operator for arrays and objects
  - Master rest parameters in functions
  - Use rest in destructuring effectively
  - Apply spread and rest in real-world patterns
  - Understand shallow vs deep copying

---

## Table of Contents

1. [Introduction](#introduction)
2. [Spread Operator - Basics](#spread-operator-basics)
3. [Spread with Arrays](#spread-with-arrays)
4. [Spread with Objects](#spread-with-objects)
5. [Spread in Function Calls](#spread-in-function-calls)
6. [Rest Parameters](#rest-parameters)
7. [Rest in Destructuring](#rest-in-destructuring)
8. [Spread vs Rest](#spread-vs-rest)
9. [Practical Patterns](#practical-patterns)
10. [Common Pitfalls](#common-pitfalls)
11. [Exercises](#exercises)
12. [Solutions](#solutions)
13. [Tests](#tests)

---

## Introduction

The three dots (`...`) operator in JavaScript serves two related but opposite purposes:
- **Spread**: Expands (spreads) an iterable into individual elements
- **Rest**: Collects (gathers) individual elements into an array

The same syntax, different contexts, opposite effects!

### Spread vs Rest: Quick Overview

```javascript
// SPREAD: Expands array into individual elements
const numbers = [1, 2, 3];
console.log(...numbers);        // 1 2 3
const combined = [0, ...numbers, 4]; // [0, 1, 2, 3, 4]

// REST: Collects individual elements into array
function sum(...numbers) {      // numbers becomes [1, 2, 3, 4]
  return numbers.reduce((a, b) => a + b);
}
console.log(sum(1, 2, 3, 4));   // 10
```

### When to Use Which?

| Context | Operation | Example |
|---------|-----------|---------|
| Array literal `[...]` | Spread | `[...arr1, ...arr2]` |
| Object literal `{...}` | Spread | `{...obj1, ...obj2}` |
| Function call | Spread | `func(...arr)` |
| Function parameters | Rest | `function(...args)` |
| Destructuring assignment | Rest | `[a, ...rest] = arr` |

---

## Spread Operator Basics

Spread operator expands an iterable (array, string, object) into individual elements.

### Basic Concept

```javascript
const arr = [1, 2, 3];

// Without spread - passes entire array as single argument
console.log(arr);        // [1, 2, 3]

// With spread - expands array into separate arguments
console.log(...arr);     // 1 2 3

// Think of it as "unpacking" the array
// [...arr] is like [arr[0], arr[1], arr[2]]
```

### Spread Strings

```javascript
const str = "Hello";

// Spread string into array of characters
const chars = [...str];
console.log(chars); // ["H", "e", "l", "l", "o"]

// Can use anywhere you can use multiple values
console.log(...str); // H e l l o

// Useful for string manipulation
const reversed = [...str].reverse().join("");
console.log(reversed); // "olleH"
```

---

## Spread with Arrays

### Copying Arrays (Shallow Copy)

```javascript
// Traditional way - reference copy (not what we want!)
const original = [1, 2, 3];
const badCopy = original;
badCopy.push(4);
console.log(original); // [1, 2, 3, 4] - original is modified!

// Spread creates a new array (shallow copy)
const original = [1, 2, 3];
const goodCopy = [...original];
goodCopy.push(4);
console.log(original); // [1, 2, 3] - original unchanged
console.log(goodCopy); // [1, 2, 3, 4]

// Note: This is a shallow copy
const nested = [[1, 2], [3, 4]];
const shallowCopy = [...nested];
shallowCopy[0].push(5);
console.log(nested); // [[1, 2, 5], [3, 4]] - inner array modified!
```

### Concatenating Arrays

```javascript
// Old way
const arr1 = [1, 2];
const arr2 = [3, 4];
const combined = arr1.concat(arr2);

// Spread way - cleaner and more flexible
const combined = [...arr1, ...arr2];
console.log(combined); // [1, 2, 3, 4]

// Multiple arrays
const a = [1, 2];
const b = [3, 4];
const c = [5, 6];
const all = [...a, ...b, ...c];
console.log(all); // [1, 2, 3, 4, 5, 6]

// Insert at any position
const middle = [...a, 99, ...b];
console.log(middle); // [1, 2, 99, 3, 4]
```

### Adding Elements

```javascript
const numbers = [2, 3, 4];

// Add at beginning
const withStart = [1, ...numbers];
console.log(withStart); // [1, 2, 3, 4]

// Add at end
const withEnd = [...numbers, 5];
console.log(withEnd); // [2, 3, 4, 5]

// Add at both ends
const withBoth = [0, 1, ...numbers, 5, 6];
console.log(withBoth); // [0, 1, 2, 3, 4, 5, 6]

// Add in middle
const withMiddle = [1, 2, ...numbers, 7, 8];
console.log(withMiddle); // [1, 2, 2, 3, 4, 7, 8]
```

### Removing Duplicates

```javascript
const numbers = [1, 2, 2, 3, 4, 4, 5];

// Spread with Set to remove duplicates
const unique = [...new Set(numbers)];
console.log(unique); // [1, 2, 3, 4, 5]

// One-liner unique array function
const getUnique = arr => [...new Set(arr)];
console.log(getUnique([1, 1, 2, 3, 3, 4])); // [1, 2, 3, 4]
```

### Converting Iterables to Arrays

```javascript
// NodeList to Array (DOM elements)
// const divs = document.querySelectorAll('div');
// const divArray = [...divs];

// Arguments to Array (will cover more in rest parameters)
function demo() {
  const argsArray = [...arguments];
  console.log(argsArray);
}
demo(1, 2, 3); // [1, 2, 3]

// Map to Array
const map = new Map([['a', 1], ['b', 2]]);
const entries = [...map];
console.log(entries); // [['a', 1], ['b', 2]]

// Set to Array
const set = new Set([1, 2, 3]);
const setArray = [...set];
console.log(setArray); // [1, 2, 3]
```

---

## Spread with Objects

Object spread was introduced in ES2018 (ES9).

### Copying Objects (Shallow Copy)

```javascript
const user = {
  name: "Arjun",
  age: 19,
  city: "Ahmedabad"
};

// Create shallow copy
const userCopy = { ...user };
userCopy.age = 20;

console.log(user.age);     // 19 (unchanged)
console.log(userCopy.age); // 20

// Shallow copy caveat
const user = {
  name: "Krishna",
  address: {
    city: "Surat",
    state: "Gujarat"
  }
};

const copy = { ...user };
copy.address.city = "Ahmedabad";

console.log(user.address.city); // "Ahmedabad" (nested object modified!)
```

### Merging Objects

```javascript
const personal = { name: "Arjun", age: 19 };
const academic = { branch: "CSE", year: 3 };

// Merge into new object
const student = { ...personal, ...academic };
console.log(student);
// { name: "Arjun", age: 19, branch: "CSE", year: 3 }

// Later properties overwrite earlier ones
const obj1 = { a: 1, b: 2 };
const obj2 = { b: 3, c: 4 };
const merged = { ...obj1, ...obj2 };
console.log(merged); // { a: 1, b: 3, c: 4 } - b from obj2 wins
```

### Adding/Updating Properties

```javascript
const user = { name: "Krishna", age: 20 };

// Add new property
const withEmail = { ...user, email: "krishna@example.com" };
console.log(withEmail);
// { name: "Krishna", age: 20, email: "krishna@example.com" }

// Update existing property
const olderUser = { ...user, age: 21 };
console.log(olderUser);
// { name: "Krishna", age: 21 }

// Order matters!
const obj1 = { ...user, age: 25 };  // age is 25 (new value)
const obj2 = { age: 25, ...user };  // age is 20 (from user)
```

### Removing Properties (with Destructuring)

```javascript
const user = {
  id: 101,
  name: "Arjun",
  password: "secret123",
  email: "arjun@example.com"
};

// Remove password using destructuring + spread
const { password, ...safeUser } = user;
console.log(safeUser);
// { id: 101, name: "Arjun", email: "arjun@example.com" }

// Remove multiple properties
const { password, id, ...publicUser } = user;
console.log(publicUser);
// { name: "Arjun", email: "arjun@example.com" }
```

### Conditional Properties

```javascript
const includeEmail = true;
const includePhone = false;

const user = {
  name: "Mahir",
  age: 19,
  ...(includeEmail && { email: "mahir@example.com" }),
  ...(includePhone && { phone: "9876543210" })
};

console.log(user);
// { name: "Mahir", age: 19, email: "mahir@example.com" }
// phone is not included because includePhone is false
```

---

## Spread in Function Calls

### Passing Array as Arguments

```javascript
const numbers = [5, 10, 15];

// Old way - using apply
Math.max.apply(null, numbers);

// Spread way - cleaner
Math.max(...numbers); // 15

// Multiple arrays
const set1 = [1, 2, 3];
const set2 = [4, 5, 6];
const max = Math.max(...set1, ...set2);
console.log(max); // 6
```

### Combining with Normal Arguments

```javascript
const numbers = [2, 3, 4];

// Mix spread with regular arguments
console.log(Math.max(1, ...numbers, 5));
// Same as: Math.max(1, 2, 3, 4, 5)
// Output: 5

// Push multiple elements
const arr = [1, 2];
const toAdd = [3, 4, 5];
arr.push(...toAdd);
console.log(arr); // [1, 2, 3, 4, 5]
```

### Practical Examples

```javascript
// Date constructor
const dateFields = [2024, 11, 25]; // Dec 25, 2024 (month is 0-indexed)
const date = new Date(...dateFields);
console.log(date);

// Custom function calls
function createUser(name, age, city) {
  return { name, age, city };
}

const userInfo = ["Arjun", 19, "Ahmedabad"];
const user = createUser(...userInfo);
console.log(user);
// { name: "Arjun", age: 19, city: "Ahmedabad" }
```

---

## Rest Parameters

Rest parameters collect multiple arguments into an array. They must be the last parameter.

### Basic Rest Parameters

```javascript
// Traditional arguments object
function oldSum() {
  let total = 0;
  for (let i = 0; i < arguments.length; i++) {
    total += arguments[i];
  }
  return total;
}

// Modern rest parameters - cleaner and more flexible
function sum(...numbers) {
  return numbers.reduce((total, num) => total + num, 0);
}

console.log(sum(1, 2, 3));        // 6
console.log(sum(1, 2, 3, 4, 5));  // 15
console.log(sum());               // 0
```

### Combining Regular and Rest Parameters

```javascript
function greet(greeting, ...names) {
  return `${greeting}, ${names.join(" and ")}!`;
}

console.log(greet("Hello", "Arjun"));                    // "Hello, Arjun!"
console.log(greet("Welcome", "Krishna", "Mahir"));       // "Welcome, Krishna and Mahir!"
console.log(greet("Hi", "Arjun", "Krishna", "Priya"));   // "Hi, Arjun and Krishna and Priya!"
```

### Rest Must Be Last

```javascript
// ✅ CORRECT: Rest parameter at the end
function demo(a, b, ...rest) {
  console.log(a, b, rest);
}
demo(1, 2, 3, 4, 5); // 1 2 [3, 4, 5]

// ❌ WRONG: Rest parameter not at the end
// function wrong(...rest, last) { } // SyntaxError

// ✅ CORRECT: Multiple regular parameters before rest
function getData(url, method, headers, ...options) {
  console.log(url, method, headers, options);
}
```

### Real-World Rest Examples

```javascript
// Logger function
function log(level, message, ...details) {
  const timestamp = new Date().toISOString();
  console.log(`[${timestamp}] [${level}] ${message}`);
  if (details.length > 0) {
    console.log("Details:", ...details);
  }
}

log("INFO", "User logged in");
log("ERROR", "Database connection failed", "Connection timeout", "Retry attempt: 3");

// Flexible calculator
function calculate(operation, ...numbers) {
  switch (operation) {
    case "add":
      return numbers.reduce((a, b) => a + b, 0);
    case "multiply":
      return numbers.reduce((a, b) => a * b, 1);
    case "average":
      return numbers.reduce((a, b) => a + b, 0) / numbers.length;
    default:
      return null;
  }
}

console.log(calculate("add", 1, 2, 3, 4));      // 10
console.log(calculate("multiply", 2, 3, 4));    // 24
console.log(calculate("average", 10, 20, 30));  // 20
```

### Rest vs Arguments Object

```javascript
// Arguments object (old way)
function oldWay() {
  console.log(typeof arguments);           // "object"
  console.log(Array.isArray(arguments));   // false
  console.log(arguments);                  // Arguments object

  // Need to convert to array to use array methods
  const arr = Array.from(arguments);
  console.log(arr.map(x => x * 2));
}

// Rest parameters (modern way)
function modernWay(...args) {
  console.log(typeof args);              // "object"
  console.log(Array.isArray(args));      // true
  console.log(args);                     // Real array

  // Can use array methods directly
  console.log(args.map(x => x * 2));
}

oldWay(1, 2, 3);
modernWay(1, 2, 3);
```

---

## Rest in Destructuring

### Array Destructuring with Rest

```javascript
const numbers = [1, 2, 3, 4, 5];

// Collect remaining elements
const [first, second, ...rest] = numbers;
console.log(first);  // 1
console.log(second); // 2
console.log(rest);   // [3, 4, 5]

// Get first and rest
const [head, ...tail] = numbers;
console.log(head); // 1
console.log(tail); // [2, 3, 4, 5]

// Skip elements before rest
const [, , ...others] = numbers;
console.log(others); // [3, 4, 5]
```

### Object Destructuring with Rest

```javascript
const student = {
  name: "Krishna",
  age: 20,
  branch: "CSE",
  city: "Surat",
  state: "Gujarat"
};

// Extract specific properties, collect rest
const { name, age, ...otherInfo } = student;
console.log(name);      // "Krishna"
console.log(age);       // 20
console.log(otherInfo); // { branch: "CSE", city: "Surat", state: "Gujarat" }

// Useful for removing properties
const { password, ...safeUser } = {
  id: 101,
  name: "Arjun",
  password: "secret",
  email: "arjun@example.com"
};
console.log(safeUser);
// { id: 101, name: "Arjun", email: "arjun@example.com" }
```

### Nested Rest

```javascript
const data = {
  user: {
    id: 1,
    name: "Arjun",
    email: "arjun@example.com",
    age: 19,
    city: "Ahmedabad"
  }
};

// Extract some nested properties, keep rest
const {
  user: {
    name,
    email,
    ...otherUserDetails
  }
} = data;

console.log(name);              // "Arjun"
console.log(email);             // "arjun@example.com"
console.log(otherUserDetails);  // { id: 1, age: 19, city: "Ahmedabad" }
```

---

## Spread vs Rest

### Visual Comparison

```javascript
// SPREAD: Takes array and spreads it out
const arr = [1, 2, 3];
console.log(...arr);           // 1 2 3 (individual values)
const newArr = [0, ...arr, 4]; // [0, 1, 2, 3, 4] (expanded inside new array)

// REST: Takes individual values and collects them into array
function sum(...numbers) {     // Collects arguments into numbers array
  console.log(numbers);        // [1, 2, 3] (collected into array)
  return numbers.reduce((a, b) => a + b);
}
console.log(sum(1, 2, 3));     // 6
```

### Side-by-Side Examples

```javascript
// SPREAD in array literal
const arr1 = [1, 2];
const arr2 = [3, 4];
const combined = [...arr1, ...arr2]; // Spread both arrays
console.log(combined); // [1, 2, 3, 4]

// REST in destructuring
const [first, ...rest] = combined;   // Collect rest into array
console.log(first); // 1
console.log(rest);  // [2, 3, 4]


// SPREAD in function call
const numbers = [5, 10, 15];
const max = Math.max(...numbers);    // Spread array as arguments
console.log(max); // 15

// REST in function definition
function multiply(...nums) {         // Collect arguments into array
  return nums.reduce((a, b) => a * b);
}
console.log(multiply(2, 3, 4));      // 24


// SPREAD in object literal
const obj1 = { a: 1, b: 2 };
const obj2 = { ...obj1, c: 3 };      // Spread object properties
console.log(obj2); // { a: 1, b: 2, c: 3 }

// REST in object destructuring
const { a, ...remaining } = obj2;    // Collect remaining properties
console.log(a);         // 1
console.log(remaining); // { b: 2, c: 3 }
```

### Context Determines Meaning

| Context | Operator | Purpose | Example |
|---------|----------|---------|---------|
| `[...arr]` | Spread | Expand array | `[1, ...arr, 5]` |
| `{...obj}` | Spread | Copy object | `{...user, age: 20}` |
| `func(...arr)` | Spread | Pass as args | `Math.max(...nums)` |
| `function(...args)` | Rest | Collect args | `function sum(...n)` |
| `[a, ...rest]` | Rest | Collect remainder | `const [x, ...r] = arr` |
| `{a, ...rest}` | Rest | Collect properties | `const {x, ...r} = obj` |

---

## Practical Patterns

### Pattern 1: Array Manipulation

```javascript
// Immutable array operations
const numbers = [1, 2, 3, 4, 5];

// Add element immutably
const withAdded = [...numbers, 6];

// Remove element by index
const index = 2;
const withRemoved = [...numbers.slice(0, index), ...numbers.slice(index + 1)];
console.log(withRemoved); // [1, 2, 4, 5]

// Update element by index
const withUpdated = [
  ...numbers.slice(0, index),
  999,
  ...numbers.slice(index + 1)
];
console.log(withUpdated); // [1, 2, 999, 4, 5]

// Insert at position
const withInserted = [
  ...numbers.slice(0, 2),
  100,
  ...numbers.slice(2)
];
console.log(withInserted); // [1, 2, 100, 3, 4, 5]
```

### Pattern 2: Object Updates

```javascript
const user = {
  id: 101,
  name: "Arjun",
  age: 19,
  city: "Ahmedabad"
};

// Update single property immutably
const updatedUser = { ...user, age: 20 };

// Update multiple properties
const fullyUpdated = {
  ...user,
  age: 20,
  city: "Surat",
  lastModified: new Date()
};

// Nested object update (be careful - still shallow!)
const userWithAddress = {
  ...user,
  address: {
    ...user.address,
    city: "Vadodara"
  }
};

// Toggle boolean
const toggledUser = { ...user, active: !user.active };
```

### Pattern 3: Function Composition

```javascript
// Composing functions with rest/spread
function pipe(...functions) {
  return (initialValue) => {
    return functions.reduce((value, func) => func(value), initialValue);
  };
}

const addOne = x => x + 1;
const double = x => x * 2;
const square = x => x * x;

const process = pipe(addOne, double, square);
console.log(process(3)); // ((3 + 1) * 2)² = 64

// Flexible middleware pattern
function applyMiddleware(handler, ...middlewares) {
  return (...args) => {
    let result = handler(...args);
    middlewares.forEach(middleware => {
      result = middleware(result);
    });
    return result;
  };
}
```

### Pattern 4: Cloning with Modifications

```javascript
// Clone array with modifications
function updateInArray(array, index, newValue) {
  return [
    ...array.slice(0, index),
    newValue,
    ...array.slice(index + 1)
  ];
}

const numbers = [10, 20, 30, 40];
const updated = updateInArray(numbers, 2, 999);
console.log(updated); // [10, 20, 999, 40]

// Clone object with nested update
function updateNested(obj, path, value) {
  const [head, ...rest] = path;

  if (rest.length === 0) {
    return { ...obj, [head]: value };
  }

  return {
    ...obj,
    [head]: updateNested(obj[head], rest, value)
  };
}

const state = {
  user: {
    profile: {
      name: "Arjun",
      age: 19
    }
  }
};

const newState = updateNested(state, ["user", "profile", "age"], 20);
console.log(newState.user.profile.age); // 20
console.log(state.user.profile.age);    // 19 (unchanged)
```

### Pattern 5: Merging with Priority

```javascript
// Merge multiple objects with priority (last wins)
function merge(...objects) {
  return objects.reduce((result, obj) => ({ ...result, ...obj }), {});
}

const defaults = { theme: "light", lang: "en", notifications: true };
const userPrefs = { theme: "dark", fontSize: 14 };
const sessionPrefs = { lang: "hi" };

const settings = merge(defaults, userPrefs, sessionPrefs);
console.log(settings);
// { theme: "dark", lang: "hi", notifications: true, fontSize: 14 }
```

---

## Common Pitfalls

### 1. Shallow Copy Trap

```javascript
// Spread creates shallow copy only!
const original = {
  name: "Arjun",
  address: { city: "Ahmedabad" }
};

const copy = { ...original };
copy.address.city = "Surat";

console.log(original.address.city); // "Surat" - original modified!

// ✅ SOLUTION: Deep copy nested objects
const deepCopy = {
  ...original,
  address: { ...original.address }
};
```

### 2. Rest Must Be Last

```javascript
// ❌ WRONG
// function wrong(...rest, last) { }
// const [...rest, last] = arr;

// ✅ CORRECT
function correct(first, ...rest) { }
const [first, ...rest] = arr;
```

### 3. Spreading Non-Iterables

```javascript
// ❌ WRONG: Can't spread numbers, booleans, etc.
// const arr = [...42];        // TypeError
// const arr = [...true];      // TypeError
// const obj = { ...null };    // No error but results in {}

// ✅ CORRECT: Only spread iterables
const arr = [...[1, 2, 3]];   // OK
const chars = [..."hello"];   // OK
const obj = { ...{a: 1} };    // OK
```

### 4. Performance with Large Arrays

```javascript
// ❌ AVOID: Spreading large arrays repeatedly in loops
const result = [];
for (let i = 0; i < 10000; i++) {
  result = [...result, i]; // Creates new array each time!
}

// ✅ BETTER: Use push for building arrays
const result = [];
for (let i = 0; i < 10000; i++) {
  result.push(i); // Mutates but much faster
}

// ✅ BEST: Use appropriate method
const result = Array.from({ length: 10000 }, (_, i) => i);
```

### 5. Object Property Order

```javascript
// Spread order matters!
const user = { name: "Arjun", age: 19 };

const updated1 = { ...user, age: 20 };
console.log(updated1.age); // 20 (new value wins)

const updated2 = { age: 20, ...user };
console.log(updated2.age); // 19 (spread overwrites)
```

---

## Exercises

### Exercise 1: Array Merging (Easy)

Create a function `mergeUnique(...arrays)` that merges multiple arrays and removes duplicates.

```javascript
mergeUnique([1, 2], [2, 3], [3, 4]);
// [1, 2, 3, 4]
```

---

### Exercise 2: Object Defaults (Easy)

Write a function `withDefaults(obj, defaults)` that returns a new object with default values for missing properties.

```javascript
withDefaults({ name: "Arjun" }, { name: "Guest", age: 18, role: "user" });
// { name: "Arjun", age: 18, role: "user" }
```

---

### Exercise 3: Rest Sum (Easy)

Create a function `sum(first, second, ...rest)` that returns the sum of all arguments, where first is multiplied by 2 and second by 3.

```javascript
sum(1, 2, 3, 4, 5);
// (1*2) + (2*3) + 3 + 4 + 5 = 20
```

---

### Exercise 4: Array Insert (Medium)

Write a function `insertAt(array, index, ...elements)` that inserts elements at a specific index without mutating the original array.

```javascript
insertAt([1, 2, 5, 6], 2, 3, 4);
// [1, 2, 3, 4, 5, 6]
```

---

### Exercise 5: Deep Merge (Medium)

Create a function `deepMerge(obj1, obj2)` that deeply merges two objects.

```javascript
deepMerge(
  { a: 1, b: { c: 2, d: 3 } },
  { b: { d: 4, e: 5 }, f: 6 }
);
// { a: 1, b: { c: 2, d: 4, e: 5 }, f: 6 }
```

---

### Exercise 6: Function Pipeline (Hard)

Create a function `pipeline(...functions)` that takes functions and returns a new function that passes its argument through all functions.

```javascript
const add5 = x => x + 5;
const multiply2 = x => x * 2;
const subtract3 = x => x - 3;

const process = pipeline(add5, multiply2, subtract3);
console.log(process(10)); // ((10 + 5) * 2) - 3 = 27
```

---

### Exercise 7: Immutable State Update (Hard)

Write a function `updateState(state, path, value)` that updates a nested property immutably.

```javascript
const state = {
  user: {
    profile: { name: "Arjun", age: 19 },
    settings: { theme: "dark" }
  }
};

updateState(state, ["user", "profile", "age"], 20);
// Returns new state with age updated, original unchanged
```

---

## Solutions

```javascript
// Solution 1: Merge Unique
function mergeUnique(...arrays) {
  const merged = arrays.flat();
  return [...new Set(merged)];
}

// Alternative
function mergeUnique2(...arrays) {
  return [...new Set([].concat(...arrays))];
}

// Test
console.log(mergeUnique([1, 2], [2, 3], [3, 4])); // [1, 2, 3, 4]
console.log(mergeUnique([1, 1, 1], [2, 2], [3])); // [1, 2, 3]


// Solution 2: Object Defaults
function withDefaults(obj, defaults) {
  return { ...defaults, ...obj };
}

// Test
console.log(withDefaults({ name: "Arjun" }, { name: "Guest", age: 18, role: "user" }));
// { name: "Arjun", age: 18, role: "user" }

console.log(withDefaults({}, { name: "Guest", age: 18 }));
// { name: "Guest", age: 18 }


// Solution 3: Rest Sum
function sum(first, second, ...rest) {
  const firstPart = first * 2;
  const secondPart = second * 3;
  const restSum = rest.reduce((acc, num) => acc + num, 0);
  return firstPart + secondPart + restSum;
}

// Test
console.log(sum(1, 2, 3, 4, 5)); // 2 + 6 + 12 = 20
console.log(sum(2, 3));          // 4 + 9 = 13


// Solution 4: Array Insert
function insertAt(array, index, ...elements) {
  return [
    ...array.slice(0, index),
    ...elements,
    ...array.slice(index)
  ];
}

// Test
console.log(insertAt([1, 2, 5, 6], 2, 3, 4)); // [1, 2, 3, 4, 5, 6]
console.log(insertAt([1, 5], 1, 2, 3, 4));    // [1, 2, 3, 4, 5]


// Solution 5: Deep Merge
function deepMerge(obj1, obj2) {
  const result = { ...obj1 };

  for (const key in obj2) {
    if (obj2[key] && typeof obj2[key] === 'object' && !Array.isArray(obj2[key])) {
      result[key] = deepMerge(result[key] || {}, obj2[key]);
    } else {
      result[key] = obj2[key];
    }
  }

  return result;
}

// Test
const merged = deepMerge(
  { a: 1, b: { c: 2, d: 3 } },
  { b: { d: 4, e: 5 }, f: 6 }
);
console.log(merged);
// { a: 1, b: { c: 2, d: 4, e: 5 }, f: 6 }


// Solution 6: Function Pipeline
function pipeline(...functions) {
  return (initialValue) => {
    return functions.reduce((value, func) => func(value), initialValue);
  };
}

// Test
const add5 = x => x + 5;
const multiply2 = x => x * 2;
const subtract3 = x => x - 3;

const process = pipeline(add5, multiply2, subtract3);
console.log(process(10)); // 27
console.log(process(5));  // 17


// Solution 7: Immutable State Update
function updateState(state, path, value) {
  if (path.length === 0) {
    return value;
  }

  const [head, ...tail] = path;

  return {
    ...state,
    [head]: updateState(state[head], tail, value)
  };
}

// Test
const state = {
  user: {
    profile: { name: "Arjun", age: 19 },
    settings: { theme: "dark" }
  }
};

const newState = updateState(state, ["user", "profile", "age"], 20);
console.log(newState.user.profile.age); // 20
console.log(state.user.profile.age);    // 19

const newState2 = updateState(state, ["user", "settings", "theme"], "light");
console.log(newState2.user.settings.theme); // "light"
console.log(state.user.settings.theme);     // "dark"
```

---

## Tests

```javascript
/**
 * Test Suite for Spread and Rest Exercises
 * Run with: node 16_spread_rest_tests.js
 */

function assert(condition, message) {
  if (!condition) {
    console.error(`❌ FAILED: ${message}`);
    return false;
  } else {
    console.log(`✅ PASSED: ${message}`);
    return true;
  }
}

function deepEqual(obj1, obj2) {
  return JSON.stringify(obj1) === JSON.stringify(obj2);
}

console.log('╔════════════════════════════════════════════════════════════════╗');
console.log('║  Spread and Rest Operators - Test Suite                       ║');
console.log('╚════════════════════════════════════════════════════════════════╝\n');

// Test Exercise 1
console.log('--- Testing Exercise 1: Merge Unique ---');
assert(
  deepEqual(mergeUnique([1, 2], [2, 3], [3, 4]), [1, 2, 3, 4]),
  "Merge arrays and remove duplicates"
);
assert(
  deepEqual(mergeUnique([1, 1], [2, 2], [3, 3]), [1, 2, 3]),
  "Handle multiple duplicates"
);

// Test Exercise 2
console.log('\n--- Testing Exercise 2: Object Defaults ---');
const result2 = withDefaults({ name: "Arjun" }, { name: "Guest", age: 18, role: "user" });
assert(
  result2.name === "Arjun" && result2.age === 18 && result2.role === "user",
  "Merge with defaults, object properties win"
);

// Test Exercise 3
console.log('\n--- Testing Exercise 3: Rest Sum ---');
assert(sum(1, 2, 3, 4, 5) === 20, "Calculate weighted sum");
assert(sum(2, 3) === 13, "Handle no rest parameters");

// Test Exercise 4
console.log('\n--- Testing Exercise 4: Array Insert ---');
assert(
  deepEqual(insertAt([1, 2, 5, 6], 2, 3, 4), [1, 2, 3, 4, 5, 6]),
  "Insert multiple elements at index"
);
assert(
  deepEqual(insertAt([1, 5], 1, 2, 3, 4), [1, 2, 3, 4, 5]),
  "Insert in middle"
);

// Test Exercise 5
console.log('\n--- Testing Exercise 5: Deep Merge ---');
const merged = deepMerge(
  { a: 1, b: { c: 2, d: 3 } },
  { b: { d: 4, e: 5 }, f: 6 }
);
assert(
  merged.a === 1 && merged.b.c === 2 && merged.b.d === 4 && merged.b.e === 5 && merged.f === 6,
  "Deep merge objects correctly"
);

// Test Exercise 6
console.log('\n--- Testing Exercise 6: Function Pipeline ---');
const add5 = x => x + 5;
const multiply2 = x => x * 2;
const subtract3 = x => x - 3;
const process = pipeline(add5, multiply2, subtract3);

assert(process(10) === 27, "Pipeline processes value correctly");
assert(process(5) === 17, "Pipeline handles different input");

// Test Exercise 7
console.log('\n--- Testing Exercise 7: Immutable State Update ---');
const state = {
  user: {
    profile: { name: "Arjun", age: 19 },
    settings: { theme: "dark" }
  }
};

const newState = updateState(state, ["user", "profile", "age"], 20);
assert(
  newState.user.profile.age === 20 && state.user.profile.age === 19,
  "Update nested property immutably"
);
assert(
  newState.user.settings.theme === "dark",
  "Preserve other properties"
);

console.log('\n╔════════════════════════════════════════════════════════════════╗');
console.log('║  All Tests Completed                                           ║');
console.log('╚════════════════════════════════════════════════════════════════╝\n');
```

---

## Summary

The spread and rest operators (`...`) are versatile tools in modern JavaScript:

**Key Takeaways:**

1. **Same syntax, different contexts**: Spread expands, rest collects
2. **Spread uses**: Copy arrays/objects, merge, pass arguments
3. **Rest uses**: Collect function arguments, gather in destructuring
4. **Shallow copying**: Both create shallow copies; nested objects need special handling
5. **Rest must be last**: In both function parameters and destructuring
6. **Immutability**: Excellent for immutable data operations
7. **Performance**: Be mindful in performance-critical code

Master spread and rest to write cleaner, more functional JavaScript!

---

**Last Updated**: 2025-11-22
**Version**: 1.0.0
