# Enhanced Object Literals - Modern Object Creation in JavaScript

## Metadata

- **Topic**: Enhanced Object Literals
- **Difficulty**: Beginner to Intermediate
- **Prerequisites**: Objects, functions, ES6 basics
- **ES Version**: ES6 (ES2015)
- **Estimated Time**: 90 minutes
- **Learning Objectives**:
  - Master property shorthand syntax
  - Use method shorthand effectively
  - Create computed property names
  - Combine enhanced features with destructuring and spread
  - Write cleaner object-oriented code
  - Understand prototype and super in object literals

---

## Table of Contents

1. [Introduction](#introduction)
2. [Property Shorthand](#property-shorthand)
3. [Method Shorthand](#method-shorthand)
4. [Computed Property Names](#computed-property-names)
5. [Concise Getters and Setters](#concise-getters-and-setters)
6. [Prototype Assignment](#prototype-assignment)
7. [Super in Object Literals](#super-in-object-literals)
8. [Combining Features](#combining-features)
9. [Real-World Patterns](#real-world-patterns)
10. [Common Pitfalls](#common-pitfalls)
11. [Exercises](#exercises)
12. [Solutions](#solutions)
13. [Tests](#tests)

---

## Introduction

Enhanced Object Literals introduced in ES6 provide cleaner, more concise syntax for creating and manipulating objects. These improvements make JavaScript objects more powerful and easier to work with.

### Problems with Traditional Object Syntax

```javascript
// Problem 1: Repetitive property assignment
var name = "Arjun";
var age = 19;
var student = {
  name: name,
  age: age
};

// Problem 2: Verbose method definition
var calculator = {
  add: function(a, b) {
    return a + b;
  },
  subtract: function(a, b) {
    return a - b;
  }
};

// Problem 3: No dynamic property names
var propName = "score";
var obj = {};
obj[propName] = 95; // Had to do it in two steps
```

### Enhanced Object Literals Solution

```javascript
// Solution 1: Property shorthand
const name = "Arjun";
const age = 19;
const student = { name, age };

// Solution 2: Method shorthand
const calculator = {
  add(a, b) {
    return a + b;
  },
  subtract(a, b) {
    return a - b;
  }
};

// Solution 3: Computed property names
const propName = "score";
const obj = {
  [propName]: 95
};
```

---

## Property Shorthand

When a property name matches the variable name, you can omit the property value.

### Basic Property Shorthand

```javascript
// Traditional
const name = "Krishna";
const age = 20;
const city = "Surat";

const user = {
  name: name,
  age: age,
  city: city
};

// Property Shorthand
const user = { name, age, city };

console.log(user);
// { name: "Krishna", age: 20, city: "Surat" }
```

### Mixed Syntax

```javascript
// Can mix shorthand and traditional
const name = "Arjun";
const age = 19;

const student = {
  name,              // shorthand
  age,               // shorthand
  branch: "CSE",     // traditional
  year: 3            // traditional
};
```

### Function Return Values

```javascript
function getUserData() {
  const id = 101;
  const username = "arjun";
  const email = "arjun@example.com";
  const createdAt = new Date();

  // Return object using shorthand
  return { id, username, email, createdAt };
}

const user = getUserData();
console.log(user);
// {
//   id: 101,
//   username: "arjun",
//   email: "arjun@example.com",
//   createdAt: ...
// }
```

### With Destructuring

```javascript
// Destructure from function parameters, return with shorthand
function createStudent({ name, age, branch }) {
  const rollNo = Math.floor(Math.random() * 1000);
  const year = 1;
  const active = true;

  return { name, age, branch, rollNo, year, active };
}

const student = createStudent({
  name: "Mahir",
  age: 18,
  branch: "CSE"
});

console.log(student);
// {
//   name: "Mahir",
//   age: 18,
//   branch: "CSE",
//   rollNo: 742,
//   year: 1,
//   active: true
// }
```

### API Response Building

```javascript
function buildResponse(data, status = 200) {
  const timestamp = Date.now();
  const success = status >= 200 && status < 300;

  return {
    data,
    status,
    timestamp,
    success
  };
}

const response = buildResponse({ user: "Arjun" });
console.log(response);
// {
//   data: { user: "Arjun" },
//   status: 200,
//   timestamp: 1732291200000,
//   success: true
// }
```

---

## Method Shorthand

Methods can be defined without the `function` keyword.

### Basic Method Shorthand

```javascript
// Traditional
const calculator = {
  add: function(a, b) {
    return a + b;
  },
  subtract: function(a, b) {
    return a - b;
  }
};

// Method Shorthand
const calculator = {
  add(a, b) {
    return a + b;
  },
  subtract(a, b) {
    return a - b;
  }
};

console.log(calculator.add(5, 3));      // 8
console.log(calculator.subtract(10, 4)); // 6
```

### Methods with `this`

```javascript
const student = {
  name: "Arjun",
  marks: [85, 92, 78, 90],

  // Method can access other properties via this
  getAverage() {
    const sum = this.marks.reduce((a, b) => a + b, 0);
    return sum / this.marks.length;
  },

  getGrade() {
    const avg = this.getAverage();
    if (avg >= 90) return "A+";
    if (avg >= 80) return "A";
    if (avg >= 70) return "B";
    return "C";
  },

  display() {
    console.log(`${this.name}: ${this.getAverage().toFixed(2)} (${this.getGrade()})`);
  }
};

student.display(); // Arjun: 86.25 (A)
```

### Generator Methods

```javascript
const sequence = {
  *numbers(start, end) {
    for (let i = start; i <= end; i++) {
      yield i;
    }
  },

  *fibonacci(n) {
    let [a, b] = [0, 1];
    for (let i = 0; i < n; i++) {
      yield a;
      [a, b] = [b, a + b];
    }
  }
};

// Use generators
console.log([...sequence.numbers(1, 5)]); // [1, 2, 3, 4, 5]
console.log([...sequence.fibonacci(8)]);  // [0, 1, 1, 2, 3, 5, 8, 13]
```

### Async Methods

```javascript
const api = {
  baseURL: "https://api.example.com",

  async fetchUser(id) {
    const response = await fetch(`${this.baseURL}/users/${id}`);
    return response.json();
  },

  async createUser(userData) {
    const response = await fetch(`${this.baseURL}/users`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(userData)
    });
    return response.json();
  }
};

// Usage (in async context)
// const user = await api.fetchUser(101);
```

---

## Computed Property Names

Dynamically create property names using expressions in square brackets.

### Basic Computed Properties

```javascript
// Variable as property name
const propName = "score";
const student = {
  name: "Krishna",
  [propName]: 95
};

console.log(student.score); // 95

// Expression as property name
const prefix = "user";
const user = {
  [prefix + "Name"]: "Arjun",
  [prefix + "Age"]: 19,
  [prefix + "Id"]: 101
};

console.log(user.userName); // "Arjun"
console.log(user.userAge);  // 19
console.log(user.userId);   // 101
```

### With Template Literals

```javascript
const type = "student";
const id = 101;

const record = {
  [`${type}_id`]: id,
  [`${type}_name`]: "Mahir",
  [`${type}_active`]: true
};

console.log(record);
// {
//   student_id: 101,
//   student_name: "Mahir",
//   student_active: true
// }
```

### Dynamic Method Names

```javascript
const methodType = "calculate";

const math = {
  [`${methodType}Sum`](a, b) {
    return a + b;
  },
  [`${methodType}Product`](a, b) {
    return a * b;
  }
};

console.log(math.calculateSum(5, 3));     // 8
console.log(math.calculateProduct(5, 3)); // 15
```

### Symbol as Property Name

```javascript
const uniqueId = Symbol("id");
const privateData = Symbol("privateData");

const user = {
  name: "Arjun",
  [uniqueId]: 12345,
  [privateData]: {
    password: "secret",
    apiKey: "abc123"
  }
};

console.log(user.name);           // "Arjun"
console.log(user[uniqueId]);      // 12345
console.log(user[privateData]);   // { password: "secret", apiKey: "abc123" }

// Symbol properties don't show in normal iteration
console.log(Object.keys(user));   // ["name"]
```

### Building Objects Dynamically

```javascript
function createConfig(options) {
  const config = {
    version: "1.0.0"
  };

  // Add properties dynamically based on options
  for (const [key, value] of Object.entries(options)) {
    config[`feature_${key}`] = value;
  }

  return config;
}

const appConfig = createConfig({
  darkMode: true,
  notifications: false,
  autoSave: true
});

console.log(appConfig);
// {
//   version: "1.0.0",
//   feature_darkMode: true,
//   feature_notifications: false,
//   feature_autoSave: true
// }
```

### Computed Properties with Functions

```javascript
function getPropertyName() {
  return "dynamicProp";
}

const obj = {
  staticProp: "static value",
  [getPropertyName()]: "dynamic value"
};

console.log(obj.dynamicProp); // "dynamic value"

// With more complex logic
function buildPropertyName(prefix, suffix) {
  return `${prefix}_${suffix}`.toLowerCase();
}

const data = {
  [buildPropertyName("User", "Name")]: "Arjun",
  [buildPropertyName("User", "Email")]: "arjun@example.com"
};

console.log(data.user_name);  // "Arjun"
console.log(data.user_email); // "arjun@example.com"
```

---

## Concise Getters and Setters

Enhanced syntax for defining getters and setters.

### Basic Getters and Setters

```javascript
const rectangle = {
  width: 10,
  height: 20,

  // Getter
  get area() {
    return this.width * this.height;
  },

  // Setter
  set dimensions({ width, height }) {
    this.width = width;
    this.height = height;
  },

  // Another getter
  get perimeter() {
    return 2 * (this.width + this.height);
  }
};

console.log(rectangle.area);      // 200
console.log(rectangle.perimeter); // 60

rectangle.dimensions = { width: 15, height: 25 };
console.log(rectangle.area);      // 375
```

### Computed Property Names with Getters

```javascript
const propName = "fullName";

const person = {
  firstName: "Arjun",
  lastName: "Kumar",

  get [propName]() {
    return `${this.firstName} ${this.lastName}`;
  },

  set [propName](name) {
    [this.firstName, this.lastName] = name.split(" ");
  }
};

console.log(person.fullName);  // "Arjun Kumar"
person.fullName = "Krishna Patel";
console.log(person.firstName); // "Krishna"
console.log(person.lastName);  // "Patel"
```

### Validation with Setters

```javascript
const student = {
  _age: 19,

  get age() {
    return this._age;
  },

  set age(value) {
    if (typeof value !== "number" || value < 0 || value > 150) {
      throw new Error("Invalid age");
    }
    this._age = value;
  },

  _marks: [],

  get marks() {
    return [...this._marks]; // Return copy to prevent mutation
  },

  set marks(value) {
    if (!Array.isArray(value)) {
      throw new Error("Marks must be an array");
    }
    this._marks = value.filter(m => m >= 0 && m <= 100);
  },

  get average() {
    if (this._marks.length === 0) return 0;
    return this._marks.reduce((a, b) => a + b, 0) / this._marks.length;
  }
};

console.log(student.age);     // 19
student.age = 20;
console.log(student.age);     // 20

student.marks = [85, 92, 78, 150, -10, 88]; // Invalid values filtered
console.log(student.marks);   // [85, 92, 78, 88]
console.log(student.average); // 85.75
```

---

## Prototype Assignment

Set prototype directly in object literal (though less commonly used).

### Basic Prototype Assignment

```javascript
const animal = {
  speak() {
    console.log(`${this.name} makes a sound`);
  }
};

// Create object with specific prototype
const dog = {
  __proto__: animal,
  name: "Buddy",
  bark() {
    console.log(`${this.name} barks!`);
  }
};

dog.speak(); // "Buddy makes a sound" (inherited from animal)
dog.bark();  // "Buddy barks!"
```

### Modern Alternative: Object.create()

```javascript
// Preferred modern approach
const animal = {
  speak() {
    console.log(`${this.name} makes a sound`);
  }
};

const dog = Object.create(animal);
dog.name = "Buddy";
dog.bark = function() {
  console.log(`${this.name} barks!`);
};
```

---

## Super in Object Literals

Use `super` to call methods from prototype chain (ES6 feature).

### Basic Super Usage

```javascript
const parent = {
  greet() {
    return "Hello from parent";
  }
};

const child = {
  __proto__: parent,

  greet() {
    // Call parent method
    const parentGreeting = super.greet();
    return `${parentGreeting}, and hello from child`;
  }
};

console.log(child.greet());
// "Hello from parent, and hello from child"
```

### Practical Example

```javascript
const person = {
  init(name, age) {
    this.name = name;
    this.age = age;
  },
  introduce() {
    return `Hi, I'm ${this.name}`;
  }
};

const student = {
  __proto__: person,

  init(name, age, course) {
    super.init(name, age);
    this.course = course;
  },

  introduce() {
    return `${super.introduce()}, and I study ${this.course}`;
  }
};

student.init("Arjun", 19, "Computer Science");
console.log(student.introduce());
// "Hi, I'm Arjun, and I study Computer Science"
```

---

## Combining Features

Enhanced object literals shine when combining multiple features.

### All Features Together

```javascript
function createStudent(name, age, branch, ...marks) {
  const id = Math.floor(Math.random() * 1000);
  const timestamp = Date.now();

  return {
    // Property shorthand
    name,
    age,
    branch,
    id,

    // Computed property name
    [`enrolled_${timestamp}`]: true,

    // Method shorthand
    getAverage() {
      return marks.reduce((a, b) => a + b, 0) / marks.length;
    },

    getDetails() {
      return `${this.name} (${this.branch}) - Avg: ${this.getAverage().toFixed(2)}`;
    },

    // Getter
    get grade() {
      const avg = this.getAverage();
      if (avg >= 90) return "A+";
      if (avg >= 80) return "A";
      if (avg >= 70) return "B";
      return "C";
    },

    // Setter
    set updateMarks(newMarks) {
      marks = newMarks;
    },

    // Async method
    async save() {
      // Simulate API call
      return new Promise(resolve => {
        setTimeout(() => {
          console.log("Student saved:", this.name);
          resolve(true);
        }, 100);
      });
    }
  };
}

const student = createStudent("Arjun", 19, "CSE", 85, 92, 78);
console.log(student.getDetails());
console.log(student.grade);
```

### With Destructuring and Spread

```javascript
function mergeUserData(defaults, ...updates) {
  const merged = updates.reduce(
    (acc, update) => ({ ...acc, ...update }),
    { ...defaults }
  );

  const { password, ...safeData } = merged;

  return {
    // Spread safe data
    ...safeData,

    // Add computed property
    [`updated_${Date.now()}`]: true,

    // Add methods
    toJSON() {
      const { password, ...rest } = this;
      return rest;
    },

    update(newData) {
      return mergeUserData(this, newData);
    }
  };
}

const user = mergeUserData(
  { role: "user", active: true },
  { name: "Arjun", age: 19 },
  { email: "arjun@example.com", password: "secret" }
);

console.log(user.toJSON());
```

---

## Real-World Patterns

### Pattern 1: Factory Functions

```javascript
function createProduct({ name, price, category }) {
  const id = Date.now();
  let quantity = 0;

  return {
    // Public properties
    id,
    name,
    price,
    category,

    // Getter for computed property
    get inStock() {
      return quantity > 0;
    },

    get totalValue() {
      return price * quantity;
    },

    // Methods
    addStock(amount) {
      quantity += amount;
      return this;
    },

    removeStock(amount) {
      if (amount > quantity) {
        throw new Error("Insufficient stock");
      }
      quantity -= amount;
      return this;
    },

    getQuantity() {
      return quantity;
    },

    toJSON() {
      return {
        id: this.id,
        name: this.name,
        price: this.price,
        category: this.category,
        quantity: quantity,
        inStock: this.inStock
      };
    }
  };
}

const laptop = createProduct({
  name: "Laptop",
  price: 45000,
  category: "Electronics"
});

laptop.addStock(10).removeStock(3);
console.log(laptop.getQuantity()); // 7
console.log(laptop.toJSON());
```

### Pattern 2: Configuration Objects

```javascript
function createConfig(environment) {
  const isDev = environment === "development";
  const isProd = environment === "production";

  return {
    environment,

    // Computed properties based on environment
    [`${environment}_mode`]: true,

    // Different values per environment
    get apiURL() {
      return isProd
        ? "https://api.production.com"
        : "https://api.dev.com";
    },

    get debugMode() {
      return isDev;
    },

    // Methods
    getConnectionString(service) {
      const base = this.apiURL;
      return `${base}/${service}`;
    },

    validate() {
      if (!["development", "production", "test"].includes(this.environment)) {
        throw new Error("Invalid environment");
      }
      return true;
    }
  };
}

const config = createConfig("development");
console.log(config.apiURL);
console.log(config.getConnectionString("users"));
```

### Pattern 3: Event Emitter

```javascript
function createEventEmitter() {
  const events = {};

  return {
    on(event, handler) {
      if (!events[event]) {
        events[event] = [];
      }
      events[event].push(handler);
      return this;
    },

    off(event, handler) {
      if (events[event]) {
        events[event] = events[event].filter(h => h !== handler);
      }
      return this;
    },

    emit(event, ...args) {
      if (events[event]) {
        events[event].forEach(handler => handler(...args));
      }
      return this;
    },

    once(event, handler) {
      const onceHandler = (...args) => {
        handler(...args);
        this.off(event, onceHandler);
      };
      return this.on(event, onceHandler);
    },

    get eventCount() {
      return Object.keys(events).length;
    }
  };
}

const emitter = createEventEmitter();
emitter.on("user:login", user => console.log(`${user} logged in`));
emitter.emit("user:login", "Arjun");
```

### Pattern 4: State Management

```javascript
function createStore(initialState = {}) {
  let state = { ...initialState };
  const listeners = [];

  return {
    getState() {
      return { ...state };
    },

    setState(updates) {
      state = { ...state, ...updates };
      this.notify();
      return this;
    },

    subscribe(listener) {
      listeners.push(listener);
      return () => {
        const index = listeners.indexOf(listener);
        if (index > -1) listeners.splice(index, 1);
      };
    },

    notify() {
      listeners.forEach(listener => listener(this.getState()));
    },

    get listenerCount() {
      return listeners.length;
    }
  };
}

const store = createStore({ count: 0, user: null });
store.subscribe(state => console.log("State changed:", state));
store.setState({ count: 1 });
store.setState({ user: "Arjun" });
```

---

## Common Pitfalls

### 1. Arrow Functions as Methods

```javascript
// ❌ WRONG: Arrow functions don't have their own `this`
const obj = {
  name: "Arjun",
  greet: () => {
    console.log(`Hello, ${this.name}`); // `this` is not obj!
  }
};

obj.greet(); // "Hello, undefined"

// ✅ CORRECT: Use method shorthand
const obj = {
  name: "Arjun",
  greet() {
    console.log(`Hello, ${this.name}`);
  }
};

obj.greet(); // "Hello, Arjun"
```

### 2. Computed Property Name Errors

```javascript
// ❌ WRONG: Undefined variable
// const obj = {
//   [undefinedVar]: "value"
// }; // ReferenceError

// ✅ CORRECT: Ensure variable exists
const propName = "myProp";
const obj = {
  [propName]: "value"
};
```

### 3. Method Shorthand vs Property with Arrow Function

```javascript
const obj = {
  // Method shorthand - has its own `this`
  method1() {
    return this;
  },

  // Property with arrow function - no own `this`
  method2: () => {
    return this;
  }
};

console.log(obj.method1() === obj);  // true
console.log(obj.method2() === obj);  // false
```

### 4. Super Without Prototype

```javascript
// ❌ WRONG: Using super without prototype
// const obj = {
//   method() {
//     super.method(); // Error: no parent
//   }
// };

// ✅ CORRECT: Only use super with prototype chain
const parent = { method() { return "parent"; } };
const child = {
  __proto__: parent,
  method() {
    return super.method() + " and child";
  }
};
```

### 5. Mixing Shorthand Incorrectly

```javascript
// ❌ WRONG: Invalid syntax
// const obj = {
//   name: age: city: "value"
// };

// ✅ CORRECT: Proper syntax
const name = "Arjun", age = 19, city = "Ahmedabad";
const obj = {
  name,
  age,
  city
};
```

---

## Exercises

### Exercise 1: Student Creator (Easy)

Create a function `createStudent(name, age, branch, ...marks)` that returns a student object with property shorthand, methods, and a getter for average marks.

---

### Exercise 2: Dynamic Object Builder (Easy)

Write a function `buildObject(keys, values)` that creates an object with computed property names from two arrays.

```javascript
buildObject(["name", "age"], ["Arjun", 19]);
// { name: "Arjun", age: 19 }
```

---

### Exercise 3: Rectangle with Getters (Medium)

Create a `createRectangle(width, height)` factory that returns an object with getters for area, perimeter, and diagonal.

---

### Exercise 4: Cache Manager (Medium)

Implement a cache manager with methods to `set`, `get`, `has`, `delete`, and a getter for `size`.

---

### Exercise 5: Form Validator (Medium)

Create a form validator object with methods to validate email, phone, age, etc., and a `validateAll` method.

---

### Exercise 6: Shopping Cart (Hard)

Implement a shopping cart with methods to add, remove, update items, and getters for total, itemCount, and a toJSON method.

---

### Exercise 7: State Machine (Hard)

Create a state machine that manages state transitions with validation and event emission.

---

## Solutions

```javascript
// Solution 1: Student Creator
function createStudent(name, age, branch, ...marks) {
  return {
    name,
    age,
    branch,
    marks,

    get average() {
      if (this.marks.length === 0) return 0;
      return this.marks.reduce((a, b) => a + b, 0) / this.marks.length;
    },

    get grade() {
      const avg = this.average;
      if (avg >= 90) return "A+";
      if (avg >= 80) return "A";
      if (avg >= 70) return "B";
      if (avg >= 60) return "C";
      return "F";
    },

    display() {
      return `${this.name} (${this.branch}): ${this.average.toFixed(2)} - ${this.grade}`;
    }
  };
}

// Test
const student = createStudent("Arjun", 19, "CSE", 85, 92, 78, 88);
console.log(student.display());


// Solution 2: Dynamic Object Builder
function buildObject(keys, values) {
  return keys.reduce((obj, key, index) => {
    return {
      ...obj,
      [key]: values[index]
    };
  }, {});
}

// Alternative
function buildObject2(keys, values) {
  const obj = {};
  keys.forEach((key, index) => {
    obj[key] = values[index];
  });
  return obj;
}

// Test
console.log(buildObject(["name", "age", "city"], ["Arjun", 19, "Ahmedabad"]));


// Solution 3: Rectangle with Getters
function createRectangle(width, height) {
  return {
    width,
    height,

    get area() {
      return this.width * this.height;
    },

    get perimeter() {
      return 2 * (this.width + this.height);
    },

    get diagonal() {
      return Math.sqrt(this.width ** 2 + this.height ** 2);
    },

    scale(factor) {
      return createRectangle(this.width * factor, this.height * factor);
    },

    toString() {
      return `Rectangle(${this.width}x${this.height})`;
    }
  };
}

// Test
const rect = createRectangle(10, 20);
console.log(rect.area);      // 200
console.log(rect.perimeter); // 60
console.log(rect.diagonal.toFixed(2)); // 22.36


// Solution 4: Cache Manager
function createCache() {
  const cache = new Map();

  return {
    set(key, value, ttl = null) {
      const item = { value, expiresAt: ttl ? Date.now() + ttl : null };
      cache.set(key, item);
      return this;
    },

    get(key) {
      const item = cache.get(key);
      if (!item) return undefined;

      if (item.expiresAt && Date.now() > item.expiresAt) {
        cache.delete(key);
        return undefined;
      }

      return item.value;
    },

    has(key) {
      return this.get(key) !== undefined;
    },

    delete(key) {
      return cache.delete(key);
    },

    clear() {
      cache.clear();
      return this;
    },

    get size() {
      return cache.size;
    },

    keys() {
      return Array.from(cache.keys());
    }
  };
}

// Test
const cache = createCache();
cache.set("user", { name: "Arjun" });
console.log(cache.get("user"));
console.log(cache.size);


// Solution 5: Form Validator
function createValidator() {
  return {
    validateEmail(email) {
      const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      return {
        valid: regex.test(email),
        error: regex.test(email) ? null : "Invalid email format"
      };
    },

    validatePhone(phone) {
      const regex = /^\d{10}$/;
      return {
        valid: regex.test(phone),
        error: regex.test(phone) ? null : "Phone must be 10 digits"
      };
    },

    validateAge(age) {
      const valid = Number.isInteger(age) && age >= 18 && age <= 100;
      return {
        valid,
        error: valid ? null : "Age must be between 18 and 100"
      };
    },

    validateRequired(value) {
      const valid = value !== null && value !== undefined && value !== "";
      return {
        valid,
        error: valid ? null : "This field is required"
      };
    },

    validateAll(data, rules) {
      const errors = {};

      for (const [field, validators] of Object.entries(rules)) {
        for (const validator of validators) {
          const result = this[validator](data[field]);
          if (!result.valid) {
            errors[field] = result.error;
            break;
          }
        }
      }

      return {
        valid: Object.keys(errors).length === 0,
        errors
      };
    }
  };
}

// Test
const validator = createValidator();
console.log(validator.validateEmail("test@example.com"));
console.log(validator.validateAll(
  { email: "invalid", age: 15 },
  { email: ["validateEmail"], age: ["validateAge"] }
));


// Solution 6: Shopping Cart
function createShoppingCart() {
  const items = [];

  return {
    add(product, quantity = 1) {
      const existing = items.find(item => item.product.id === product.id);
      if (existing) {
        existing.quantity += quantity;
      } else {
        items.push({ product, quantity });
      }
      return this;
    },

    remove(productId) {
      const index = items.findIndex(item => item.product.id === productId);
      if (index > -1) {
        items.splice(index, 1);
      }
      return this;
    },

    updateQuantity(productId, quantity) {
      const item = items.find(item => item.product.id === productId);
      if (item) {
        item.quantity = quantity;
      }
      return this;
    },

    clear() {
      items.length = 0;
      return this;
    },

    get total() {
      return items.reduce((sum, item) => sum + (item.product.price * item.quantity), 0);
    },

    get itemCount() {
      return items.reduce((count, item) => count + item.quantity, 0);
    },

    get items() {
      return items.map(item => ({ ...item }));
    },

    toJSON() {
      return {
        items: this.items,
        total: this.total,
        itemCount: this.itemCount
      };
    }
  };
}

// Test
const cart = createShoppingCart();
cart.add({ id: 1, name: "Laptop", price: 45000 }, 1);
cart.add({ id: 2, name: "Mouse", price: 500 }, 2);
console.log(cart.toJSON());


// Solution 7: State Machine
function createStateMachine(initialState, transitions) {
  let currentState = initialState;
  const listeners = [];

  return {
    get state() {
      return currentState;
    },

    transition(action) {
      const validTransitions = transitions[currentState];
      if (!validTransitions || !validTransitions[action]) {
        throw new Error(`Invalid transition: ${currentState} -> ${action}`);
      }

      const previousState = currentState;
      currentState = validTransitions[action];

      this.emit("transition", { from: previousState, to: currentState, action });

      return this;
    },

    on(event, handler) {
      listeners.push({ event, handler });
      return this;
    },

    emit(event, data) {
      listeners
        .filter(listener => listener.event === event)
        .forEach(listener => listener.handler(data));
    },

    canTransition(action) {
      const validTransitions = transitions[currentState];
      return validTransitions && action in validTransitions;
    }
  };
}

// Test
const machine = createStateMachine("idle", {
  idle: { start: "running" },
  running: { pause: "paused", stop: "stopped" },
  paused: { resume: "running", stop: "stopped" },
  stopped: { reset: "idle" }
});

machine.on("transition", ({ from, to, action }) => {
  console.log(`${from} --[${action}]--> ${to}`);
});

machine.transition("start");  // idle --[start]--> running
machine.transition("pause");  // running --[pause]--> paused
machine.transition("resume"); // paused --[resume]--> running
```

---

## Tests

```javascript
/**
 * Test Suite for Enhanced Object Literals
 * Run with: node 17_enhanced_object_literals_tests.js
 */

function assert(condition, message) {
  if (!condition) {
    console.error(`❌ FAILED: ${message}`);
  } else {
    console.log(`✅ PASSED: ${message}`);
  }
}

console.log('╔════════════════════════════════════════════════════════════════╗');
console.log('║  Enhanced Object Literals - Test Suite                        ║');
console.log('╚════════════════════════════════════════════════════════════════╝\n');

// Test Exercise 1
console.log('--- Testing Exercise 1: Student Creator ---');
const student = createStudent("Arjun", 19, "CSE", 85, 92, 78);
assert(student.name === "Arjun", "Has correct name");
assert(student.average === 85, "Calculates average correctly");
assert(student.grade === "A", "Assigns correct grade");
assert(typeof student.display === "function", "Has display method");

// Test Exercise 2
console.log('\n--- Testing Exercise 2: Dynamic Object Builder ---');
const obj = buildObject(["name", "age", "city"], ["Krishna", 20, "Surat"]);
assert(obj.name === "Krishna", "Sets first property");
assert(obj.age === 20, "Sets second property");
assert(obj.city === "Surat", "Sets third property");

// Test Exercise 3
console.log('\n--- Testing Exercise 3: Rectangle with Getters ---');
const rect = createRectangle(10, 20);
assert(rect.area === 200, "Calculates area");
assert(rect.perimeter === 60, "Calculates perimeter");
assert(rect.diagonal > 22 && rect.diagonal < 23, "Calculates diagonal");

// Test Exercise 4
console.log('\n--- Testing Exercise 4: Cache Manager ---');
const cache = createCache();
cache.set("key1", "value1");
assert(cache.get("key1") === "value1", "Sets and gets values");
assert(cache.has("key1"), "Checks if key exists");
assert(cache.size === 1, "Reports correct size");
cache.delete("key1");
assert(!cache.has("key1"), "Deletes keys");

// Test Exercise 5
console.log('\n--- Testing Exercise 5: Form Validator ---');
const validator = createValidator();
const emailResult = validator.validateEmail("test@example.com");
assert(emailResult.valid, "Validates correct email");
const phoneResult = validator.validatePhone("9876543210");
assert(phoneResult.valid, "Validates correct phone");

// Test Exercise 6
console.log('\n--- Testing Exercise 6: Shopping Cart ---');
const cart = createShoppingCart();
cart.add({ id: 1, name: "Laptop", price: 1000 }, 2);
assert(cart.itemCount === 2, "Tracks item count");
assert(cart.total === 2000, "Calculates total");
cart.remove(1);
assert(cart.itemCount === 0, "Removes items");

// Test Exercise 7
console.log('\n--- Testing Exercise 7: State Machine ---');
const machine = createStateMachine("idle", {
  idle: { start: "running" },
  running: { stop: "stopped" },
  stopped: { reset: "idle" }
});

assert(machine.state === "idle", "Initializes correctly");
machine.transition("start");
assert(machine.state === "running", "Transitions correctly");
assert(machine.canTransition("stop"), "Checks valid transitions");
assert(!machine.canTransition("invalid"), "Rejects invalid transitions");

console.log('\n╔════════════════════════════════════════════════════════════════╗');
console.log('║  All Tests Completed                                           ║');
console.log('╚════════════════════════════════════════════════════════════════╝\n');
```

---

## Summary

Enhanced Object Literals provide powerful, concise syntax for modern JavaScript development:

**Key Takeaways:**

1. **Property shorthand**: Omit value when name matches variable
2. **Method shorthand**: No `function` keyword needed
3. **Computed properties**: Dynamic property names with `[]`
4. **Getters/setters**: Clean accessor syntax
5. **Super**: Access parent methods in prototype chain
6. **Combine features**: Mix with destructuring, spread, etc.
7. **Avoid arrow functions as methods**: Use method shorthand for proper `this`

Master enhanced object literals to write cleaner, more maintainable object-oriented JavaScript!

---

**Last Updated**: 2025-11-22
**Version**: 1.0.0
